use crate::rcl::{rosidl_message_type_support_t, rosidl_service_type_support_t};
/* automatically generated by rust-bindgen 0.59.2 */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &[u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Bool {
    pub data: bool,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Bool() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Bool>(),
        1usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Bool))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Bool>(),
        1usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__Bool))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_msgs__msg__Bool>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Bool),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Bool__Sequence {
    pub data: *mut std_msgs__msg__Bool,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Bool__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Bool__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Bool__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Bool__Sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__Bool__Sequence))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Bool__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Bool__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Bool__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Bool__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Bool__Sequence>())).capacity as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Bool__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type ssize_t = __ssize_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: size_t, __size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __pwcs: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        __s: *mut ::std::os::raw::c_char,
        __pwcs: *const wchar_t,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Initialize msg/Bool message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__Bool"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__Bool__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Bool__init(msg: *mut std_msgs__msg__Bool) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Bool message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Bool__fini(msg: *mut std_msgs__msg__Bool);
}
extern "C" {
    #[doc = " Create msg/Bool message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__Bool__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Bool__create() -> *mut std_msgs__msg__Bool;
}
extern "C" {
    #[doc = " Destroy msg/Bool message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Bool__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Bool__destroy(msg: *mut std_msgs__msg__Bool);
}
extern "C" {
    #[doc = " Check for msg/Bool message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Bool__are_equal(
        lhs: *const std_msgs__msg__Bool,
        rhs: *const std_msgs__msg__Bool,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Bool message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Bool__copy(
        input: *const std_msgs__msg__Bool,
        output: *mut std_msgs__msg__Bool,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Bool messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__Bool__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Bool__Sequence__init(
        array: *mut std_msgs__msg__Bool__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Bool messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Bool__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Bool__Sequence__fini(array: *mut std_msgs__msg__Bool__Sequence);
}
extern "C" {
    #[doc = " Create array of msg/Bool messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__Bool__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Bool__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__Bool__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Bool messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Bool__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Bool__Sequence__destroy(array: *mut std_msgs__msg__Bool__Sequence);
}
extern "C" {
    #[doc = " Check for msg/Bool message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Bool__Sequence__are_equal(
        lhs: *const std_msgs__msg__Bool__Sequence,
        rhs: *const std_msgs__msg__Bool__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Bool messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Bool__Sequence__copy(
        input: *const std_msgs__msg__Bool__Sequence,
        output: *mut std_msgs__msg__Bool__Sequence,
    ) -> bool;
}
pub type rosidl_message_typesupport_handle_function = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const rosidl_message_type_support_t,
        arg2: *const ::std::os::raw::c_char,
    ) -> *const rosidl_message_type_support_t,
>;
#[doc = " Contains rosidl message type support data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
struct rosidl_message_type_support_t_ {
    #[doc = " String identifier for the type_support."]
    pub typesupport_identifier: *const ::std::os::raw::c_char,
    #[doc = " Pointer to the message type support library"]
    pub data: *const ::std::os::raw::c_void,
    #[doc = " Pointer to the message type support handler function"]
    pub func: rosidl_message_typesupport_handle_function,
}
#[test]
fn bindgen_test_layout_rosidl_message_type_support_t() {
    assert_eq!(
        ::std::mem::size_of::<rosidl_message_type_support_t>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_message_type_support_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_message_type_support_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rosidl_message_type_support_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_message_type_support_t>())).typesupport_identifier
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_message_type_support_t),
            "::",
            stringify!(typesupport_identifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_message_type_support_t>())).data as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_message_type_support_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_message_type_support_t>())).func as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_message_type_support_t),
            "::",
            stringify!(func)
        )
    );
}
extern "C" {
    #[doc = " Get the message type support handle specific to this identifier."]
    #[doc = "**"]
    #[doc = "* The handle's message typesupport identifier function is returned or if the parameters are NULL"]
    #[doc = "* then an assert will happen."]
    #[doc = "*"]
    #[doc = "* \\param handle Handle to message type support"]
    #[doc = "* \\param identifier The typesupport identifier to get the handle function for"]
    #[doc = "* \\return The associated message typesupport handle function."]
    #[doc = "*/"]
    pub fn get_message_typesupport_handle(
        handle: *const rosidl_message_type_support_t,
        identifier: *const ::std::os::raw::c_char,
    ) -> *const rosidl_message_type_support_t;
}
extern "C" {
    #[doc = " If the identifier is the same as this handle's typesupport_identifier the handle is simply"]
    #[doc = " returned or if the parameters are NULL then an assert will happen."]
    #[doc = ""]
    #[doc = " \\param handle Handle to message type support"]
    #[doc = " \\param identifier The typesupport identifier to get the handle function for"]
    #[doc = " \\return if the identifier match's the handle's identifier then the handle's function"]
    #[doc = "   is returned."]
    pub fn get_message_typesupport_handle_function(
        handle: *const rosidl_message_type_support_t,
        identifier: *const ::std::os::raw::c_char,
    ) -> *const rosidl_message_type_support_t;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__Bool(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Byte {
    pub data: u8,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Byte() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Byte>(),
        1usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Byte))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Byte>(),
        1usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__Byte))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_msgs__msg__Byte>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Byte),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Byte__Sequence {
    pub data: *mut std_msgs__msg__Byte,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Byte__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Byte__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Byte__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Byte__Sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__Byte__Sequence))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Byte__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Byte__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Byte__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Byte__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Byte__Sequence>())).capacity as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Byte__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Byte message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__Byte"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__Byte__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Byte__init(msg: *mut std_msgs__msg__Byte) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Byte message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Byte__fini(msg: *mut std_msgs__msg__Byte);
}
extern "C" {
    #[doc = " Create msg/Byte message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__Byte__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Byte__create() -> *mut std_msgs__msg__Byte;
}
extern "C" {
    #[doc = " Destroy msg/Byte message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Byte__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Byte__destroy(msg: *mut std_msgs__msg__Byte);
}
extern "C" {
    #[doc = " Check for msg/Byte message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Byte__are_equal(
        lhs: *const std_msgs__msg__Byte,
        rhs: *const std_msgs__msg__Byte,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Byte message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Byte__copy(
        input: *const std_msgs__msg__Byte,
        output: *mut std_msgs__msg__Byte,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Byte messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__Byte__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Byte__Sequence__init(
        array: *mut std_msgs__msg__Byte__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Byte messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Byte__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Byte__Sequence__fini(array: *mut std_msgs__msg__Byte__Sequence);
}
extern "C" {
    #[doc = " Create array of msg/Byte messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__Byte__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Byte__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__Byte__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Byte messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Byte__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Byte__Sequence__destroy(array: *mut std_msgs__msg__Byte__Sequence);
}
extern "C" {
    #[doc = " Check for msg/Byte message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Byte__Sequence__are_equal(
        lhs: *const std_msgs__msg__Byte__Sequence,
        rhs: *const std_msgs__msg__Byte__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Byte messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Byte__Sequence__copy(
        input: *const std_msgs__msg__Byte__Sequence,
        output: *mut std_msgs__msg__Byte__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__Byte(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__float__Sequence {
    pub data: *mut f32,
    pub size: size_t,
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__float__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__float__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__float__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__float__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__float__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__float__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__float__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__float__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__float__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__float__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__float__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__double__Sequence {
    pub data: *mut f64,
    pub size: size_t,
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__double__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__double__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__double__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__double__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__double__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__double__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__double__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__double__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__double__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__double__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__double__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__long_double__Sequence {
    pub data: *mut u128,
    pub size: size_t,
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__long_double__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__long_double__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(rosidl_runtime_c__long_double__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__long_double__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__long_double__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__long_double__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__long_double__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__long_double__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__long_double__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__long_double__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__long_double__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__char__Sequence {
    pub data: *mut ::std::os::raw::c_schar,
    pub size: size_t,
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__char__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__char__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__char__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__char__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__char__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__char__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__char__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__char__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__char__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__char__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__char__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__wchar__Sequence {
    pub data: *mut u16,
    pub size: size_t,
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__wchar__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__wchar__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__wchar__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__wchar__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__wchar__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__wchar__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__wchar__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__wchar__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__wchar__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__wchar__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__wchar__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__boolean__Sequence {
    pub data: *mut bool,
    pub size: size_t,
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__boolean__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__boolean__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__boolean__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__boolean__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__boolean__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__boolean__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__boolean__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__boolean__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__boolean__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__boolean__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__boolean__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__octet__Sequence {
    pub data: *mut u8,
    pub size: size_t,
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__octet__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__octet__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__octet__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__octet__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__octet__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__octet__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__octet__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__octet__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__octet__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__octet__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__octet__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__uint8__Sequence {
    pub data: *mut u8,
    pub size: size_t,
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__uint8__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__uint8__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__uint8__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__uint8__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__uint8__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__uint8__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint8__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__uint8__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint8__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__uint8__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint8__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__int8__Sequence {
    pub data: *mut i8,
    pub size: size_t,
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__int8__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__int8__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__int8__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__int8__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__int8__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__int8__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int8__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__int8__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int8__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__int8__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int8__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__uint16__Sequence {
    pub data: *mut u16,
    pub size: size_t,
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__uint16__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__uint16__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__uint16__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__uint16__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__uint16__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__uint16__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint16__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__uint16__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint16__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__uint16__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint16__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__int16__Sequence {
    pub data: *mut i16,
    pub size: size_t,
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__int16__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__int16__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__int16__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__int16__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__int16__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__int16__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int16__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__int16__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int16__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__int16__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int16__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__uint32__Sequence {
    pub data: *mut u32,
    pub size: size_t,
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__uint32__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__uint32__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__uint32__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__uint32__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__uint32__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__uint32__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint32__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__uint32__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint32__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__uint32__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint32__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__int32__Sequence {
    pub data: *mut i32,
    pub size: size_t,
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__int32__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__int32__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__int32__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__int32__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__int32__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__int32__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int32__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__int32__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int32__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__int32__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int32__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__uint64__Sequence {
    pub data: *mut u64,
    pub size: size_t,
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__uint64__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__uint64__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__uint64__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__uint64__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__uint64__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__uint64__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint64__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__uint64__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint64__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__uint64__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__uint64__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__int64__Sequence {
    pub data: *mut i64,
    pub size: size_t,
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__int64__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__int64__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__int64__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__int64__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__int64__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__int64__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int64__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__int64__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int64__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__int64__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__int64__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
pub type rosidl_runtime_c__bool__Sequence = rosidl_runtime_c__boolean__Sequence;
pub type rosidl_runtime_c__byte__Sequence = rosidl_runtime_c__octet__Sequence;
pub type rosidl_runtime_c__float32__Sequence = rosidl_runtime_c__float__Sequence;
pub type rosidl_runtime_c__float64__Sequence = rosidl_runtime_c__double__Sequence;
#[doc = " An array of 8-bit characters terminated by a null byte."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__String {
    #[doc = " The pointer to the first character, the sequence ends with a null byte."]
    pub data: *mut ::std::os::raw::c_char,
    #[doc = " The length of the string (excluding the null byte)."]
    pub size: size_t,
    #[doc = " The capacity represents the number of allocated bytes (including the null byte)."]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__String() {
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__String>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__String))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__String>(),
        8usize,
        concat!("Alignment of ", stringify!(rosidl_runtime_c__String))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rosidl_runtime_c__String>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__String),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rosidl_runtime_c__String>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__String),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__String>())).capacity as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__String),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__String__Sequence {
    pub data: *mut rosidl_runtime_c__String,
    pub size: size_t,
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__String__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__String__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__String__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__String__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rosidl_runtime_c__String__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__String__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__String__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__String__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__String__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__String__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__String__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__MultiArrayDimension {
    pub label: rosidl_runtime_c__String,
    pub size: u32,
    pub stride: u32,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__MultiArrayDimension() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__MultiArrayDimension>(),
        32usize,
        concat!("Size of: ", stringify!(std_msgs__msg__MultiArrayDimension))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__MultiArrayDimension>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std_msgs__msg__MultiArrayDimension)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__MultiArrayDimension>())).label as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__MultiArrayDimension),
            "::",
            stringify!(label)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__MultiArrayDimension>())).size as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__MultiArrayDimension),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__MultiArrayDimension>())).stride as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__MultiArrayDimension),
            "::",
            stringify!(stride)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__MultiArrayDimension__Sequence {
    pub data: *mut std_msgs__msg__MultiArrayDimension,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__MultiArrayDimension__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__MultiArrayDimension__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(std_msgs__msg__MultiArrayDimension__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__MultiArrayDimension__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std_msgs__msg__MultiArrayDimension__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__MultiArrayDimension__Sequence>())).data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__MultiArrayDimension__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__MultiArrayDimension__Sequence>())).size
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__MultiArrayDimension__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__MultiArrayDimension__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__MultiArrayDimension__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__MultiArrayLayout {
    pub dim: std_msgs__msg__MultiArrayDimension__Sequence,
    pub data_offset: u32,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__MultiArrayLayout() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__MultiArrayLayout>(),
        32usize,
        concat!("Size of: ", stringify!(std_msgs__msg__MultiArrayLayout))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__MultiArrayLayout>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__MultiArrayLayout))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__MultiArrayLayout>())).dim as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__MultiArrayLayout),
            "::",
            stringify!(dim)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__MultiArrayLayout>())).data_offset as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__MultiArrayLayout),
            "::",
            stringify!(data_offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__MultiArrayLayout__Sequence {
    pub data: *mut std_msgs__msg__MultiArrayLayout,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__MultiArrayLayout__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__MultiArrayLayout__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(std_msgs__msg__MultiArrayLayout__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__MultiArrayLayout__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std_msgs__msg__MultiArrayLayout__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__MultiArrayLayout__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__MultiArrayLayout__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__MultiArrayLayout__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__MultiArrayLayout__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__MultiArrayLayout__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__MultiArrayLayout__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__ByteMultiArray {
    pub layout: std_msgs__msg__MultiArrayLayout,
    pub data: rosidl_runtime_c__octet__Sequence,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__ByteMultiArray() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__ByteMultiArray>(),
        56usize,
        concat!("Size of: ", stringify!(std_msgs__msg__ByteMultiArray))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__ByteMultiArray>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__ByteMultiArray))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__ByteMultiArray>())).layout as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__ByteMultiArray),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__ByteMultiArray>())).data as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__ByteMultiArray),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__ByteMultiArray__Sequence {
    pub data: *mut std_msgs__msg__ByteMultiArray,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__ByteMultiArray__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__ByteMultiArray__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(std_msgs__msg__ByteMultiArray__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__ByteMultiArray__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std_msgs__msg__ByteMultiArray__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__ByteMultiArray__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__ByteMultiArray__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__ByteMultiArray__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__ByteMultiArray__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__ByteMultiArray__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__ByteMultiArray__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/ByteMultiArray message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__ByteMultiArray"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__ByteMultiArray__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__ByteMultiArray__init(msg: *mut std_msgs__msg__ByteMultiArray) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/ByteMultiArray message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__ByteMultiArray__fini(msg: *mut std_msgs__msg__ByteMultiArray);
}
extern "C" {
    #[doc = " Create msg/ByteMultiArray message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__ByteMultiArray__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__ByteMultiArray__create() -> *mut std_msgs__msg__ByteMultiArray;
}
extern "C" {
    #[doc = " Destroy msg/ByteMultiArray message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__ByteMultiArray__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__ByteMultiArray__destroy(msg: *mut std_msgs__msg__ByteMultiArray);
}
extern "C" {
    #[doc = " Check for msg/ByteMultiArray message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__ByteMultiArray__are_equal(
        lhs: *const std_msgs__msg__ByteMultiArray,
        rhs: *const std_msgs__msg__ByteMultiArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/ByteMultiArray message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__ByteMultiArray__copy(
        input: *const std_msgs__msg__ByteMultiArray,
        output: *mut std_msgs__msg__ByteMultiArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/ByteMultiArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__ByteMultiArray__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__ByteMultiArray__Sequence__init(
        array: *mut std_msgs__msg__ByteMultiArray__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/ByteMultiArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__ByteMultiArray__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__ByteMultiArray__Sequence__fini(
        array: *mut std_msgs__msg__ByteMultiArray__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/ByteMultiArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__ByteMultiArray__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__ByteMultiArray__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__ByteMultiArray__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/ByteMultiArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__ByteMultiArray__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__ByteMultiArray__Sequence__destroy(
        array: *mut std_msgs__msg__ByteMultiArray__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/ByteMultiArray message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__ByteMultiArray__Sequence__are_equal(
        lhs: *const std_msgs__msg__ByteMultiArray__Sequence,
        rhs: *const std_msgs__msg__ByteMultiArray__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/ByteMultiArray messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__ByteMultiArray__Sequence__copy(
        input: *const std_msgs__msg__ByteMultiArray__Sequence,
        output: *mut std_msgs__msg__ByteMultiArray__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__ByteMultiArray(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Char {
    pub data: u8,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Char() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Char>(),
        1usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Char))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Char>(),
        1usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__Char))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_msgs__msg__Char>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Char),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Char__Sequence {
    pub data: *mut std_msgs__msg__Char,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Char__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Char__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Char__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Char__Sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__Char__Sequence))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Char__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Char__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Char__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Char__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Char__Sequence>())).capacity as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Char__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Char message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__Char"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__Char__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Char__init(msg: *mut std_msgs__msg__Char) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Char message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Char__fini(msg: *mut std_msgs__msg__Char);
}
extern "C" {
    #[doc = " Create msg/Char message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__Char__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Char__create() -> *mut std_msgs__msg__Char;
}
extern "C" {
    #[doc = " Destroy msg/Char message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Char__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Char__destroy(msg: *mut std_msgs__msg__Char);
}
extern "C" {
    #[doc = " Check for msg/Char message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Char__are_equal(
        lhs: *const std_msgs__msg__Char,
        rhs: *const std_msgs__msg__Char,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Char message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Char__copy(
        input: *const std_msgs__msg__Char,
        output: *mut std_msgs__msg__Char,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Char messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__Char__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Char__Sequence__init(
        array: *mut std_msgs__msg__Char__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Char messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Char__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Char__Sequence__fini(array: *mut std_msgs__msg__Char__Sequence);
}
extern "C" {
    #[doc = " Create array of msg/Char messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__Char__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Char__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__Char__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Char messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Char__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Char__Sequence__destroy(array: *mut std_msgs__msg__Char__Sequence);
}
extern "C" {
    #[doc = " Check for msg/Char message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Char__Sequence__are_equal(
        lhs: *const std_msgs__msg__Char__Sequence,
        rhs: *const std_msgs__msg__Char__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Char messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Char__Sequence__copy(
        input: *const std_msgs__msg__Char__Sequence,
        output: *mut std_msgs__msg__Char__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__Char(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__ColorRGBA {
    pub r: f32,
    pub g: f32,
    pub b: f32,
    pub a: f32,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__ColorRGBA() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__ColorRGBA>(),
        16usize,
        concat!("Size of: ", stringify!(std_msgs__msg__ColorRGBA))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__ColorRGBA>(),
        4usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__ColorRGBA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_msgs__msg__ColorRGBA>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__ColorRGBA),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_msgs__msg__ColorRGBA>())).g as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__ColorRGBA),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_msgs__msg__ColorRGBA>())).b as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__ColorRGBA),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_msgs__msg__ColorRGBA>())).a as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__ColorRGBA),
            "::",
            stringify!(a)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__ColorRGBA__Sequence {
    pub data: *mut std_msgs__msg__ColorRGBA,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__ColorRGBA__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__ColorRGBA__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(std_msgs__msg__ColorRGBA__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__ColorRGBA__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std_msgs__msg__ColorRGBA__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__ColorRGBA__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__ColorRGBA__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__ColorRGBA__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__ColorRGBA__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__ColorRGBA__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__ColorRGBA__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/ColorRGBA message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__ColorRGBA"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__ColorRGBA__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__ColorRGBA__init(msg: *mut std_msgs__msg__ColorRGBA) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/ColorRGBA message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__ColorRGBA__fini(msg: *mut std_msgs__msg__ColorRGBA);
}
extern "C" {
    #[doc = " Create msg/ColorRGBA message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__ColorRGBA__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__ColorRGBA__create() -> *mut std_msgs__msg__ColorRGBA;
}
extern "C" {
    #[doc = " Destroy msg/ColorRGBA message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__ColorRGBA__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__ColorRGBA__destroy(msg: *mut std_msgs__msg__ColorRGBA);
}
extern "C" {
    #[doc = " Check for msg/ColorRGBA message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__ColorRGBA__are_equal(
        lhs: *const std_msgs__msg__ColorRGBA,
        rhs: *const std_msgs__msg__ColorRGBA,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/ColorRGBA message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__ColorRGBA__copy(
        input: *const std_msgs__msg__ColorRGBA,
        output: *mut std_msgs__msg__ColorRGBA,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/ColorRGBA messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__ColorRGBA__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__ColorRGBA__Sequence__init(
        array: *mut std_msgs__msg__ColorRGBA__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/ColorRGBA messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__ColorRGBA__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__ColorRGBA__Sequence__fini(array: *mut std_msgs__msg__ColorRGBA__Sequence);
}
extern "C" {
    #[doc = " Create array of msg/ColorRGBA messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__ColorRGBA__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__ColorRGBA__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__ColorRGBA__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/ColorRGBA messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__ColorRGBA__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__ColorRGBA__Sequence__destroy(
        array: *mut std_msgs__msg__ColorRGBA__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/ColorRGBA message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__ColorRGBA__Sequence__are_equal(
        lhs: *const std_msgs__msg__ColorRGBA__Sequence,
        rhs: *const std_msgs__msg__ColorRGBA__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/ColorRGBA messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__ColorRGBA__Sequence__copy(
        input: *const std_msgs__msg__ColorRGBA__Sequence,
        output: *mut std_msgs__msg__ColorRGBA__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__ColorRGBA(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Empty {
    pub structure_needs_at_least_one_member: u8,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Empty() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Empty>(),
        1usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Empty))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Empty>(),
        1usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__Empty))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Empty>())).structure_needs_at_least_one_member
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Empty),
            "::",
            stringify!(structure_needs_at_least_one_member)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Empty__Sequence {
    pub data: *mut std_msgs__msg__Empty,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Empty__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Empty__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Empty__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Empty__Sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__Empty__Sequence))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Empty__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Empty__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Empty__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Empty__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Empty__Sequence>())).capacity as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Empty__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Empty message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__Empty"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__Empty__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Empty__init(msg: *mut std_msgs__msg__Empty) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Empty message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Empty__fini(msg: *mut std_msgs__msg__Empty);
}
extern "C" {
    #[doc = " Create msg/Empty message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__Empty__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Empty__create() -> *mut std_msgs__msg__Empty;
}
extern "C" {
    #[doc = " Destroy msg/Empty message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Empty__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Empty__destroy(msg: *mut std_msgs__msg__Empty);
}
extern "C" {
    #[doc = " Check for msg/Empty message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Empty__are_equal(
        lhs: *const std_msgs__msg__Empty,
        rhs: *const std_msgs__msg__Empty,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Empty message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Empty__copy(
        input: *const std_msgs__msg__Empty,
        output: *mut std_msgs__msg__Empty,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Empty messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__Empty__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Empty__Sequence__init(
        array: *mut std_msgs__msg__Empty__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Empty messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Empty__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Empty__Sequence__fini(array: *mut std_msgs__msg__Empty__Sequence);
}
extern "C" {
    #[doc = " Create array of msg/Empty messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__Empty__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Empty__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__Empty__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Empty messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Empty__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Empty__Sequence__destroy(array: *mut std_msgs__msg__Empty__Sequence);
}
extern "C" {
    #[doc = " Check for msg/Empty message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Empty__Sequence__are_equal(
        lhs: *const std_msgs__msg__Empty__Sequence,
        rhs: *const std_msgs__msg__Empty__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Empty messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Empty__Sequence__copy(
        input: *const std_msgs__msg__Empty__Sequence,
        output: *mut std_msgs__msg__Empty__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__Empty(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Float32 {
    pub data: f32,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Float32() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Float32>(),
        4usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Float32))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Float32>(),
        4usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__Float32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_msgs__msg__Float32>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Float32),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Float32__Sequence {
    pub data: *mut std_msgs__msg__Float32,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Float32__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Float32__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Float32__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Float32__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std_msgs__msg__Float32__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Float32__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Float32__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Float32__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Float32__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Float32__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Float32__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Float32 message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__Float32"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__Float32__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float32__init(msg: *mut std_msgs__msg__Float32) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Float32 message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float32__fini(msg: *mut std_msgs__msg__Float32);
}
extern "C" {
    #[doc = " Create msg/Float32 message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__Float32__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float32__create() -> *mut std_msgs__msg__Float32;
}
extern "C" {
    #[doc = " Destroy msg/Float32 message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Float32__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float32__destroy(msg: *mut std_msgs__msg__Float32);
}
extern "C" {
    #[doc = " Check for msg/Float32 message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float32__are_equal(
        lhs: *const std_msgs__msg__Float32,
        rhs: *const std_msgs__msg__Float32,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Float32 message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float32__copy(
        input: *const std_msgs__msg__Float32,
        output: *mut std_msgs__msg__Float32,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Float32 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__Float32__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float32__Sequence__init(
        array: *mut std_msgs__msg__Float32__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Float32 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Float32__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float32__Sequence__fini(array: *mut std_msgs__msg__Float32__Sequence);
}
extern "C" {
    #[doc = " Create array of msg/Float32 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__Float32__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float32__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__Float32__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Float32 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Float32__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float32__Sequence__destroy(array: *mut std_msgs__msg__Float32__Sequence);
}
extern "C" {
    #[doc = " Check for msg/Float32 message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float32__Sequence__are_equal(
        lhs: *const std_msgs__msg__Float32__Sequence,
        rhs: *const std_msgs__msg__Float32__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Float32 messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float32__Sequence__copy(
        input: *const std_msgs__msg__Float32__Sequence,
        output: *mut std_msgs__msg__Float32__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__Float32(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Float32MultiArray {
    pub layout: std_msgs__msg__MultiArrayLayout,
    pub data: rosidl_runtime_c__float__Sequence,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Float32MultiArray() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Float32MultiArray>(),
        56usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Float32MultiArray))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Float32MultiArray>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std_msgs__msg__Float32MultiArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Float32MultiArray>())).layout as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Float32MultiArray),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Float32MultiArray>())).data as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Float32MultiArray),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Float32MultiArray__Sequence {
    pub data: *mut std_msgs__msg__Float32MultiArray,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Float32MultiArray__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Float32MultiArray__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(std_msgs__msg__Float32MultiArray__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Float32MultiArray__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std_msgs__msg__Float32MultiArray__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Float32MultiArray__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Float32MultiArray__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Float32MultiArray__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Float32MultiArray__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Float32MultiArray__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Float32MultiArray__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Float32MultiArray message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__Float32MultiArray"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__Float32MultiArray__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float32MultiArray__init(
        msg: *mut std_msgs__msg__Float32MultiArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Float32MultiArray message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float32MultiArray__fini(msg: *mut std_msgs__msg__Float32MultiArray);
}
extern "C" {
    #[doc = " Create msg/Float32MultiArray message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__Float32MultiArray__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float32MultiArray__create() -> *mut std_msgs__msg__Float32MultiArray;
}
extern "C" {
    #[doc = " Destroy msg/Float32MultiArray message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Float32MultiArray__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float32MultiArray__destroy(msg: *mut std_msgs__msg__Float32MultiArray);
}
extern "C" {
    #[doc = " Check for msg/Float32MultiArray message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float32MultiArray__are_equal(
        lhs: *const std_msgs__msg__Float32MultiArray,
        rhs: *const std_msgs__msg__Float32MultiArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Float32MultiArray message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float32MultiArray__copy(
        input: *const std_msgs__msg__Float32MultiArray,
        output: *mut std_msgs__msg__Float32MultiArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Float32MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__Float32MultiArray__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float32MultiArray__Sequence__init(
        array: *mut std_msgs__msg__Float32MultiArray__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Float32MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Float32MultiArray__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float32MultiArray__Sequence__fini(
        array: *mut std_msgs__msg__Float32MultiArray__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/Float32MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__Float32MultiArray__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float32MultiArray__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__Float32MultiArray__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Float32MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Float32MultiArray__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float32MultiArray__Sequence__destroy(
        array: *mut std_msgs__msg__Float32MultiArray__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Float32MultiArray message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float32MultiArray__Sequence__are_equal(
        lhs: *const std_msgs__msg__Float32MultiArray__Sequence,
        rhs: *const std_msgs__msg__Float32MultiArray__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Float32MultiArray messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float32MultiArray__Sequence__copy(
        input: *const std_msgs__msg__Float32MultiArray__Sequence,
        output: *mut std_msgs__msg__Float32MultiArray__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__Float32MultiArray(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Float64 {
    pub data: f64,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Float64() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Float64>(),
        8usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Float64))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Float64>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__Float64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_msgs__msg__Float64>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Float64),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Float64__Sequence {
    pub data: *mut std_msgs__msg__Float64,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Float64__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Float64__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Float64__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Float64__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std_msgs__msg__Float64__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Float64__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Float64__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Float64__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Float64__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Float64__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Float64__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Float64 message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__Float64"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__Float64__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float64__init(msg: *mut std_msgs__msg__Float64) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Float64 message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float64__fini(msg: *mut std_msgs__msg__Float64);
}
extern "C" {
    #[doc = " Create msg/Float64 message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__Float64__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float64__create() -> *mut std_msgs__msg__Float64;
}
extern "C" {
    #[doc = " Destroy msg/Float64 message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Float64__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float64__destroy(msg: *mut std_msgs__msg__Float64);
}
extern "C" {
    #[doc = " Check for msg/Float64 message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float64__are_equal(
        lhs: *const std_msgs__msg__Float64,
        rhs: *const std_msgs__msg__Float64,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Float64 message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float64__copy(
        input: *const std_msgs__msg__Float64,
        output: *mut std_msgs__msg__Float64,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Float64 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__Float64__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float64__Sequence__init(
        array: *mut std_msgs__msg__Float64__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Float64 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Float64__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float64__Sequence__fini(array: *mut std_msgs__msg__Float64__Sequence);
}
extern "C" {
    #[doc = " Create array of msg/Float64 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__Float64__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float64__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__Float64__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Float64 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Float64__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float64__Sequence__destroy(array: *mut std_msgs__msg__Float64__Sequence);
}
extern "C" {
    #[doc = " Check for msg/Float64 message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float64__Sequence__are_equal(
        lhs: *const std_msgs__msg__Float64__Sequence,
        rhs: *const std_msgs__msg__Float64__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Float64 messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float64__Sequence__copy(
        input: *const std_msgs__msg__Float64__Sequence,
        output: *mut std_msgs__msg__Float64__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__Float64(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Float64MultiArray {
    pub layout: std_msgs__msg__MultiArrayLayout,
    pub data: rosidl_runtime_c__double__Sequence,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Float64MultiArray() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Float64MultiArray>(),
        56usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Float64MultiArray))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Float64MultiArray>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std_msgs__msg__Float64MultiArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Float64MultiArray>())).layout as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Float64MultiArray),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Float64MultiArray>())).data as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Float64MultiArray),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Float64MultiArray__Sequence {
    pub data: *mut std_msgs__msg__Float64MultiArray,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Float64MultiArray__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Float64MultiArray__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(std_msgs__msg__Float64MultiArray__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Float64MultiArray__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std_msgs__msg__Float64MultiArray__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Float64MultiArray__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Float64MultiArray__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Float64MultiArray__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Float64MultiArray__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Float64MultiArray__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Float64MultiArray__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Float64MultiArray message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__Float64MultiArray"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__Float64MultiArray__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float64MultiArray__init(
        msg: *mut std_msgs__msg__Float64MultiArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Float64MultiArray message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float64MultiArray__fini(msg: *mut std_msgs__msg__Float64MultiArray);
}
extern "C" {
    #[doc = " Create msg/Float64MultiArray message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__Float64MultiArray__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float64MultiArray__create() -> *mut std_msgs__msg__Float64MultiArray;
}
extern "C" {
    #[doc = " Destroy msg/Float64MultiArray message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Float64MultiArray__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float64MultiArray__destroy(msg: *mut std_msgs__msg__Float64MultiArray);
}
extern "C" {
    #[doc = " Check for msg/Float64MultiArray message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float64MultiArray__are_equal(
        lhs: *const std_msgs__msg__Float64MultiArray,
        rhs: *const std_msgs__msg__Float64MultiArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Float64MultiArray message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float64MultiArray__copy(
        input: *const std_msgs__msg__Float64MultiArray,
        output: *mut std_msgs__msg__Float64MultiArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Float64MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__Float64MultiArray__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float64MultiArray__Sequence__init(
        array: *mut std_msgs__msg__Float64MultiArray__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Float64MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Float64MultiArray__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float64MultiArray__Sequence__fini(
        array: *mut std_msgs__msg__Float64MultiArray__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/Float64MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__Float64MultiArray__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float64MultiArray__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__Float64MultiArray__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Float64MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Float64MultiArray__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float64MultiArray__Sequence__destroy(
        array: *mut std_msgs__msg__Float64MultiArray__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Float64MultiArray message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float64MultiArray__Sequence__are_equal(
        lhs: *const std_msgs__msg__Float64MultiArray__Sequence,
        rhs: *const std_msgs__msg__Float64MultiArray__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Float64MultiArray messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Float64MultiArray__Sequence__copy(
        input: *const std_msgs__msg__Float64MultiArray__Sequence,
        output: *mut std_msgs__msg__Float64MultiArray__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__Float64MultiArray(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct builtin_interfaces__msg__Time {
    pub sec: i32,
    pub nanosec: u32,
}
#[test]
fn bindgen_test_layout_builtin_interfaces__msg__Time() {
    assert_eq!(
        ::std::mem::size_of::<builtin_interfaces__msg__Time>(),
        8usize,
        concat!("Size of: ", stringify!(builtin_interfaces__msg__Time))
    );
    assert_eq!(
        ::std::mem::align_of::<builtin_interfaces__msg__Time>(),
        4usize,
        concat!("Alignment of ", stringify!(builtin_interfaces__msg__Time))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<builtin_interfaces__msg__Time>())).sec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(builtin_interfaces__msg__Time),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<builtin_interfaces__msg__Time>())).nanosec as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(builtin_interfaces__msg__Time),
            "::",
            stringify!(nanosec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct builtin_interfaces__msg__Time__Sequence {
    pub data: *mut builtin_interfaces__msg__Time,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_builtin_interfaces__msg__Time__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<builtin_interfaces__msg__Time__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(builtin_interfaces__msg__Time__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<builtin_interfaces__msg__Time__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(builtin_interfaces__msg__Time__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<builtin_interfaces__msg__Time__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(builtin_interfaces__msg__Time__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<builtin_interfaces__msg__Time__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(builtin_interfaces__msg__Time__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<builtin_interfaces__msg__Time__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(builtin_interfaces__msg__Time__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Header {
    pub stamp: builtin_interfaces__msg__Time,
    pub frame_id: rosidl_runtime_c__String,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Header() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Header>(),
        32usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Header))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Header>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__Header))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_msgs__msg__Header>())).stamp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Header),
            "::",
            stringify!(stamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_msgs__msg__Header>())).frame_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Header),
            "::",
            stringify!(frame_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Header__Sequence {
    pub data: *mut std_msgs__msg__Header,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Header__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Header__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Header__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Header__Sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__Header__Sequence))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Header__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Header__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Header__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Header__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Header__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Header__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Header message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__Header"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__Header__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Header__init(msg: *mut std_msgs__msg__Header) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Header message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Header__fini(msg: *mut std_msgs__msg__Header);
}
extern "C" {
    #[doc = " Create msg/Header message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__Header__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Header__create() -> *mut std_msgs__msg__Header;
}
extern "C" {
    #[doc = " Destroy msg/Header message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Header__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Header__destroy(msg: *mut std_msgs__msg__Header);
}
extern "C" {
    #[doc = " Check for msg/Header message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Header__are_equal(
        lhs: *const std_msgs__msg__Header,
        rhs: *const std_msgs__msg__Header,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Header message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Header__copy(
        input: *const std_msgs__msg__Header,
        output: *mut std_msgs__msg__Header,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Header messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__Header__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Header__Sequence__init(
        array: *mut std_msgs__msg__Header__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Header messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Header__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Header__Sequence__fini(array: *mut std_msgs__msg__Header__Sequence);
}
extern "C" {
    #[doc = " Create array of msg/Header messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__Header__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Header__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__Header__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Header messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Header__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Header__Sequence__destroy(array: *mut std_msgs__msg__Header__Sequence);
}
extern "C" {
    #[doc = " Check for msg/Header message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Header__Sequence__are_equal(
        lhs: *const std_msgs__msg__Header__Sequence,
        rhs: *const std_msgs__msg__Header__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Header messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Header__Sequence__copy(
        input: *const std_msgs__msg__Header__Sequence,
        output: *mut std_msgs__msg__Header__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__Header(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Int16 {
    pub data: i16,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Int16() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Int16>(),
        2usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Int16))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Int16>(),
        2usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__Int16))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_msgs__msg__Int16>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int16),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Int16__Sequence {
    pub data: *mut std_msgs__msg__Int16,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Int16__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Int16__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Int16__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Int16__Sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__Int16__Sequence))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int16__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int16__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int16__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int16__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int16__Sequence>())).capacity as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int16__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Int16 message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__Int16"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__Int16__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int16__init(msg: *mut std_msgs__msg__Int16) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Int16 message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int16__fini(msg: *mut std_msgs__msg__Int16);
}
extern "C" {
    #[doc = " Create msg/Int16 message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__Int16__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int16__create() -> *mut std_msgs__msg__Int16;
}
extern "C" {
    #[doc = " Destroy msg/Int16 message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Int16__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int16__destroy(msg: *mut std_msgs__msg__Int16);
}
extern "C" {
    #[doc = " Check for msg/Int16 message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int16__are_equal(
        lhs: *const std_msgs__msg__Int16,
        rhs: *const std_msgs__msg__Int16,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Int16 message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int16__copy(
        input: *const std_msgs__msg__Int16,
        output: *mut std_msgs__msg__Int16,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Int16 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__Int16__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int16__Sequence__init(
        array: *mut std_msgs__msg__Int16__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Int16 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Int16__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int16__Sequence__fini(array: *mut std_msgs__msg__Int16__Sequence);
}
extern "C" {
    #[doc = " Create array of msg/Int16 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__Int16__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int16__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__Int16__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Int16 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Int16__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int16__Sequence__destroy(array: *mut std_msgs__msg__Int16__Sequence);
}
extern "C" {
    #[doc = " Check for msg/Int16 message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int16__Sequence__are_equal(
        lhs: *const std_msgs__msg__Int16__Sequence,
        rhs: *const std_msgs__msg__Int16__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Int16 messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int16__Sequence__copy(
        input: *const std_msgs__msg__Int16__Sequence,
        output: *mut std_msgs__msg__Int16__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__Int16(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Int16MultiArray {
    pub layout: std_msgs__msg__MultiArrayLayout,
    pub data: rosidl_runtime_c__int16__Sequence,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Int16MultiArray() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Int16MultiArray>(),
        56usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Int16MultiArray))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Int16MultiArray>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__Int16MultiArray))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int16MultiArray>())).layout as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int16MultiArray),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int16MultiArray>())).data as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int16MultiArray),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Int16MultiArray__Sequence {
    pub data: *mut std_msgs__msg__Int16MultiArray,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Int16MultiArray__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Int16MultiArray__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(std_msgs__msg__Int16MultiArray__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Int16MultiArray__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std_msgs__msg__Int16MultiArray__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int16MultiArray__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int16MultiArray__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int16MultiArray__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int16MultiArray__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int16MultiArray__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int16MultiArray__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Int16MultiArray message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__Int16MultiArray"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__Int16MultiArray__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int16MultiArray__init(msg: *mut std_msgs__msg__Int16MultiArray) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Int16MultiArray message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int16MultiArray__fini(msg: *mut std_msgs__msg__Int16MultiArray);
}
extern "C" {
    #[doc = " Create msg/Int16MultiArray message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__Int16MultiArray__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int16MultiArray__create() -> *mut std_msgs__msg__Int16MultiArray;
}
extern "C" {
    #[doc = " Destroy msg/Int16MultiArray message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Int16MultiArray__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int16MultiArray__destroy(msg: *mut std_msgs__msg__Int16MultiArray);
}
extern "C" {
    #[doc = " Check for msg/Int16MultiArray message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int16MultiArray__are_equal(
        lhs: *const std_msgs__msg__Int16MultiArray,
        rhs: *const std_msgs__msg__Int16MultiArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Int16MultiArray message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int16MultiArray__copy(
        input: *const std_msgs__msg__Int16MultiArray,
        output: *mut std_msgs__msg__Int16MultiArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Int16MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__Int16MultiArray__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int16MultiArray__Sequence__init(
        array: *mut std_msgs__msg__Int16MultiArray__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Int16MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Int16MultiArray__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int16MultiArray__Sequence__fini(
        array: *mut std_msgs__msg__Int16MultiArray__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/Int16MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__Int16MultiArray__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int16MultiArray__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__Int16MultiArray__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Int16MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Int16MultiArray__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int16MultiArray__Sequence__destroy(
        array: *mut std_msgs__msg__Int16MultiArray__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Int16MultiArray message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int16MultiArray__Sequence__are_equal(
        lhs: *const std_msgs__msg__Int16MultiArray__Sequence,
        rhs: *const std_msgs__msg__Int16MultiArray__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Int16MultiArray messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int16MultiArray__Sequence__copy(
        input: *const std_msgs__msg__Int16MultiArray__Sequence,
        output: *mut std_msgs__msg__Int16MultiArray__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__Int16MultiArray(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Int32 {
    pub data: i32,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Int32() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Int32>(),
        4usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Int32))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Int32>(),
        4usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__Int32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_msgs__msg__Int32>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int32),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Int32__Sequence {
    pub data: *mut std_msgs__msg__Int32,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Int32__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Int32__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Int32__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Int32__Sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__Int32__Sequence))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int32__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int32__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int32__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int32__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int32__Sequence>())).capacity as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int32__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Int32 message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__Int32"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__Int32__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int32__init(msg: *mut std_msgs__msg__Int32) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Int32 message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int32__fini(msg: *mut std_msgs__msg__Int32);
}
extern "C" {
    #[doc = " Create msg/Int32 message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__Int32__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int32__create() -> *mut std_msgs__msg__Int32;
}
extern "C" {
    #[doc = " Destroy msg/Int32 message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Int32__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int32__destroy(msg: *mut std_msgs__msg__Int32);
}
extern "C" {
    #[doc = " Check for msg/Int32 message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int32__are_equal(
        lhs: *const std_msgs__msg__Int32,
        rhs: *const std_msgs__msg__Int32,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Int32 message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int32__copy(
        input: *const std_msgs__msg__Int32,
        output: *mut std_msgs__msg__Int32,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Int32 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__Int32__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int32__Sequence__init(
        array: *mut std_msgs__msg__Int32__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Int32 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Int32__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int32__Sequence__fini(array: *mut std_msgs__msg__Int32__Sequence);
}
extern "C" {
    #[doc = " Create array of msg/Int32 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__Int32__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int32__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__Int32__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Int32 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Int32__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int32__Sequence__destroy(array: *mut std_msgs__msg__Int32__Sequence);
}
extern "C" {
    #[doc = " Check for msg/Int32 message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int32__Sequence__are_equal(
        lhs: *const std_msgs__msg__Int32__Sequence,
        rhs: *const std_msgs__msg__Int32__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Int32 messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int32__Sequence__copy(
        input: *const std_msgs__msg__Int32__Sequence,
        output: *mut std_msgs__msg__Int32__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__Int32(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Int32MultiArray {
    pub layout: std_msgs__msg__MultiArrayLayout,
    pub data: rosidl_runtime_c__int32__Sequence,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Int32MultiArray() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Int32MultiArray>(),
        56usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Int32MultiArray))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Int32MultiArray>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__Int32MultiArray))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int32MultiArray>())).layout as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int32MultiArray),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int32MultiArray>())).data as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int32MultiArray),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Int32MultiArray__Sequence {
    pub data: *mut std_msgs__msg__Int32MultiArray,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Int32MultiArray__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Int32MultiArray__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(std_msgs__msg__Int32MultiArray__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Int32MultiArray__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std_msgs__msg__Int32MultiArray__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int32MultiArray__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int32MultiArray__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int32MultiArray__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int32MultiArray__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int32MultiArray__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int32MultiArray__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Int32MultiArray message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__Int32MultiArray"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__Int32MultiArray__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int32MultiArray__init(msg: *mut std_msgs__msg__Int32MultiArray) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Int32MultiArray message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int32MultiArray__fini(msg: *mut std_msgs__msg__Int32MultiArray);
}
extern "C" {
    #[doc = " Create msg/Int32MultiArray message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__Int32MultiArray__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int32MultiArray__create() -> *mut std_msgs__msg__Int32MultiArray;
}
extern "C" {
    #[doc = " Destroy msg/Int32MultiArray message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Int32MultiArray__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int32MultiArray__destroy(msg: *mut std_msgs__msg__Int32MultiArray);
}
extern "C" {
    #[doc = " Check for msg/Int32MultiArray message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int32MultiArray__are_equal(
        lhs: *const std_msgs__msg__Int32MultiArray,
        rhs: *const std_msgs__msg__Int32MultiArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Int32MultiArray message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int32MultiArray__copy(
        input: *const std_msgs__msg__Int32MultiArray,
        output: *mut std_msgs__msg__Int32MultiArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Int32MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__Int32MultiArray__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int32MultiArray__Sequence__init(
        array: *mut std_msgs__msg__Int32MultiArray__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Int32MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Int32MultiArray__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int32MultiArray__Sequence__fini(
        array: *mut std_msgs__msg__Int32MultiArray__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/Int32MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__Int32MultiArray__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int32MultiArray__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__Int32MultiArray__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Int32MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Int32MultiArray__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int32MultiArray__Sequence__destroy(
        array: *mut std_msgs__msg__Int32MultiArray__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Int32MultiArray message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int32MultiArray__Sequence__are_equal(
        lhs: *const std_msgs__msg__Int32MultiArray__Sequence,
        rhs: *const std_msgs__msg__Int32MultiArray__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Int32MultiArray messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int32MultiArray__Sequence__copy(
        input: *const std_msgs__msg__Int32MultiArray__Sequence,
        output: *mut std_msgs__msg__Int32MultiArray__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__Int32MultiArray(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Int64 {
    pub data: i64,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Int64() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Int64>(),
        8usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Int64))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Int64>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__Int64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_msgs__msg__Int64>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int64),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Int64__Sequence {
    pub data: *mut std_msgs__msg__Int64,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Int64__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Int64__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Int64__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Int64__Sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__Int64__Sequence))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int64__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int64__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int64__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int64__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int64__Sequence>())).capacity as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int64__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Int64 message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__Int64"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__Int64__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int64__init(msg: *mut std_msgs__msg__Int64) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Int64 message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int64__fini(msg: *mut std_msgs__msg__Int64);
}
extern "C" {
    #[doc = " Create msg/Int64 message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__Int64__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int64__create() -> *mut std_msgs__msg__Int64;
}
extern "C" {
    #[doc = " Destroy msg/Int64 message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Int64__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int64__destroy(msg: *mut std_msgs__msg__Int64);
}
extern "C" {
    #[doc = " Check for msg/Int64 message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int64__are_equal(
        lhs: *const std_msgs__msg__Int64,
        rhs: *const std_msgs__msg__Int64,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Int64 message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int64__copy(
        input: *const std_msgs__msg__Int64,
        output: *mut std_msgs__msg__Int64,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Int64 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__Int64__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int64__Sequence__init(
        array: *mut std_msgs__msg__Int64__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Int64 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Int64__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int64__Sequence__fini(array: *mut std_msgs__msg__Int64__Sequence);
}
extern "C" {
    #[doc = " Create array of msg/Int64 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__Int64__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int64__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__Int64__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Int64 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Int64__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int64__Sequence__destroy(array: *mut std_msgs__msg__Int64__Sequence);
}
extern "C" {
    #[doc = " Check for msg/Int64 message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int64__Sequence__are_equal(
        lhs: *const std_msgs__msg__Int64__Sequence,
        rhs: *const std_msgs__msg__Int64__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Int64 messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int64__Sequence__copy(
        input: *const std_msgs__msg__Int64__Sequence,
        output: *mut std_msgs__msg__Int64__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__Int64(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Int64MultiArray {
    pub layout: std_msgs__msg__MultiArrayLayout,
    pub data: rosidl_runtime_c__int64__Sequence,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Int64MultiArray() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Int64MultiArray>(),
        56usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Int64MultiArray))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Int64MultiArray>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__Int64MultiArray))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int64MultiArray>())).layout as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int64MultiArray),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int64MultiArray>())).data as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int64MultiArray),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Int64MultiArray__Sequence {
    pub data: *mut std_msgs__msg__Int64MultiArray,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Int64MultiArray__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Int64MultiArray__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(std_msgs__msg__Int64MultiArray__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Int64MultiArray__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std_msgs__msg__Int64MultiArray__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int64MultiArray__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int64MultiArray__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int64MultiArray__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int64MultiArray__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int64MultiArray__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int64MultiArray__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Int64MultiArray message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__Int64MultiArray"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__Int64MultiArray__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int64MultiArray__init(msg: *mut std_msgs__msg__Int64MultiArray) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Int64MultiArray message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int64MultiArray__fini(msg: *mut std_msgs__msg__Int64MultiArray);
}
extern "C" {
    #[doc = " Create msg/Int64MultiArray message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__Int64MultiArray__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int64MultiArray__create() -> *mut std_msgs__msg__Int64MultiArray;
}
extern "C" {
    #[doc = " Destroy msg/Int64MultiArray message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Int64MultiArray__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int64MultiArray__destroy(msg: *mut std_msgs__msg__Int64MultiArray);
}
extern "C" {
    #[doc = " Check for msg/Int64MultiArray message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int64MultiArray__are_equal(
        lhs: *const std_msgs__msg__Int64MultiArray,
        rhs: *const std_msgs__msg__Int64MultiArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Int64MultiArray message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int64MultiArray__copy(
        input: *const std_msgs__msg__Int64MultiArray,
        output: *mut std_msgs__msg__Int64MultiArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Int64MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__Int64MultiArray__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int64MultiArray__Sequence__init(
        array: *mut std_msgs__msg__Int64MultiArray__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Int64MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Int64MultiArray__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int64MultiArray__Sequence__fini(
        array: *mut std_msgs__msg__Int64MultiArray__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/Int64MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__Int64MultiArray__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int64MultiArray__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__Int64MultiArray__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Int64MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Int64MultiArray__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int64MultiArray__Sequence__destroy(
        array: *mut std_msgs__msg__Int64MultiArray__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Int64MultiArray message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int64MultiArray__Sequence__are_equal(
        lhs: *const std_msgs__msg__Int64MultiArray__Sequence,
        rhs: *const std_msgs__msg__Int64MultiArray__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Int64MultiArray messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int64MultiArray__Sequence__copy(
        input: *const std_msgs__msg__Int64MultiArray__Sequence,
        output: *mut std_msgs__msg__Int64MultiArray__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__Int64MultiArray(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Int8 {
    pub data: i8,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Int8() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Int8>(),
        1usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Int8))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Int8>(),
        1usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__Int8))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_msgs__msg__Int8>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int8),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Int8__Sequence {
    pub data: *mut std_msgs__msg__Int8,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Int8__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Int8__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Int8__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Int8__Sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__Int8__Sequence))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int8__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int8__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int8__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int8__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int8__Sequence>())).capacity as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int8__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Int8 message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__Int8"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__Int8__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int8__init(msg: *mut std_msgs__msg__Int8) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Int8 message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int8__fini(msg: *mut std_msgs__msg__Int8);
}
extern "C" {
    #[doc = " Create msg/Int8 message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__Int8__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int8__create() -> *mut std_msgs__msg__Int8;
}
extern "C" {
    #[doc = " Destroy msg/Int8 message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Int8__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int8__destroy(msg: *mut std_msgs__msg__Int8);
}
extern "C" {
    #[doc = " Check for msg/Int8 message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int8__are_equal(
        lhs: *const std_msgs__msg__Int8,
        rhs: *const std_msgs__msg__Int8,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Int8 message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int8__copy(
        input: *const std_msgs__msg__Int8,
        output: *mut std_msgs__msg__Int8,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Int8 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__Int8__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int8__Sequence__init(
        array: *mut std_msgs__msg__Int8__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Int8 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Int8__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int8__Sequence__fini(array: *mut std_msgs__msg__Int8__Sequence);
}
extern "C" {
    #[doc = " Create array of msg/Int8 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__Int8__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int8__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__Int8__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Int8 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Int8__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int8__Sequence__destroy(array: *mut std_msgs__msg__Int8__Sequence);
}
extern "C" {
    #[doc = " Check for msg/Int8 message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int8__Sequence__are_equal(
        lhs: *const std_msgs__msg__Int8__Sequence,
        rhs: *const std_msgs__msg__Int8__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Int8 messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int8__Sequence__copy(
        input: *const std_msgs__msg__Int8__Sequence,
        output: *mut std_msgs__msg__Int8__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__Int8(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Int8MultiArray {
    pub layout: std_msgs__msg__MultiArrayLayout,
    pub data: rosidl_runtime_c__int8__Sequence,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Int8MultiArray() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Int8MultiArray>(),
        56usize,
        concat!("Size of: ", stringify!(std_msgs__msg__Int8MultiArray))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Int8MultiArray>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__Int8MultiArray))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int8MultiArray>())).layout as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int8MultiArray),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int8MultiArray>())).data as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int8MultiArray),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__Int8MultiArray__Sequence {
    pub data: *mut std_msgs__msg__Int8MultiArray,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__Int8MultiArray__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__Int8MultiArray__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(std_msgs__msg__Int8MultiArray__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__Int8MultiArray__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std_msgs__msg__Int8MultiArray__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int8MultiArray__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int8MultiArray__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int8MultiArray__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int8MultiArray__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__Int8MultiArray__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__Int8MultiArray__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Int8MultiArray message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__Int8MultiArray"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__Int8MultiArray__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int8MultiArray__init(msg: *mut std_msgs__msg__Int8MultiArray) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Int8MultiArray message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int8MultiArray__fini(msg: *mut std_msgs__msg__Int8MultiArray);
}
extern "C" {
    #[doc = " Create msg/Int8MultiArray message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__Int8MultiArray__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int8MultiArray__create() -> *mut std_msgs__msg__Int8MultiArray;
}
extern "C" {
    #[doc = " Destroy msg/Int8MultiArray message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Int8MultiArray__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int8MultiArray__destroy(msg: *mut std_msgs__msg__Int8MultiArray);
}
extern "C" {
    #[doc = " Check for msg/Int8MultiArray message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int8MultiArray__are_equal(
        lhs: *const std_msgs__msg__Int8MultiArray,
        rhs: *const std_msgs__msg__Int8MultiArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Int8MultiArray message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int8MultiArray__copy(
        input: *const std_msgs__msg__Int8MultiArray,
        output: *mut std_msgs__msg__Int8MultiArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Int8MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__Int8MultiArray__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int8MultiArray__Sequence__init(
        array: *mut std_msgs__msg__Int8MultiArray__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Int8MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Int8MultiArray__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int8MultiArray__Sequence__fini(
        array: *mut std_msgs__msg__Int8MultiArray__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/Int8MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__Int8MultiArray__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int8MultiArray__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__Int8MultiArray__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Int8MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__Int8MultiArray__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int8MultiArray__Sequence__destroy(
        array: *mut std_msgs__msg__Int8MultiArray__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Int8MultiArray message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int8MultiArray__Sequence__are_equal(
        lhs: *const std_msgs__msg__Int8MultiArray__Sequence,
        rhs: *const std_msgs__msg__Int8MultiArray__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Int8MultiArray messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__Int8MultiArray__Sequence__copy(
        input: *const std_msgs__msg__Int8MultiArray__Sequence,
        output: *mut std_msgs__msg__Int8MultiArray__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__Int8MultiArray(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__String {
    pub data: rosidl_runtime_c__String,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__String() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__String>(),
        24usize,
        concat!("Size of: ", stringify!(std_msgs__msg__String))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__String>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__String))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_msgs__msg__String>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__String),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__String__Sequence {
    pub data: *mut std_msgs__msg__String,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__String__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__String__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(std_msgs__msg__String__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__String__Sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__String__Sequence))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__String__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__String__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__String__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__String__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__String__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__String__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/String message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__String"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__String__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__String__init(msg: *mut std_msgs__msg__String) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/String message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__String__fini(msg: *mut std_msgs__msg__String);
}
extern "C" {
    #[doc = " Create msg/String message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__String__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__String__create() -> *mut std_msgs__msg__String;
}
extern "C" {
    #[doc = " Destroy msg/String message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__String__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__String__destroy(msg: *mut std_msgs__msg__String);
}
extern "C" {
    #[doc = " Check for msg/String message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__String__are_equal(
        lhs: *const std_msgs__msg__String,
        rhs: *const std_msgs__msg__String,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/String message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__String__copy(
        input: *const std_msgs__msg__String,
        output: *mut std_msgs__msg__String,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/String messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__String__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__String__Sequence__init(
        array: *mut std_msgs__msg__String__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/String messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__String__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__String__Sequence__fini(array: *mut std_msgs__msg__String__Sequence);
}
extern "C" {
    #[doc = " Create array of msg/String messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__String__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__String__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__String__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/String messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__String__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__String__Sequence__destroy(array: *mut std_msgs__msg__String__Sequence);
}
extern "C" {
    #[doc = " Check for msg/String message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__String__Sequence__are_equal(
        lhs: *const std_msgs__msg__String__Sequence,
        rhs: *const std_msgs__msg__String__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/String messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__String__Sequence__copy(
        input: *const std_msgs__msg__String__Sequence,
        output: *mut std_msgs__msg__String__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__String(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__UInt16 {
    pub data: u16,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__UInt16() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__UInt16>(),
        2usize,
        concat!("Size of: ", stringify!(std_msgs__msg__UInt16))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__UInt16>(),
        2usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__UInt16))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_msgs__msg__UInt16>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt16),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__UInt16__Sequence {
    pub data: *mut std_msgs__msg__UInt16,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__UInt16__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__UInt16__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(std_msgs__msg__UInt16__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__UInt16__Sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__UInt16__Sequence))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt16__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt16__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt16__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt16__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt16__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt16__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/UInt16 message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__UInt16"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__UInt16__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt16__init(msg: *mut std_msgs__msg__UInt16) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/UInt16 message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt16__fini(msg: *mut std_msgs__msg__UInt16);
}
extern "C" {
    #[doc = " Create msg/UInt16 message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__UInt16__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt16__create() -> *mut std_msgs__msg__UInt16;
}
extern "C" {
    #[doc = " Destroy msg/UInt16 message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__UInt16__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt16__destroy(msg: *mut std_msgs__msg__UInt16);
}
extern "C" {
    #[doc = " Check for msg/UInt16 message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt16__are_equal(
        lhs: *const std_msgs__msg__UInt16,
        rhs: *const std_msgs__msg__UInt16,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/UInt16 message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt16__copy(
        input: *const std_msgs__msg__UInt16,
        output: *mut std_msgs__msg__UInt16,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/UInt16 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__UInt16__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt16__Sequence__init(
        array: *mut std_msgs__msg__UInt16__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/UInt16 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__UInt16__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt16__Sequence__fini(array: *mut std_msgs__msg__UInt16__Sequence);
}
extern "C" {
    #[doc = " Create array of msg/UInt16 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__UInt16__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt16__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__UInt16__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/UInt16 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__UInt16__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt16__Sequence__destroy(array: *mut std_msgs__msg__UInt16__Sequence);
}
extern "C" {
    #[doc = " Check for msg/UInt16 message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt16__Sequence__are_equal(
        lhs: *const std_msgs__msg__UInt16__Sequence,
        rhs: *const std_msgs__msg__UInt16__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/UInt16 messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt16__Sequence__copy(
        input: *const std_msgs__msg__UInt16__Sequence,
        output: *mut std_msgs__msg__UInt16__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__UInt16(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__UInt16MultiArray {
    pub layout: std_msgs__msg__MultiArrayLayout,
    pub data: rosidl_runtime_c__uint16__Sequence,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__UInt16MultiArray() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__UInt16MultiArray>(),
        56usize,
        concat!("Size of: ", stringify!(std_msgs__msg__UInt16MultiArray))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__UInt16MultiArray>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__UInt16MultiArray))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt16MultiArray>())).layout as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt16MultiArray),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt16MultiArray>())).data as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt16MultiArray),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__UInt16MultiArray__Sequence {
    pub data: *mut std_msgs__msg__UInt16MultiArray,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__UInt16MultiArray__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__UInt16MultiArray__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(std_msgs__msg__UInt16MultiArray__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__UInt16MultiArray__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std_msgs__msg__UInt16MultiArray__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt16MultiArray__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt16MultiArray__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt16MultiArray__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt16MultiArray__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt16MultiArray__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt16MultiArray__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/UInt16MultiArray message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__UInt16MultiArray"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__UInt16MultiArray__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt16MultiArray__init(msg: *mut std_msgs__msg__UInt16MultiArray)
        -> bool;
}
extern "C" {
    #[doc = " Finalize msg/UInt16MultiArray message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt16MultiArray__fini(msg: *mut std_msgs__msg__UInt16MultiArray);
}
extern "C" {
    #[doc = " Create msg/UInt16MultiArray message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__UInt16MultiArray__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt16MultiArray__create() -> *mut std_msgs__msg__UInt16MultiArray;
}
extern "C" {
    #[doc = " Destroy msg/UInt16MultiArray message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__UInt16MultiArray__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt16MultiArray__destroy(msg: *mut std_msgs__msg__UInt16MultiArray);
}
extern "C" {
    #[doc = " Check for msg/UInt16MultiArray message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt16MultiArray__are_equal(
        lhs: *const std_msgs__msg__UInt16MultiArray,
        rhs: *const std_msgs__msg__UInt16MultiArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/UInt16MultiArray message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt16MultiArray__copy(
        input: *const std_msgs__msg__UInt16MultiArray,
        output: *mut std_msgs__msg__UInt16MultiArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/UInt16MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__UInt16MultiArray__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt16MultiArray__Sequence__init(
        array: *mut std_msgs__msg__UInt16MultiArray__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/UInt16MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__UInt16MultiArray__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt16MultiArray__Sequence__fini(
        array: *mut std_msgs__msg__UInt16MultiArray__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/UInt16MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__UInt16MultiArray__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt16MultiArray__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__UInt16MultiArray__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/UInt16MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__UInt16MultiArray__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt16MultiArray__Sequence__destroy(
        array: *mut std_msgs__msg__UInt16MultiArray__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/UInt16MultiArray message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt16MultiArray__Sequence__are_equal(
        lhs: *const std_msgs__msg__UInt16MultiArray__Sequence,
        rhs: *const std_msgs__msg__UInt16MultiArray__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/UInt16MultiArray messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt16MultiArray__Sequence__copy(
        input: *const std_msgs__msg__UInt16MultiArray__Sequence,
        output: *mut std_msgs__msg__UInt16MultiArray__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__UInt16MultiArray(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__UInt32 {
    pub data: u32,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__UInt32() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__UInt32>(),
        4usize,
        concat!("Size of: ", stringify!(std_msgs__msg__UInt32))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__UInt32>(),
        4usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__UInt32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_msgs__msg__UInt32>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt32),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__UInt32__Sequence {
    pub data: *mut std_msgs__msg__UInt32,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__UInt32__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__UInt32__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(std_msgs__msg__UInt32__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__UInt32__Sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__UInt32__Sequence))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt32__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt32__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt32__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt32__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt32__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt32__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/UInt32 message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__UInt32"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__UInt32__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt32__init(msg: *mut std_msgs__msg__UInt32) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/UInt32 message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt32__fini(msg: *mut std_msgs__msg__UInt32);
}
extern "C" {
    #[doc = " Create msg/UInt32 message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__UInt32__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt32__create() -> *mut std_msgs__msg__UInt32;
}
extern "C" {
    #[doc = " Destroy msg/UInt32 message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__UInt32__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt32__destroy(msg: *mut std_msgs__msg__UInt32);
}
extern "C" {
    #[doc = " Check for msg/UInt32 message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt32__are_equal(
        lhs: *const std_msgs__msg__UInt32,
        rhs: *const std_msgs__msg__UInt32,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/UInt32 message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt32__copy(
        input: *const std_msgs__msg__UInt32,
        output: *mut std_msgs__msg__UInt32,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/UInt32 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__UInt32__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt32__Sequence__init(
        array: *mut std_msgs__msg__UInt32__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/UInt32 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__UInt32__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt32__Sequence__fini(array: *mut std_msgs__msg__UInt32__Sequence);
}
extern "C" {
    #[doc = " Create array of msg/UInt32 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__UInt32__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt32__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__UInt32__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/UInt32 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__UInt32__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt32__Sequence__destroy(array: *mut std_msgs__msg__UInt32__Sequence);
}
extern "C" {
    #[doc = " Check for msg/UInt32 message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt32__Sequence__are_equal(
        lhs: *const std_msgs__msg__UInt32__Sequence,
        rhs: *const std_msgs__msg__UInt32__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/UInt32 messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt32__Sequence__copy(
        input: *const std_msgs__msg__UInt32__Sequence,
        output: *mut std_msgs__msg__UInt32__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__UInt32(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__UInt32MultiArray {
    pub layout: std_msgs__msg__MultiArrayLayout,
    pub data: rosidl_runtime_c__uint32__Sequence,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__UInt32MultiArray() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__UInt32MultiArray>(),
        56usize,
        concat!("Size of: ", stringify!(std_msgs__msg__UInt32MultiArray))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__UInt32MultiArray>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__UInt32MultiArray))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt32MultiArray>())).layout as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt32MultiArray),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt32MultiArray>())).data as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt32MultiArray),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__UInt32MultiArray__Sequence {
    pub data: *mut std_msgs__msg__UInt32MultiArray,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__UInt32MultiArray__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__UInt32MultiArray__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(std_msgs__msg__UInt32MultiArray__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__UInt32MultiArray__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std_msgs__msg__UInt32MultiArray__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt32MultiArray__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt32MultiArray__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt32MultiArray__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt32MultiArray__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt32MultiArray__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt32MultiArray__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/UInt32MultiArray message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__UInt32MultiArray"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__UInt32MultiArray__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt32MultiArray__init(msg: *mut std_msgs__msg__UInt32MultiArray)
        -> bool;
}
extern "C" {
    #[doc = " Finalize msg/UInt32MultiArray message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt32MultiArray__fini(msg: *mut std_msgs__msg__UInt32MultiArray);
}
extern "C" {
    #[doc = " Create msg/UInt32MultiArray message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__UInt32MultiArray__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt32MultiArray__create() -> *mut std_msgs__msg__UInt32MultiArray;
}
extern "C" {
    #[doc = " Destroy msg/UInt32MultiArray message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__UInt32MultiArray__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt32MultiArray__destroy(msg: *mut std_msgs__msg__UInt32MultiArray);
}
extern "C" {
    #[doc = " Check for msg/UInt32MultiArray message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt32MultiArray__are_equal(
        lhs: *const std_msgs__msg__UInt32MultiArray,
        rhs: *const std_msgs__msg__UInt32MultiArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/UInt32MultiArray message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt32MultiArray__copy(
        input: *const std_msgs__msg__UInt32MultiArray,
        output: *mut std_msgs__msg__UInt32MultiArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/UInt32MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__UInt32MultiArray__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt32MultiArray__Sequence__init(
        array: *mut std_msgs__msg__UInt32MultiArray__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/UInt32MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__UInt32MultiArray__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt32MultiArray__Sequence__fini(
        array: *mut std_msgs__msg__UInt32MultiArray__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/UInt32MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__UInt32MultiArray__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt32MultiArray__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__UInt32MultiArray__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/UInt32MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__UInt32MultiArray__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt32MultiArray__Sequence__destroy(
        array: *mut std_msgs__msg__UInt32MultiArray__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/UInt32MultiArray message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt32MultiArray__Sequence__are_equal(
        lhs: *const std_msgs__msg__UInt32MultiArray__Sequence,
        rhs: *const std_msgs__msg__UInt32MultiArray__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/UInt32MultiArray messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt32MultiArray__Sequence__copy(
        input: *const std_msgs__msg__UInt32MultiArray__Sequence,
        output: *mut std_msgs__msg__UInt32MultiArray__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__UInt32MultiArray(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__UInt64 {
    pub data: u64,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__UInt64() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__UInt64>(),
        8usize,
        concat!("Size of: ", stringify!(std_msgs__msg__UInt64))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__UInt64>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__UInt64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_msgs__msg__UInt64>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt64),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__UInt64__Sequence {
    pub data: *mut std_msgs__msg__UInt64,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__UInt64__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__UInt64__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(std_msgs__msg__UInt64__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__UInt64__Sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__UInt64__Sequence))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt64__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt64__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt64__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt64__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt64__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt64__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/UInt64 message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__UInt64"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__UInt64__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt64__init(msg: *mut std_msgs__msg__UInt64) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/UInt64 message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt64__fini(msg: *mut std_msgs__msg__UInt64);
}
extern "C" {
    #[doc = " Create msg/UInt64 message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__UInt64__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt64__create() -> *mut std_msgs__msg__UInt64;
}
extern "C" {
    #[doc = " Destroy msg/UInt64 message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__UInt64__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt64__destroy(msg: *mut std_msgs__msg__UInt64);
}
extern "C" {
    #[doc = " Check for msg/UInt64 message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt64__are_equal(
        lhs: *const std_msgs__msg__UInt64,
        rhs: *const std_msgs__msg__UInt64,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/UInt64 message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt64__copy(
        input: *const std_msgs__msg__UInt64,
        output: *mut std_msgs__msg__UInt64,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/UInt64 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__UInt64__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt64__Sequence__init(
        array: *mut std_msgs__msg__UInt64__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/UInt64 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__UInt64__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt64__Sequence__fini(array: *mut std_msgs__msg__UInt64__Sequence);
}
extern "C" {
    #[doc = " Create array of msg/UInt64 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__UInt64__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt64__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__UInt64__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/UInt64 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__UInt64__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt64__Sequence__destroy(array: *mut std_msgs__msg__UInt64__Sequence);
}
extern "C" {
    #[doc = " Check for msg/UInt64 message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt64__Sequence__are_equal(
        lhs: *const std_msgs__msg__UInt64__Sequence,
        rhs: *const std_msgs__msg__UInt64__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/UInt64 messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt64__Sequence__copy(
        input: *const std_msgs__msg__UInt64__Sequence,
        output: *mut std_msgs__msg__UInt64__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__UInt64(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__UInt64MultiArray {
    pub layout: std_msgs__msg__MultiArrayLayout,
    pub data: rosidl_runtime_c__uint64__Sequence,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__UInt64MultiArray() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__UInt64MultiArray>(),
        56usize,
        concat!("Size of: ", stringify!(std_msgs__msg__UInt64MultiArray))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__UInt64MultiArray>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__UInt64MultiArray))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt64MultiArray>())).layout as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt64MultiArray),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt64MultiArray>())).data as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt64MultiArray),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__UInt64MultiArray__Sequence {
    pub data: *mut std_msgs__msg__UInt64MultiArray,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__UInt64MultiArray__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__UInt64MultiArray__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(std_msgs__msg__UInt64MultiArray__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__UInt64MultiArray__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std_msgs__msg__UInt64MultiArray__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt64MultiArray__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt64MultiArray__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt64MultiArray__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt64MultiArray__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt64MultiArray__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt64MultiArray__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/UInt64MultiArray message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__UInt64MultiArray"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__UInt64MultiArray__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt64MultiArray__init(msg: *mut std_msgs__msg__UInt64MultiArray)
        -> bool;
}
extern "C" {
    #[doc = " Finalize msg/UInt64MultiArray message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt64MultiArray__fini(msg: *mut std_msgs__msg__UInt64MultiArray);
}
extern "C" {
    #[doc = " Create msg/UInt64MultiArray message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__UInt64MultiArray__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt64MultiArray__create() -> *mut std_msgs__msg__UInt64MultiArray;
}
extern "C" {
    #[doc = " Destroy msg/UInt64MultiArray message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__UInt64MultiArray__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt64MultiArray__destroy(msg: *mut std_msgs__msg__UInt64MultiArray);
}
extern "C" {
    #[doc = " Check for msg/UInt64MultiArray message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt64MultiArray__are_equal(
        lhs: *const std_msgs__msg__UInt64MultiArray,
        rhs: *const std_msgs__msg__UInt64MultiArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/UInt64MultiArray message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt64MultiArray__copy(
        input: *const std_msgs__msg__UInt64MultiArray,
        output: *mut std_msgs__msg__UInt64MultiArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/UInt64MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__UInt64MultiArray__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt64MultiArray__Sequence__init(
        array: *mut std_msgs__msg__UInt64MultiArray__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/UInt64MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__UInt64MultiArray__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt64MultiArray__Sequence__fini(
        array: *mut std_msgs__msg__UInt64MultiArray__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/UInt64MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__UInt64MultiArray__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt64MultiArray__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__UInt64MultiArray__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/UInt64MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__UInt64MultiArray__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt64MultiArray__Sequence__destroy(
        array: *mut std_msgs__msg__UInt64MultiArray__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/UInt64MultiArray message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt64MultiArray__Sequence__are_equal(
        lhs: *const std_msgs__msg__UInt64MultiArray__Sequence,
        rhs: *const std_msgs__msg__UInt64MultiArray__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/UInt64MultiArray messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt64MultiArray__Sequence__copy(
        input: *const std_msgs__msg__UInt64MultiArray__Sequence,
        output: *mut std_msgs__msg__UInt64MultiArray__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__UInt64MultiArray(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__UInt8 {
    pub data: u8,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__UInt8() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__UInt8>(),
        1usize,
        concat!("Size of: ", stringify!(std_msgs__msg__UInt8))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__UInt8>(),
        1usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__UInt8))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_msgs__msg__UInt8>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt8),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__UInt8__Sequence {
    pub data: *mut std_msgs__msg__UInt8,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__UInt8__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__UInt8__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(std_msgs__msg__UInt8__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__UInt8__Sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__UInt8__Sequence))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt8__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt8__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt8__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt8__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt8__Sequence>())).capacity as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt8__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/UInt8 message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__UInt8"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__UInt8__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt8__init(msg: *mut std_msgs__msg__UInt8) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/UInt8 message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt8__fini(msg: *mut std_msgs__msg__UInt8);
}
extern "C" {
    #[doc = " Create msg/UInt8 message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__UInt8__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt8__create() -> *mut std_msgs__msg__UInt8;
}
extern "C" {
    #[doc = " Destroy msg/UInt8 message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__UInt8__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt8__destroy(msg: *mut std_msgs__msg__UInt8);
}
extern "C" {
    #[doc = " Check for msg/UInt8 message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt8__are_equal(
        lhs: *const std_msgs__msg__UInt8,
        rhs: *const std_msgs__msg__UInt8,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/UInt8 message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt8__copy(
        input: *const std_msgs__msg__UInt8,
        output: *mut std_msgs__msg__UInt8,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/UInt8 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__UInt8__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt8__Sequence__init(
        array: *mut std_msgs__msg__UInt8__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/UInt8 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__UInt8__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt8__Sequence__fini(array: *mut std_msgs__msg__UInt8__Sequence);
}
extern "C" {
    #[doc = " Create array of msg/UInt8 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__UInt8__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt8__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__UInt8__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/UInt8 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__UInt8__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt8__Sequence__destroy(array: *mut std_msgs__msg__UInt8__Sequence);
}
extern "C" {
    #[doc = " Check for msg/UInt8 message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt8__Sequence__are_equal(
        lhs: *const std_msgs__msg__UInt8__Sequence,
        rhs: *const std_msgs__msg__UInt8__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/UInt8 messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt8__Sequence__copy(
        input: *const std_msgs__msg__UInt8__Sequence,
        output: *mut std_msgs__msg__UInt8__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__UInt8(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__UInt8MultiArray {
    pub layout: std_msgs__msg__MultiArrayLayout,
    pub data: rosidl_runtime_c__uint8__Sequence,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__UInt8MultiArray() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__UInt8MultiArray>(),
        56usize,
        concat!("Size of: ", stringify!(std_msgs__msg__UInt8MultiArray))
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__UInt8MultiArray>(),
        8usize,
        concat!("Alignment of ", stringify!(std_msgs__msg__UInt8MultiArray))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt8MultiArray>())).layout as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt8MultiArray),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt8MultiArray>())).data as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt8MultiArray),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_msgs__msg__UInt8MultiArray__Sequence {
    pub data: *mut std_msgs__msg__UInt8MultiArray,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_std_msgs__msg__UInt8MultiArray__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<std_msgs__msg__UInt8MultiArray__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(std_msgs__msg__UInt8MultiArray__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_msgs__msg__UInt8MultiArray__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(std_msgs__msg__UInt8MultiArray__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt8MultiArray__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt8MultiArray__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt8MultiArray__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt8MultiArray__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<std_msgs__msg__UInt8MultiArray__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(std_msgs__msg__UInt8MultiArray__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/UInt8MultiArray message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* std_msgs__msg__UInt8MultiArray"]
    #[doc = "* )) before or use"]
    #[doc = "* std_msgs__msg__UInt8MultiArray__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt8MultiArray__init(msg: *mut std_msgs__msg__UInt8MultiArray) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/UInt8MultiArray message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt8MultiArray__fini(msg: *mut std_msgs__msg__UInt8MultiArray);
}
extern "C" {
    #[doc = " Create msg/UInt8MultiArray message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* std_msgs__msg__UInt8MultiArray__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt8MultiArray__create() -> *mut std_msgs__msg__UInt8MultiArray;
}
extern "C" {
    #[doc = " Destroy msg/UInt8MultiArray message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__UInt8MultiArray__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt8MultiArray__destroy(msg: *mut std_msgs__msg__UInt8MultiArray);
}
extern "C" {
    #[doc = " Check for msg/UInt8MultiArray message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt8MultiArray__are_equal(
        lhs: *const std_msgs__msg__UInt8MultiArray,
        rhs: *const std_msgs__msg__UInt8MultiArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/UInt8MultiArray message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt8MultiArray__copy(
        input: *const std_msgs__msg__UInt8MultiArray,
        output: *mut std_msgs__msg__UInt8MultiArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/UInt8MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* std_msgs__msg__UInt8MultiArray__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt8MultiArray__Sequence__init(
        array: *mut std_msgs__msg__UInt8MultiArray__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/UInt8MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__UInt8MultiArray__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt8MultiArray__Sequence__fini(
        array: *mut std_msgs__msg__UInt8MultiArray__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/UInt8MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* std_msgs__msg__UInt8MultiArray__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt8MultiArray__Sequence__create(
        size: size_t,
    ) -> *mut std_msgs__msg__UInt8MultiArray__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/UInt8MultiArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* std_msgs__msg__UInt8MultiArray__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt8MultiArray__Sequence__destroy(
        array: *mut std_msgs__msg__UInt8MultiArray__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/UInt8MultiArray message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt8MultiArray__Sequence__are_equal(
        lhs: *const std_msgs__msg__UInt8MultiArray__Sequence,
        rhs: *const std_msgs__msg__UInt8MultiArray__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/UInt8MultiArray messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn std_msgs__msg__UInt8MultiArray__Sequence__copy(
        input: *const std_msgs__msg__UInt8MultiArray__Sequence,
        output: *mut std_msgs__msg__UInt8MultiArray__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__std_msgs__msg__UInt8MultiArray(
    ) -> *const rosidl_message_type_support_t;
}
extern "C" {
    #[doc = " Initialize msg/Time message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* builtin_interfaces__msg__Time"]
    #[doc = "* )) before or use"]
    #[doc = "* builtin_interfaces__msg__Time__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn builtin_interfaces__msg__Time__init(msg: *mut builtin_interfaces__msg__Time) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Time message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn builtin_interfaces__msg__Time__fini(msg: *mut builtin_interfaces__msg__Time);
}
extern "C" {
    #[doc = " Create msg/Time message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* builtin_interfaces__msg__Time__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn builtin_interfaces__msg__Time__create() -> *mut builtin_interfaces__msg__Time;
}
extern "C" {
    #[doc = " Destroy msg/Time message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* builtin_interfaces__msg__Time__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn builtin_interfaces__msg__Time__destroy(msg: *mut builtin_interfaces__msg__Time);
}
extern "C" {
    #[doc = " Check for msg/Time message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn builtin_interfaces__msg__Time__are_equal(
        lhs: *const builtin_interfaces__msg__Time,
        rhs: *const builtin_interfaces__msg__Time,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Time message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn builtin_interfaces__msg__Time__copy(
        input: *const builtin_interfaces__msg__Time,
        output: *mut builtin_interfaces__msg__Time,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Time messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* builtin_interfaces__msg__Time__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn builtin_interfaces__msg__Time__Sequence__init(
        array: *mut builtin_interfaces__msg__Time__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Time messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* builtin_interfaces__msg__Time__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn builtin_interfaces__msg__Time__Sequence__fini(
        array: *mut builtin_interfaces__msg__Time__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/Time messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* builtin_interfaces__msg__Time__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn builtin_interfaces__msg__Time__Sequence__create(
        size: size_t,
    ) -> *mut builtin_interfaces__msg__Time__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Time messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* builtin_interfaces__msg__Time__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn builtin_interfaces__msg__Time__Sequence__destroy(
        array: *mut builtin_interfaces__msg__Time__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Time message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn builtin_interfaces__msg__Time__Sequence__are_equal(
        lhs: *const builtin_interfaces__msg__Time__Sequence,
        rhs: *const builtin_interfaces__msg__Time__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Time messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn builtin_interfaces__msg__Time__Sequence__copy(
        input: *const builtin_interfaces__msg__Time__Sequence,
        output: *mut builtin_interfaces__msg__Time__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__builtin_interfaces__msg__Time(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct builtin_interfaces__msg__Duration {
    pub sec: i32,
    pub nanosec: u32,
}
#[test]
fn bindgen_test_layout_builtin_interfaces__msg__Duration() {
    assert_eq!(
        ::std::mem::size_of::<builtin_interfaces__msg__Duration>(),
        8usize,
        concat!("Size of: ", stringify!(builtin_interfaces__msg__Duration))
    );
    assert_eq!(
        ::std::mem::align_of::<builtin_interfaces__msg__Duration>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(builtin_interfaces__msg__Duration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<builtin_interfaces__msg__Duration>())).sec as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(builtin_interfaces__msg__Duration),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<builtin_interfaces__msg__Duration>())).nanosec as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(builtin_interfaces__msg__Duration),
            "::",
            stringify!(nanosec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct builtin_interfaces__msg__Duration__Sequence {
    pub data: *mut builtin_interfaces__msg__Duration,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_builtin_interfaces__msg__Duration__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<builtin_interfaces__msg__Duration__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(builtin_interfaces__msg__Duration__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<builtin_interfaces__msg__Duration__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(builtin_interfaces__msg__Duration__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<builtin_interfaces__msg__Duration__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(builtin_interfaces__msg__Duration__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<builtin_interfaces__msg__Duration__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(builtin_interfaces__msg__Duration__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<builtin_interfaces__msg__Duration__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(builtin_interfaces__msg__Duration__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Duration message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* builtin_interfaces__msg__Duration"]
    #[doc = "* )) before or use"]
    #[doc = "* builtin_interfaces__msg__Duration__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn builtin_interfaces__msg__Duration__init(
        msg: *mut builtin_interfaces__msg__Duration,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Duration message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn builtin_interfaces__msg__Duration__fini(msg: *mut builtin_interfaces__msg__Duration);
}
extern "C" {
    #[doc = " Create msg/Duration message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* builtin_interfaces__msg__Duration__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn builtin_interfaces__msg__Duration__create() -> *mut builtin_interfaces__msg__Duration;
}
extern "C" {
    #[doc = " Destroy msg/Duration message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* builtin_interfaces__msg__Duration__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn builtin_interfaces__msg__Duration__destroy(msg: *mut builtin_interfaces__msg__Duration);
}
extern "C" {
    #[doc = " Check for msg/Duration message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn builtin_interfaces__msg__Duration__are_equal(
        lhs: *const builtin_interfaces__msg__Duration,
        rhs: *const builtin_interfaces__msg__Duration,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Duration message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn builtin_interfaces__msg__Duration__copy(
        input: *const builtin_interfaces__msg__Duration,
        output: *mut builtin_interfaces__msg__Duration,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Duration messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* builtin_interfaces__msg__Duration__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn builtin_interfaces__msg__Duration__Sequence__init(
        array: *mut builtin_interfaces__msg__Duration__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Duration messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* builtin_interfaces__msg__Duration__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn builtin_interfaces__msg__Duration__Sequence__fini(
        array: *mut builtin_interfaces__msg__Duration__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/Duration messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* builtin_interfaces__msg__Duration__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn builtin_interfaces__msg__Duration__Sequence__create(
        size: size_t,
    ) -> *mut builtin_interfaces__msg__Duration__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Duration messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* builtin_interfaces__msg__Duration__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn builtin_interfaces__msg__Duration__Sequence__destroy(
        array: *mut builtin_interfaces__msg__Duration__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Duration message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn builtin_interfaces__msg__Duration__Sequence__are_equal(
        lhs: *const builtin_interfaces__msg__Duration__Sequence,
        rhs: *const builtin_interfaces__msg__Duration__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Duration messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn builtin_interfaces__msg__Duration__Sequence__copy(
        input: *const builtin_interfaces__msg__Duration__Sequence,
        output: *mut builtin_interfaces__msg__Duration__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__builtin_interfaces__msg__Duration(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Vector3 {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Vector3() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Vector3>(),
        24usize,
        concat!("Size of: ", stringify!(geometry_msgs__msg__Vector3))
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Vector3>(),
        8usize,
        concat!("Alignment of ", stringify!(geometry_msgs__msg__Vector3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<geometry_msgs__msg__Vector3>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Vector3),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<geometry_msgs__msg__Vector3>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Vector3),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<geometry_msgs__msg__Vector3>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Vector3),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Vector3__Sequence {
    pub data: *mut geometry_msgs__msg__Vector3,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Vector3__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Vector3__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__Vector3__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Vector3__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__Vector3__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Vector3__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Vector3__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Vector3__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Vector3__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Vector3__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Vector3__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Accel {
    pub linear: geometry_msgs__msg__Vector3,
    pub angular: geometry_msgs__msg__Vector3,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Accel() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Accel>(),
        48usize,
        concat!("Size of: ", stringify!(geometry_msgs__msg__Accel))
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Accel>(),
        8usize,
        concat!("Alignment of ", stringify!(geometry_msgs__msg__Accel))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Accel>())).linear as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Accel),
            "::",
            stringify!(linear)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Accel>())).angular as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Accel),
            "::",
            stringify!(angular)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Accel__Sequence {
    pub data: *mut geometry_msgs__msg__Accel,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Accel__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Accel__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(geometry_msgs__msg__Accel__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Accel__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__Accel__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Accel__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Accel__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Accel__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Accel__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Accel__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Accel__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Accel message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__Accel"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__Accel__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Accel__init(msg: *mut geometry_msgs__msg__Accel) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Accel message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Accel__fini(msg: *mut geometry_msgs__msg__Accel);
}
extern "C" {
    #[doc = " Create msg/Accel message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__Accel__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Accel__create() -> *mut geometry_msgs__msg__Accel;
}
extern "C" {
    #[doc = " Destroy msg/Accel message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Accel__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Accel__destroy(msg: *mut geometry_msgs__msg__Accel);
}
extern "C" {
    #[doc = " Check for msg/Accel message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Accel__are_equal(
        lhs: *const geometry_msgs__msg__Accel,
        rhs: *const geometry_msgs__msg__Accel,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Accel message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Accel__copy(
        input: *const geometry_msgs__msg__Accel,
        output: *mut geometry_msgs__msg__Accel,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Accel messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__Accel__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Accel__Sequence__init(
        array: *mut geometry_msgs__msg__Accel__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Accel messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Accel__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Accel__Sequence__fini(
        array: *mut geometry_msgs__msg__Accel__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/Accel messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__Accel__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Accel__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__Accel__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Accel messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Accel__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Accel__Sequence__destroy(
        array: *mut geometry_msgs__msg__Accel__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Accel message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Accel__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__Accel__Sequence,
        rhs: *const geometry_msgs__msg__Accel__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Accel messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Accel__Sequence__copy(
        input: *const geometry_msgs__msg__Accel__Sequence,
        output: *mut geometry_msgs__msg__Accel__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__Accel(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__AccelStamped {
    pub header: std_msgs__msg__Header,
    pub accel: geometry_msgs__msg__Accel,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__AccelStamped() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__AccelStamped>(),
        80usize,
        concat!("Size of: ", stringify!(geometry_msgs__msg__AccelStamped))
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__AccelStamped>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__AccelStamped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__AccelStamped>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__AccelStamped),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__AccelStamped>())).accel as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__AccelStamped),
            "::",
            stringify!(accel)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__AccelStamped__Sequence {
    pub data: *mut geometry_msgs__msg__AccelStamped,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__AccelStamped__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__AccelStamped__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__AccelStamped__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__AccelStamped__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__AccelStamped__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__AccelStamped__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__AccelStamped__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__AccelStamped__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__AccelStamped__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__AccelStamped__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__AccelStamped__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/AccelStamped message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__AccelStamped"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__AccelStamped__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelStamped__init(
        msg: *mut geometry_msgs__msg__AccelStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/AccelStamped message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelStamped__fini(msg: *mut geometry_msgs__msg__AccelStamped);
}
extern "C" {
    #[doc = " Create msg/AccelStamped message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__AccelStamped__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelStamped__create() -> *mut geometry_msgs__msg__AccelStamped;
}
extern "C" {
    #[doc = " Destroy msg/AccelStamped message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__AccelStamped__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelStamped__destroy(msg: *mut geometry_msgs__msg__AccelStamped);
}
extern "C" {
    #[doc = " Check for msg/AccelStamped message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelStamped__are_equal(
        lhs: *const geometry_msgs__msg__AccelStamped,
        rhs: *const geometry_msgs__msg__AccelStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/AccelStamped message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelStamped__copy(
        input: *const geometry_msgs__msg__AccelStamped,
        output: *mut geometry_msgs__msg__AccelStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/AccelStamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__AccelStamped__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelStamped__Sequence__init(
        array: *mut geometry_msgs__msg__AccelStamped__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/AccelStamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__AccelStamped__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelStamped__Sequence__fini(
        array: *mut geometry_msgs__msg__AccelStamped__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/AccelStamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__AccelStamped__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelStamped__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__AccelStamped__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/AccelStamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__AccelStamped__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelStamped__Sequence__destroy(
        array: *mut geometry_msgs__msg__AccelStamped__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/AccelStamped message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelStamped__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__AccelStamped__Sequence,
        rhs: *const geometry_msgs__msg__AccelStamped__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/AccelStamped messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelStamped__Sequence__copy(
        input: *const geometry_msgs__msg__AccelStamped__Sequence,
        output: *mut geometry_msgs__msg__AccelStamped__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__AccelStamped(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__AccelWithCovariance {
    pub accel: geometry_msgs__msg__Accel,
    pub covariance: [f64; 36usize],
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__AccelWithCovariance() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__AccelWithCovariance>(),
        336usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__AccelWithCovariance)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__AccelWithCovariance>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__AccelWithCovariance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__AccelWithCovariance>())).accel as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__AccelWithCovariance),
            "::",
            stringify!(accel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__AccelWithCovariance>())).covariance
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__AccelWithCovariance),
            "::",
            stringify!(covariance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__AccelWithCovariance__Sequence {
    pub data: *mut geometry_msgs__msg__AccelWithCovariance,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__AccelWithCovariance__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__AccelWithCovariance__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__AccelWithCovariance__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__AccelWithCovariance__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__AccelWithCovariance__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__AccelWithCovariance__Sequence>())).data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__AccelWithCovariance__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__AccelWithCovariance__Sequence>())).size
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__AccelWithCovariance__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__AccelWithCovariance__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__AccelWithCovariance__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/AccelWithCovariance message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__AccelWithCovariance"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__AccelWithCovariance__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelWithCovariance__init(
        msg: *mut geometry_msgs__msg__AccelWithCovariance,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/AccelWithCovariance message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelWithCovariance__fini(
        msg: *mut geometry_msgs__msg__AccelWithCovariance,
    );
}
extern "C" {
    #[doc = " Create msg/AccelWithCovariance message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__AccelWithCovariance__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelWithCovariance__create(
    ) -> *mut geometry_msgs__msg__AccelWithCovariance;
}
extern "C" {
    #[doc = " Destroy msg/AccelWithCovariance message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__AccelWithCovariance__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelWithCovariance__destroy(
        msg: *mut geometry_msgs__msg__AccelWithCovariance,
    );
}
extern "C" {
    #[doc = " Check for msg/AccelWithCovariance message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelWithCovariance__are_equal(
        lhs: *const geometry_msgs__msg__AccelWithCovariance,
        rhs: *const geometry_msgs__msg__AccelWithCovariance,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/AccelWithCovariance message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelWithCovariance__copy(
        input: *const geometry_msgs__msg__AccelWithCovariance,
        output: *mut geometry_msgs__msg__AccelWithCovariance,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/AccelWithCovariance messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__AccelWithCovariance__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelWithCovariance__Sequence__init(
        array: *mut geometry_msgs__msg__AccelWithCovariance__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/AccelWithCovariance messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__AccelWithCovariance__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelWithCovariance__Sequence__fini(
        array: *mut geometry_msgs__msg__AccelWithCovariance__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/AccelWithCovariance messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__AccelWithCovariance__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelWithCovariance__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__AccelWithCovariance__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/AccelWithCovariance messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__AccelWithCovariance__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelWithCovariance__Sequence__destroy(
        array: *mut geometry_msgs__msg__AccelWithCovariance__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/AccelWithCovariance message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelWithCovariance__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__AccelWithCovariance__Sequence,
        rhs: *const geometry_msgs__msg__AccelWithCovariance__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/AccelWithCovariance messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelWithCovariance__Sequence__copy(
        input: *const geometry_msgs__msg__AccelWithCovariance__Sequence,
        output: *mut geometry_msgs__msg__AccelWithCovariance__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__AccelWithCovariance(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__AccelWithCovarianceStamped {
    pub header: std_msgs__msg__Header,
    pub accel: geometry_msgs__msg__AccelWithCovariance,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__AccelWithCovarianceStamped() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__AccelWithCovarianceStamped>(),
        368usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__AccelWithCovarianceStamped)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__AccelWithCovarianceStamped>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__AccelWithCovarianceStamped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__AccelWithCovarianceStamped>())).header
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__AccelWithCovarianceStamped),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__AccelWithCovarianceStamped>())).accel
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__AccelWithCovarianceStamped),
            "::",
            stringify!(accel)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__AccelWithCovarianceStamped__Sequence {
    pub data: *mut geometry_msgs__msg__AccelWithCovarianceStamped,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__AccelWithCovarianceStamped__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__AccelWithCovarianceStamped__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__AccelWithCovarianceStamped__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__AccelWithCovarianceStamped__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__AccelWithCovarianceStamped__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__AccelWithCovarianceStamped__Sequence>()))
                .data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__AccelWithCovarianceStamped__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__AccelWithCovarianceStamped__Sequence>()))
                .size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__AccelWithCovarianceStamped__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__AccelWithCovarianceStamped__Sequence>()))
                .capacity as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__AccelWithCovarianceStamped__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/AccelWithCovarianceStamped message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__AccelWithCovarianceStamped"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__AccelWithCovarianceStamped__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelWithCovarianceStamped__init(
        msg: *mut geometry_msgs__msg__AccelWithCovarianceStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/AccelWithCovarianceStamped message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelWithCovarianceStamped__fini(
        msg: *mut geometry_msgs__msg__AccelWithCovarianceStamped,
    );
}
extern "C" {
    #[doc = " Create msg/AccelWithCovarianceStamped message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__AccelWithCovarianceStamped__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelWithCovarianceStamped__create(
    ) -> *mut geometry_msgs__msg__AccelWithCovarianceStamped;
}
extern "C" {
    #[doc = " Destroy msg/AccelWithCovarianceStamped message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__AccelWithCovarianceStamped__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelWithCovarianceStamped__destroy(
        msg: *mut geometry_msgs__msg__AccelWithCovarianceStamped,
    );
}
extern "C" {
    #[doc = " Check for msg/AccelWithCovarianceStamped message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelWithCovarianceStamped__are_equal(
        lhs: *const geometry_msgs__msg__AccelWithCovarianceStamped,
        rhs: *const geometry_msgs__msg__AccelWithCovarianceStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/AccelWithCovarianceStamped message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelWithCovarianceStamped__copy(
        input: *const geometry_msgs__msg__AccelWithCovarianceStamped,
        output: *mut geometry_msgs__msg__AccelWithCovarianceStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/AccelWithCovarianceStamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__AccelWithCovarianceStamped__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelWithCovarianceStamped__Sequence__init(
        array: *mut geometry_msgs__msg__AccelWithCovarianceStamped__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/AccelWithCovarianceStamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__AccelWithCovarianceStamped__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelWithCovarianceStamped__Sequence__fini(
        array: *mut geometry_msgs__msg__AccelWithCovarianceStamped__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/AccelWithCovarianceStamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__AccelWithCovarianceStamped__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelWithCovarianceStamped__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__AccelWithCovarianceStamped__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/AccelWithCovarianceStamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__AccelWithCovarianceStamped__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelWithCovarianceStamped__Sequence__destroy(
        array: *mut geometry_msgs__msg__AccelWithCovarianceStamped__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/AccelWithCovarianceStamped message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelWithCovarianceStamped__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__AccelWithCovarianceStamped__Sequence,
        rhs: *const geometry_msgs__msg__AccelWithCovarianceStamped__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/AccelWithCovarianceStamped messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__AccelWithCovarianceStamped__Sequence__copy(
        input: *const geometry_msgs__msg__AccelWithCovarianceStamped__Sequence,
        output: *mut geometry_msgs__msg__AccelWithCovarianceStamped__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__AccelWithCovarianceStamped(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Inertia {
    pub m: f64,
    pub com: geometry_msgs__msg__Vector3,
    pub ixx: f64,
    pub ixy: f64,
    pub ixz: f64,
    pub iyy: f64,
    pub iyz: f64,
    pub izz: f64,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Inertia() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Inertia>(),
        80usize,
        concat!("Size of: ", stringify!(geometry_msgs__msg__Inertia))
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Inertia>(),
        8usize,
        concat!("Alignment of ", stringify!(geometry_msgs__msg__Inertia))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<geometry_msgs__msg__Inertia>())).m as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Inertia),
            "::",
            stringify!(m)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<geometry_msgs__msg__Inertia>())).com as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Inertia),
            "::",
            stringify!(com)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<geometry_msgs__msg__Inertia>())).ixx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Inertia),
            "::",
            stringify!(ixx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<geometry_msgs__msg__Inertia>())).ixy as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Inertia),
            "::",
            stringify!(ixy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<geometry_msgs__msg__Inertia>())).ixz as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Inertia),
            "::",
            stringify!(ixz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<geometry_msgs__msg__Inertia>())).iyy as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Inertia),
            "::",
            stringify!(iyy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<geometry_msgs__msg__Inertia>())).iyz as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Inertia),
            "::",
            stringify!(iyz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<geometry_msgs__msg__Inertia>())).izz as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Inertia),
            "::",
            stringify!(izz)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Inertia__Sequence {
    pub data: *mut geometry_msgs__msg__Inertia,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Inertia__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Inertia__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__Inertia__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Inertia__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__Inertia__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Inertia__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Inertia__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Inertia__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Inertia__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Inertia__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Inertia__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Inertia message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__Inertia"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__Inertia__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Inertia__init(msg: *mut geometry_msgs__msg__Inertia) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Inertia message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Inertia__fini(msg: *mut geometry_msgs__msg__Inertia);
}
extern "C" {
    #[doc = " Create msg/Inertia message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__Inertia__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Inertia__create() -> *mut geometry_msgs__msg__Inertia;
}
extern "C" {
    #[doc = " Destroy msg/Inertia message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Inertia__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Inertia__destroy(msg: *mut geometry_msgs__msg__Inertia);
}
extern "C" {
    #[doc = " Check for msg/Inertia message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Inertia__are_equal(
        lhs: *const geometry_msgs__msg__Inertia,
        rhs: *const geometry_msgs__msg__Inertia,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Inertia message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Inertia__copy(
        input: *const geometry_msgs__msg__Inertia,
        output: *mut geometry_msgs__msg__Inertia,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Inertia messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__Inertia__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Inertia__Sequence__init(
        array: *mut geometry_msgs__msg__Inertia__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Inertia messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Inertia__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Inertia__Sequence__fini(
        array: *mut geometry_msgs__msg__Inertia__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/Inertia messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__Inertia__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Inertia__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__Inertia__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Inertia messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Inertia__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Inertia__Sequence__destroy(
        array: *mut geometry_msgs__msg__Inertia__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Inertia message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Inertia__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__Inertia__Sequence,
        rhs: *const geometry_msgs__msg__Inertia__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Inertia messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Inertia__Sequence__copy(
        input: *const geometry_msgs__msg__Inertia__Sequence,
        output: *mut geometry_msgs__msg__Inertia__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__Inertia(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__InertiaStamped {
    pub header: std_msgs__msg__Header,
    pub inertia: geometry_msgs__msg__Inertia,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__InertiaStamped() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__InertiaStamped>(),
        112usize,
        concat!("Size of: ", stringify!(geometry_msgs__msg__InertiaStamped))
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__InertiaStamped>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__InertiaStamped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__InertiaStamped>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__InertiaStamped),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__InertiaStamped>())).inertia as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__InertiaStamped),
            "::",
            stringify!(inertia)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__InertiaStamped__Sequence {
    pub data: *mut geometry_msgs__msg__InertiaStamped,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__InertiaStamped__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__InertiaStamped__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__InertiaStamped__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__InertiaStamped__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__InertiaStamped__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__InertiaStamped__Sequence>())).data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__InertiaStamped__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__InertiaStamped__Sequence>())).size
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__InertiaStamped__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__InertiaStamped__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__InertiaStamped__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/InertiaStamped message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__InertiaStamped"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__InertiaStamped__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__InertiaStamped__init(
        msg: *mut geometry_msgs__msg__InertiaStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/InertiaStamped message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__InertiaStamped__fini(msg: *mut geometry_msgs__msg__InertiaStamped);
}
extern "C" {
    #[doc = " Create msg/InertiaStamped message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__InertiaStamped__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__InertiaStamped__create() -> *mut geometry_msgs__msg__InertiaStamped;
}
extern "C" {
    #[doc = " Destroy msg/InertiaStamped message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__InertiaStamped__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__InertiaStamped__destroy(
        msg: *mut geometry_msgs__msg__InertiaStamped,
    );
}
extern "C" {
    #[doc = " Check for msg/InertiaStamped message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__InertiaStamped__are_equal(
        lhs: *const geometry_msgs__msg__InertiaStamped,
        rhs: *const geometry_msgs__msg__InertiaStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/InertiaStamped message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__InertiaStamped__copy(
        input: *const geometry_msgs__msg__InertiaStamped,
        output: *mut geometry_msgs__msg__InertiaStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/InertiaStamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__InertiaStamped__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__InertiaStamped__Sequence__init(
        array: *mut geometry_msgs__msg__InertiaStamped__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/InertiaStamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__InertiaStamped__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__InertiaStamped__Sequence__fini(
        array: *mut geometry_msgs__msg__InertiaStamped__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/InertiaStamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__InertiaStamped__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__InertiaStamped__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__InertiaStamped__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/InertiaStamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__InertiaStamped__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__InertiaStamped__Sequence__destroy(
        array: *mut geometry_msgs__msg__InertiaStamped__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/InertiaStamped message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__InertiaStamped__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__InertiaStamped__Sequence,
        rhs: *const geometry_msgs__msg__InertiaStamped__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/InertiaStamped messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__InertiaStamped__Sequence__copy(
        input: *const geometry_msgs__msg__InertiaStamped__Sequence,
        output: *mut geometry_msgs__msg__InertiaStamped__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__InertiaStamped(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Point {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Point() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Point>(),
        24usize,
        concat!("Size of: ", stringify!(geometry_msgs__msg__Point))
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Point>(),
        8usize,
        concat!("Alignment of ", stringify!(geometry_msgs__msg__Point))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<geometry_msgs__msg__Point>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Point),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<geometry_msgs__msg__Point>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Point),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<geometry_msgs__msg__Point>())).z as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Point),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Point__Sequence {
    pub data: *mut geometry_msgs__msg__Point,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Point__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Point__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(geometry_msgs__msg__Point__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Point__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__Point__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Point__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Point__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Point__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Point__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Point__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Point__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Point message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__Point"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__Point__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Point__init(msg: *mut geometry_msgs__msg__Point) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Point message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Point__fini(msg: *mut geometry_msgs__msg__Point);
}
extern "C" {
    #[doc = " Create msg/Point message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__Point__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Point__create() -> *mut geometry_msgs__msg__Point;
}
extern "C" {
    #[doc = " Destroy msg/Point message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Point__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Point__destroy(msg: *mut geometry_msgs__msg__Point);
}
extern "C" {
    #[doc = " Check for msg/Point message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Point__are_equal(
        lhs: *const geometry_msgs__msg__Point,
        rhs: *const geometry_msgs__msg__Point,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Point message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Point__copy(
        input: *const geometry_msgs__msg__Point,
        output: *mut geometry_msgs__msg__Point,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Point messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__Point__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Point__Sequence__init(
        array: *mut geometry_msgs__msg__Point__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Point messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Point__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Point__Sequence__fini(
        array: *mut geometry_msgs__msg__Point__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/Point messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__Point__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Point__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__Point__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Point messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Point__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Point__Sequence__destroy(
        array: *mut geometry_msgs__msg__Point__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Point message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Point__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__Point__Sequence,
        rhs: *const geometry_msgs__msg__Point__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Point messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Point__Sequence__copy(
        input: *const geometry_msgs__msg__Point__Sequence,
        output: *mut geometry_msgs__msg__Point__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__Point(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Point32 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Point32() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Point32>(),
        12usize,
        concat!("Size of: ", stringify!(geometry_msgs__msg__Point32))
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Point32>(),
        4usize,
        concat!("Alignment of ", stringify!(geometry_msgs__msg__Point32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<geometry_msgs__msg__Point32>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Point32),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<geometry_msgs__msg__Point32>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Point32),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<geometry_msgs__msg__Point32>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Point32),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Point32__Sequence {
    pub data: *mut geometry_msgs__msg__Point32,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Point32__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Point32__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__Point32__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Point32__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__Point32__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Point32__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Point32__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Point32__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Point32__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Point32__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Point32__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Point32 message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__Point32"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__Point32__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Point32__init(msg: *mut geometry_msgs__msg__Point32) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Point32 message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Point32__fini(msg: *mut geometry_msgs__msg__Point32);
}
extern "C" {
    #[doc = " Create msg/Point32 message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__Point32__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Point32__create() -> *mut geometry_msgs__msg__Point32;
}
extern "C" {
    #[doc = " Destroy msg/Point32 message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Point32__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Point32__destroy(msg: *mut geometry_msgs__msg__Point32);
}
extern "C" {
    #[doc = " Check for msg/Point32 message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Point32__are_equal(
        lhs: *const geometry_msgs__msg__Point32,
        rhs: *const geometry_msgs__msg__Point32,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Point32 message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Point32__copy(
        input: *const geometry_msgs__msg__Point32,
        output: *mut geometry_msgs__msg__Point32,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Point32 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__Point32__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Point32__Sequence__init(
        array: *mut geometry_msgs__msg__Point32__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Point32 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Point32__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Point32__Sequence__fini(
        array: *mut geometry_msgs__msg__Point32__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/Point32 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__Point32__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Point32__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__Point32__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Point32 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Point32__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Point32__Sequence__destroy(
        array: *mut geometry_msgs__msg__Point32__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Point32 message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Point32__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__Point32__Sequence,
        rhs: *const geometry_msgs__msg__Point32__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Point32 messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Point32__Sequence__copy(
        input: *const geometry_msgs__msg__Point32__Sequence,
        output: *mut geometry_msgs__msg__Point32__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__Point32(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__PointStamped {
    pub header: std_msgs__msg__Header,
    pub point: geometry_msgs__msg__Point,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__PointStamped() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__PointStamped>(),
        56usize,
        concat!("Size of: ", stringify!(geometry_msgs__msg__PointStamped))
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__PointStamped>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__PointStamped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PointStamped>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PointStamped),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PointStamped>())).point as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PointStamped),
            "::",
            stringify!(point)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__PointStamped__Sequence {
    pub data: *mut geometry_msgs__msg__PointStamped,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__PointStamped__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__PointStamped__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__PointStamped__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__PointStamped__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__PointStamped__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PointStamped__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PointStamped__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PointStamped__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PointStamped__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PointStamped__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PointStamped__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/PointStamped message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__PointStamped"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__PointStamped__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PointStamped__init(
        msg: *mut geometry_msgs__msg__PointStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/PointStamped message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PointStamped__fini(msg: *mut geometry_msgs__msg__PointStamped);
}
extern "C" {
    #[doc = " Create msg/PointStamped message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__PointStamped__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PointStamped__create() -> *mut geometry_msgs__msg__PointStamped;
}
extern "C" {
    #[doc = " Destroy msg/PointStamped message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__PointStamped__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PointStamped__destroy(msg: *mut geometry_msgs__msg__PointStamped);
}
extern "C" {
    #[doc = " Check for msg/PointStamped message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PointStamped__are_equal(
        lhs: *const geometry_msgs__msg__PointStamped,
        rhs: *const geometry_msgs__msg__PointStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/PointStamped message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PointStamped__copy(
        input: *const geometry_msgs__msg__PointStamped,
        output: *mut geometry_msgs__msg__PointStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/PointStamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__PointStamped__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PointStamped__Sequence__init(
        array: *mut geometry_msgs__msg__PointStamped__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/PointStamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__PointStamped__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PointStamped__Sequence__fini(
        array: *mut geometry_msgs__msg__PointStamped__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/PointStamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__PointStamped__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PointStamped__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__PointStamped__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/PointStamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__PointStamped__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PointStamped__Sequence__destroy(
        array: *mut geometry_msgs__msg__PointStamped__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/PointStamped message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PointStamped__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__PointStamped__Sequence,
        rhs: *const geometry_msgs__msg__PointStamped__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/PointStamped messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PointStamped__Sequence__copy(
        input: *const geometry_msgs__msg__PointStamped__Sequence,
        output: *mut geometry_msgs__msg__PointStamped__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__PointStamped(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Polygon {
    pub points: geometry_msgs__msg__Point32__Sequence,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Polygon() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Polygon>(),
        24usize,
        concat!("Size of: ", stringify!(geometry_msgs__msg__Polygon))
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Polygon>(),
        8usize,
        concat!("Alignment of ", stringify!(geometry_msgs__msg__Polygon))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Polygon>())).points as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Polygon),
            "::",
            stringify!(points)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Polygon__Sequence {
    pub data: *mut geometry_msgs__msg__Polygon,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Polygon__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Polygon__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__Polygon__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Polygon__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__Polygon__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Polygon__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Polygon__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Polygon__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Polygon__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Polygon__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Polygon__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Polygon message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__Polygon"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__Polygon__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Polygon__init(msg: *mut geometry_msgs__msg__Polygon) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Polygon message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Polygon__fini(msg: *mut geometry_msgs__msg__Polygon);
}
extern "C" {
    #[doc = " Create msg/Polygon message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__Polygon__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Polygon__create() -> *mut geometry_msgs__msg__Polygon;
}
extern "C" {
    #[doc = " Destroy msg/Polygon message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Polygon__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Polygon__destroy(msg: *mut geometry_msgs__msg__Polygon);
}
extern "C" {
    #[doc = " Check for msg/Polygon message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Polygon__are_equal(
        lhs: *const geometry_msgs__msg__Polygon,
        rhs: *const geometry_msgs__msg__Polygon,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Polygon message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Polygon__copy(
        input: *const geometry_msgs__msg__Polygon,
        output: *mut geometry_msgs__msg__Polygon,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Polygon messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__Polygon__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Polygon__Sequence__init(
        array: *mut geometry_msgs__msg__Polygon__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Polygon messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Polygon__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Polygon__Sequence__fini(
        array: *mut geometry_msgs__msg__Polygon__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/Polygon messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__Polygon__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Polygon__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__Polygon__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Polygon messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Polygon__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Polygon__Sequence__destroy(
        array: *mut geometry_msgs__msg__Polygon__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Polygon message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Polygon__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__Polygon__Sequence,
        rhs: *const geometry_msgs__msg__Polygon__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Polygon messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Polygon__Sequence__copy(
        input: *const geometry_msgs__msg__Polygon__Sequence,
        output: *mut geometry_msgs__msg__Polygon__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__Polygon(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__PolygonStamped {
    pub header: std_msgs__msg__Header,
    pub polygon: geometry_msgs__msg__Polygon,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__PolygonStamped() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__PolygonStamped>(),
        56usize,
        concat!("Size of: ", stringify!(geometry_msgs__msg__PolygonStamped))
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__PolygonStamped>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__PolygonStamped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PolygonStamped>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PolygonStamped),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PolygonStamped>())).polygon as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PolygonStamped),
            "::",
            stringify!(polygon)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__PolygonStamped__Sequence {
    pub data: *mut geometry_msgs__msg__PolygonStamped,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__PolygonStamped__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__PolygonStamped__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__PolygonStamped__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__PolygonStamped__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__PolygonStamped__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PolygonStamped__Sequence>())).data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PolygonStamped__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PolygonStamped__Sequence>())).size
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PolygonStamped__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PolygonStamped__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PolygonStamped__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/PolygonStamped message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__PolygonStamped"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__PolygonStamped__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PolygonStamped__init(
        msg: *mut geometry_msgs__msg__PolygonStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/PolygonStamped message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PolygonStamped__fini(msg: *mut geometry_msgs__msg__PolygonStamped);
}
extern "C" {
    #[doc = " Create msg/PolygonStamped message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__PolygonStamped__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PolygonStamped__create() -> *mut geometry_msgs__msg__PolygonStamped;
}
extern "C" {
    #[doc = " Destroy msg/PolygonStamped message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__PolygonStamped__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PolygonStamped__destroy(
        msg: *mut geometry_msgs__msg__PolygonStamped,
    );
}
extern "C" {
    #[doc = " Check for msg/PolygonStamped message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PolygonStamped__are_equal(
        lhs: *const geometry_msgs__msg__PolygonStamped,
        rhs: *const geometry_msgs__msg__PolygonStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/PolygonStamped message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PolygonStamped__copy(
        input: *const geometry_msgs__msg__PolygonStamped,
        output: *mut geometry_msgs__msg__PolygonStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/PolygonStamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__PolygonStamped__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PolygonStamped__Sequence__init(
        array: *mut geometry_msgs__msg__PolygonStamped__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/PolygonStamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__PolygonStamped__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PolygonStamped__Sequence__fini(
        array: *mut geometry_msgs__msg__PolygonStamped__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/PolygonStamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__PolygonStamped__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PolygonStamped__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__PolygonStamped__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/PolygonStamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__PolygonStamped__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PolygonStamped__Sequence__destroy(
        array: *mut geometry_msgs__msg__PolygonStamped__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/PolygonStamped message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PolygonStamped__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__PolygonStamped__Sequence,
        rhs: *const geometry_msgs__msg__PolygonStamped__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/PolygonStamped messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PolygonStamped__Sequence__copy(
        input: *const geometry_msgs__msg__PolygonStamped__Sequence,
        output: *mut geometry_msgs__msg__PolygonStamped__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__PolygonStamped(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Quaternion {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub w: f64,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Quaternion() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Quaternion>(),
        32usize,
        concat!("Size of: ", stringify!(geometry_msgs__msg__Quaternion))
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Quaternion>(),
        8usize,
        concat!("Alignment of ", stringify!(geometry_msgs__msg__Quaternion))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Quaternion>())).x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Quaternion),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Quaternion>())).y as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Quaternion),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Quaternion>())).z as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Quaternion),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Quaternion>())).w as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Quaternion),
            "::",
            stringify!(w)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Quaternion__Sequence {
    pub data: *mut geometry_msgs__msg__Quaternion,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Quaternion__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Quaternion__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__Quaternion__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Quaternion__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__Quaternion__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Quaternion__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Quaternion__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Quaternion__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Quaternion__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Quaternion__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Quaternion__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Pose {
    pub position: geometry_msgs__msg__Point,
    pub orientation: geometry_msgs__msg__Quaternion,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Pose() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Pose>(),
        56usize,
        concat!("Size of: ", stringify!(geometry_msgs__msg__Pose))
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Pose>(),
        8usize,
        concat!("Alignment of ", stringify!(geometry_msgs__msg__Pose))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Pose>())).position as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Pose),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Pose>())).orientation as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Pose),
            "::",
            stringify!(orientation)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Pose__Sequence {
    pub data: *mut geometry_msgs__msg__Pose,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Pose__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Pose__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(geometry_msgs__msg__Pose__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Pose__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__Pose__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Pose__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Pose__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Pose__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Pose__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Pose__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Pose__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Pose message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__Pose"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__Pose__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Pose__init(msg: *mut geometry_msgs__msg__Pose) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Pose message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Pose__fini(msg: *mut geometry_msgs__msg__Pose);
}
extern "C" {
    #[doc = " Create msg/Pose message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__Pose__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Pose__create() -> *mut geometry_msgs__msg__Pose;
}
extern "C" {
    #[doc = " Destroy msg/Pose message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Pose__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Pose__destroy(msg: *mut geometry_msgs__msg__Pose);
}
extern "C" {
    #[doc = " Check for msg/Pose message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Pose__are_equal(
        lhs: *const geometry_msgs__msg__Pose,
        rhs: *const geometry_msgs__msg__Pose,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Pose message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Pose__copy(
        input: *const geometry_msgs__msg__Pose,
        output: *mut geometry_msgs__msg__Pose,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Pose messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__Pose__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Pose__Sequence__init(
        array: *mut geometry_msgs__msg__Pose__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Pose messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Pose__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Pose__Sequence__fini(array: *mut geometry_msgs__msg__Pose__Sequence);
}
extern "C" {
    #[doc = " Create array of msg/Pose messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__Pose__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Pose__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__Pose__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Pose messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Pose__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Pose__Sequence__destroy(
        array: *mut geometry_msgs__msg__Pose__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Pose message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Pose__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__Pose__Sequence,
        rhs: *const geometry_msgs__msg__Pose__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Pose messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Pose__Sequence__copy(
        input: *const geometry_msgs__msg__Pose__Sequence,
        output: *mut geometry_msgs__msg__Pose__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__Pose(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Pose2D {
    pub x: f64,
    pub y: f64,
    pub theta: f64,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Pose2D() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Pose2D>(),
        24usize,
        concat!("Size of: ", stringify!(geometry_msgs__msg__Pose2D))
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Pose2D>(),
        8usize,
        concat!("Alignment of ", stringify!(geometry_msgs__msg__Pose2D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<geometry_msgs__msg__Pose2D>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Pose2D),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<geometry_msgs__msg__Pose2D>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Pose2D),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Pose2D>())).theta as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Pose2D),
            "::",
            stringify!(theta)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Pose2D__Sequence {
    pub data: *mut geometry_msgs__msg__Pose2D,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Pose2D__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Pose2D__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__Pose2D__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Pose2D__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__Pose2D__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Pose2D__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Pose2D__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Pose2D__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Pose2D__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Pose2D__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Pose2D__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Pose2D message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__Pose2D"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__Pose2D__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Pose2D__init(msg: *mut geometry_msgs__msg__Pose2D) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Pose2D message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Pose2D__fini(msg: *mut geometry_msgs__msg__Pose2D);
}
extern "C" {
    #[doc = " Create msg/Pose2D message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__Pose2D__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Pose2D__create() -> *mut geometry_msgs__msg__Pose2D;
}
extern "C" {
    #[doc = " Destroy msg/Pose2D message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Pose2D__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Pose2D__destroy(msg: *mut geometry_msgs__msg__Pose2D);
}
extern "C" {
    #[doc = " Check for msg/Pose2D message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Pose2D__are_equal(
        lhs: *const geometry_msgs__msg__Pose2D,
        rhs: *const geometry_msgs__msg__Pose2D,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Pose2D message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Pose2D__copy(
        input: *const geometry_msgs__msg__Pose2D,
        output: *mut geometry_msgs__msg__Pose2D,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Pose2D messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__Pose2D__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Pose2D__Sequence__init(
        array: *mut geometry_msgs__msg__Pose2D__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Pose2D messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Pose2D__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Pose2D__Sequence__fini(
        array: *mut geometry_msgs__msg__Pose2D__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/Pose2D messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__Pose2D__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Pose2D__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__Pose2D__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Pose2D messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Pose2D__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Pose2D__Sequence__destroy(
        array: *mut geometry_msgs__msg__Pose2D__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Pose2D message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Pose2D__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__Pose2D__Sequence,
        rhs: *const geometry_msgs__msg__Pose2D__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Pose2D messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Pose2D__Sequence__copy(
        input: *const geometry_msgs__msg__Pose2D__Sequence,
        output: *mut geometry_msgs__msg__Pose2D__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__Pose2D(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__PoseArray {
    pub header: std_msgs__msg__Header,
    pub poses: geometry_msgs__msg__Pose__Sequence,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__PoseArray() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__PoseArray>(),
        56usize,
        concat!("Size of: ", stringify!(geometry_msgs__msg__PoseArray))
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__PoseArray>(),
        8usize,
        concat!("Alignment of ", stringify!(geometry_msgs__msg__PoseArray))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PoseArray>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PoseArray),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PoseArray>())).poses as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PoseArray),
            "::",
            stringify!(poses)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__PoseArray__Sequence {
    pub data: *mut geometry_msgs__msg__PoseArray,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__PoseArray__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__PoseArray__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__PoseArray__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__PoseArray__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__PoseArray__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PoseArray__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PoseArray__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PoseArray__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PoseArray__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PoseArray__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PoseArray__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/PoseArray message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__PoseArray"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__PoseArray__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseArray__init(msg: *mut geometry_msgs__msg__PoseArray) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/PoseArray message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseArray__fini(msg: *mut geometry_msgs__msg__PoseArray);
}
extern "C" {
    #[doc = " Create msg/PoseArray message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__PoseArray__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseArray__create() -> *mut geometry_msgs__msg__PoseArray;
}
extern "C" {
    #[doc = " Destroy msg/PoseArray message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__PoseArray__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseArray__destroy(msg: *mut geometry_msgs__msg__PoseArray);
}
extern "C" {
    #[doc = " Check for msg/PoseArray message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseArray__are_equal(
        lhs: *const geometry_msgs__msg__PoseArray,
        rhs: *const geometry_msgs__msg__PoseArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/PoseArray message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseArray__copy(
        input: *const geometry_msgs__msg__PoseArray,
        output: *mut geometry_msgs__msg__PoseArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/PoseArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__PoseArray__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseArray__Sequence__init(
        array: *mut geometry_msgs__msg__PoseArray__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/PoseArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__PoseArray__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseArray__Sequence__fini(
        array: *mut geometry_msgs__msg__PoseArray__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/PoseArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__PoseArray__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseArray__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__PoseArray__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/PoseArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__PoseArray__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseArray__Sequence__destroy(
        array: *mut geometry_msgs__msg__PoseArray__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/PoseArray message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseArray__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__PoseArray__Sequence,
        rhs: *const geometry_msgs__msg__PoseArray__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/PoseArray messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseArray__Sequence__copy(
        input: *const geometry_msgs__msg__PoseArray__Sequence,
        output: *mut geometry_msgs__msg__PoseArray__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__PoseArray(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__PoseStamped {
    pub header: std_msgs__msg__Header,
    pub pose: geometry_msgs__msg__Pose,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__PoseStamped() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__PoseStamped>(),
        88usize,
        concat!("Size of: ", stringify!(geometry_msgs__msg__PoseStamped))
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__PoseStamped>(),
        8usize,
        concat!("Alignment of ", stringify!(geometry_msgs__msg__PoseStamped))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PoseStamped>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PoseStamped),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PoseStamped>())).pose as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PoseStamped),
            "::",
            stringify!(pose)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__PoseStamped__Sequence {
    pub data: *mut geometry_msgs__msg__PoseStamped,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__PoseStamped__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__PoseStamped__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__PoseStamped__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__PoseStamped__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__PoseStamped__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PoseStamped__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PoseStamped__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PoseStamped__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PoseStamped__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PoseStamped__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PoseStamped__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/PoseStamped message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__PoseStamped"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__PoseStamped__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseStamped__init(msg: *mut geometry_msgs__msg__PoseStamped)
        -> bool;
}
extern "C" {
    #[doc = " Finalize msg/PoseStamped message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseStamped__fini(msg: *mut geometry_msgs__msg__PoseStamped);
}
extern "C" {
    #[doc = " Create msg/PoseStamped message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__PoseStamped__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseStamped__create() -> *mut geometry_msgs__msg__PoseStamped;
}
extern "C" {
    #[doc = " Destroy msg/PoseStamped message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__PoseStamped__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseStamped__destroy(msg: *mut geometry_msgs__msg__PoseStamped);
}
extern "C" {
    #[doc = " Check for msg/PoseStamped message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseStamped__are_equal(
        lhs: *const geometry_msgs__msg__PoseStamped,
        rhs: *const geometry_msgs__msg__PoseStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/PoseStamped message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseStamped__copy(
        input: *const geometry_msgs__msg__PoseStamped,
        output: *mut geometry_msgs__msg__PoseStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/PoseStamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__PoseStamped__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseStamped__Sequence__init(
        array: *mut geometry_msgs__msg__PoseStamped__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/PoseStamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__PoseStamped__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseStamped__Sequence__fini(
        array: *mut geometry_msgs__msg__PoseStamped__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/PoseStamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__PoseStamped__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseStamped__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__PoseStamped__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/PoseStamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__PoseStamped__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseStamped__Sequence__destroy(
        array: *mut geometry_msgs__msg__PoseStamped__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/PoseStamped message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseStamped__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__PoseStamped__Sequence,
        rhs: *const geometry_msgs__msg__PoseStamped__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/PoseStamped messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseStamped__Sequence__copy(
        input: *const geometry_msgs__msg__PoseStamped__Sequence,
        output: *mut geometry_msgs__msg__PoseStamped__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__PoseStamped(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__PoseWithCovariance {
    pub pose: geometry_msgs__msg__Pose,
    pub covariance: [f64; 36usize],
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__PoseWithCovariance() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__PoseWithCovariance>(),
        344usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__PoseWithCovariance)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__PoseWithCovariance>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__PoseWithCovariance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PoseWithCovariance>())).pose as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PoseWithCovariance),
            "::",
            stringify!(pose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PoseWithCovariance>())).covariance
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PoseWithCovariance),
            "::",
            stringify!(covariance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__PoseWithCovariance__Sequence {
    pub data: *mut geometry_msgs__msg__PoseWithCovariance,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__PoseWithCovariance__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__PoseWithCovariance__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__PoseWithCovariance__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__PoseWithCovariance__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__PoseWithCovariance__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PoseWithCovariance__Sequence>())).data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PoseWithCovariance__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PoseWithCovariance__Sequence>())).size
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PoseWithCovariance__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PoseWithCovariance__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PoseWithCovariance__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/PoseWithCovariance message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__PoseWithCovariance"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__PoseWithCovariance__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseWithCovariance__init(
        msg: *mut geometry_msgs__msg__PoseWithCovariance,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/PoseWithCovariance message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseWithCovariance__fini(
        msg: *mut geometry_msgs__msg__PoseWithCovariance,
    );
}
extern "C" {
    #[doc = " Create msg/PoseWithCovariance message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__PoseWithCovariance__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseWithCovariance__create(
    ) -> *mut geometry_msgs__msg__PoseWithCovariance;
}
extern "C" {
    #[doc = " Destroy msg/PoseWithCovariance message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__PoseWithCovariance__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseWithCovariance__destroy(
        msg: *mut geometry_msgs__msg__PoseWithCovariance,
    );
}
extern "C" {
    #[doc = " Check for msg/PoseWithCovariance message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseWithCovariance__are_equal(
        lhs: *const geometry_msgs__msg__PoseWithCovariance,
        rhs: *const geometry_msgs__msg__PoseWithCovariance,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/PoseWithCovariance message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseWithCovariance__copy(
        input: *const geometry_msgs__msg__PoseWithCovariance,
        output: *mut geometry_msgs__msg__PoseWithCovariance,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/PoseWithCovariance messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__PoseWithCovariance__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseWithCovariance__Sequence__init(
        array: *mut geometry_msgs__msg__PoseWithCovariance__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/PoseWithCovariance messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__PoseWithCovariance__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseWithCovariance__Sequence__fini(
        array: *mut geometry_msgs__msg__PoseWithCovariance__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/PoseWithCovariance messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__PoseWithCovariance__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseWithCovariance__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__PoseWithCovariance__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/PoseWithCovariance messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__PoseWithCovariance__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseWithCovariance__Sequence__destroy(
        array: *mut geometry_msgs__msg__PoseWithCovariance__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/PoseWithCovariance message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseWithCovariance__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__PoseWithCovariance__Sequence,
        rhs: *const geometry_msgs__msg__PoseWithCovariance__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/PoseWithCovariance messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseWithCovariance__Sequence__copy(
        input: *const geometry_msgs__msg__PoseWithCovariance__Sequence,
        output: *mut geometry_msgs__msg__PoseWithCovariance__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__PoseWithCovariance(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__PoseWithCovarianceStamped {
    pub header: std_msgs__msg__Header,
    pub pose: geometry_msgs__msg__PoseWithCovariance,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__PoseWithCovarianceStamped() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__PoseWithCovarianceStamped>(),
        376usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__PoseWithCovarianceStamped)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__PoseWithCovarianceStamped>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__PoseWithCovarianceStamped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PoseWithCovarianceStamped>())).header
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PoseWithCovarianceStamped),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PoseWithCovarianceStamped>())).pose
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PoseWithCovarianceStamped),
            "::",
            stringify!(pose)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__PoseWithCovarianceStamped__Sequence {
    pub data: *mut geometry_msgs__msg__PoseWithCovarianceStamped,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__PoseWithCovarianceStamped__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__PoseWithCovarianceStamped__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__PoseWithCovarianceStamped__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__PoseWithCovarianceStamped__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__PoseWithCovarianceStamped__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PoseWithCovarianceStamped__Sequence>())).data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PoseWithCovarianceStamped__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PoseWithCovarianceStamped__Sequence>())).size
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PoseWithCovarianceStamped__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__PoseWithCovarianceStamped__Sequence>()))
                .capacity as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__PoseWithCovarianceStamped__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/PoseWithCovarianceStamped message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__PoseWithCovarianceStamped"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__PoseWithCovarianceStamped__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseWithCovarianceStamped__init(
        msg: *mut geometry_msgs__msg__PoseWithCovarianceStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/PoseWithCovarianceStamped message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseWithCovarianceStamped__fini(
        msg: *mut geometry_msgs__msg__PoseWithCovarianceStamped,
    );
}
extern "C" {
    #[doc = " Create msg/PoseWithCovarianceStamped message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__PoseWithCovarianceStamped__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseWithCovarianceStamped__create(
    ) -> *mut geometry_msgs__msg__PoseWithCovarianceStamped;
}
extern "C" {
    #[doc = " Destroy msg/PoseWithCovarianceStamped message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__PoseWithCovarianceStamped__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseWithCovarianceStamped__destroy(
        msg: *mut geometry_msgs__msg__PoseWithCovarianceStamped,
    );
}
extern "C" {
    #[doc = " Check for msg/PoseWithCovarianceStamped message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseWithCovarianceStamped__are_equal(
        lhs: *const geometry_msgs__msg__PoseWithCovarianceStamped,
        rhs: *const geometry_msgs__msg__PoseWithCovarianceStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/PoseWithCovarianceStamped message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseWithCovarianceStamped__copy(
        input: *const geometry_msgs__msg__PoseWithCovarianceStamped,
        output: *mut geometry_msgs__msg__PoseWithCovarianceStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/PoseWithCovarianceStamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__PoseWithCovarianceStamped__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseWithCovarianceStamped__Sequence__init(
        array: *mut geometry_msgs__msg__PoseWithCovarianceStamped__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/PoseWithCovarianceStamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__PoseWithCovarianceStamped__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseWithCovarianceStamped__Sequence__fini(
        array: *mut geometry_msgs__msg__PoseWithCovarianceStamped__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/PoseWithCovarianceStamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__PoseWithCovarianceStamped__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseWithCovarianceStamped__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__PoseWithCovarianceStamped__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/PoseWithCovarianceStamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__PoseWithCovarianceStamped__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseWithCovarianceStamped__Sequence__destroy(
        array: *mut geometry_msgs__msg__PoseWithCovarianceStamped__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/PoseWithCovarianceStamped message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseWithCovarianceStamped__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__PoseWithCovarianceStamped__Sequence,
        rhs: *const geometry_msgs__msg__PoseWithCovarianceStamped__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/PoseWithCovarianceStamped messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__PoseWithCovarianceStamped__Sequence__copy(
        input: *const geometry_msgs__msg__PoseWithCovarianceStamped__Sequence,
        output: *mut geometry_msgs__msg__PoseWithCovarianceStamped__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__PoseWithCovarianceStamped(
    ) -> *const rosidl_message_type_support_t;
}
extern "C" {
    #[doc = " Initialize msg/Quaternion message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__Quaternion"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__Quaternion__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Quaternion__init(msg: *mut geometry_msgs__msg__Quaternion) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Quaternion message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Quaternion__fini(msg: *mut geometry_msgs__msg__Quaternion);
}
extern "C" {
    #[doc = " Create msg/Quaternion message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__Quaternion__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Quaternion__create() -> *mut geometry_msgs__msg__Quaternion;
}
extern "C" {
    #[doc = " Destroy msg/Quaternion message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Quaternion__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Quaternion__destroy(msg: *mut geometry_msgs__msg__Quaternion);
}
extern "C" {
    #[doc = " Check for msg/Quaternion message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Quaternion__are_equal(
        lhs: *const geometry_msgs__msg__Quaternion,
        rhs: *const geometry_msgs__msg__Quaternion,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Quaternion message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Quaternion__copy(
        input: *const geometry_msgs__msg__Quaternion,
        output: *mut geometry_msgs__msg__Quaternion,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Quaternion messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__Quaternion__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Quaternion__Sequence__init(
        array: *mut geometry_msgs__msg__Quaternion__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Quaternion messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Quaternion__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Quaternion__Sequence__fini(
        array: *mut geometry_msgs__msg__Quaternion__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/Quaternion messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__Quaternion__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Quaternion__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__Quaternion__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Quaternion messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Quaternion__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Quaternion__Sequence__destroy(
        array: *mut geometry_msgs__msg__Quaternion__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Quaternion message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Quaternion__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__Quaternion__Sequence,
        rhs: *const geometry_msgs__msg__Quaternion__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Quaternion messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Quaternion__Sequence__copy(
        input: *const geometry_msgs__msg__Quaternion__Sequence,
        output: *mut geometry_msgs__msg__Quaternion__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__Quaternion(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__QuaternionStamped {
    pub header: std_msgs__msg__Header,
    pub quaternion: geometry_msgs__msg__Quaternion,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__QuaternionStamped() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__QuaternionStamped>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__QuaternionStamped)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__QuaternionStamped>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__QuaternionStamped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__QuaternionStamped>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__QuaternionStamped),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__QuaternionStamped>())).quaternion as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__QuaternionStamped),
            "::",
            stringify!(quaternion)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__QuaternionStamped__Sequence {
    pub data: *mut geometry_msgs__msg__QuaternionStamped,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__QuaternionStamped__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__QuaternionStamped__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__QuaternionStamped__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__QuaternionStamped__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__QuaternionStamped__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__QuaternionStamped__Sequence>())).data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__QuaternionStamped__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__QuaternionStamped__Sequence>())).size
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__QuaternionStamped__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__QuaternionStamped__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__QuaternionStamped__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/QuaternionStamped message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__QuaternionStamped"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__QuaternionStamped__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__QuaternionStamped__init(
        msg: *mut geometry_msgs__msg__QuaternionStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/QuaternionStamped message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__QuaternionStamped__fini(
        msg: *mut geometry_msgs__msg__QuaternionStamped,
    );
}
extern "C" {
    #[doc = " Create msg/QuaternionStamped message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__QuaternionStamped__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__QuaternionStamped__create(
    ) -> *mut geometry_msgs__msg__QuaternionStamped;
}
extern "C" {
    #[doc = " Destroy msg/QuaternionStamped message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__QuaternionStamped__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__QuaternionStamped__destroy(
        msg: *mut geometry_msgs__msg__QuaternionStamped,
    );
}
extern "C" {
    #[doc = " Check for msg/QuaternionStamped message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__QuaternionStamped__are_equal(
        lhs: *const geometry_msgs__msg__QuaternionStamped,
        rhs: *const geometry_msgs__msg__QuaternionStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/QuaternionStamped message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__QuaternionStamped__copy(
        input: *const geometry_msgs__msg__QuaternionStamped,
        output: *mut geometry_msgs__msg__QuaternionStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/QuaternionStamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__QuaternionStamped__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__QuaternionStamped__Sequence__init(
        array: *mut geometry_msgs__msg__QuaternionStamped__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/QuaternionStamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__QuaternionStamped__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__QuaternionStamped__Sequence__fini(
        array: *mut geometry_msgs__msg__QuaternionStamped__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/QuaternionStamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__QuaternionStamped__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__QuaternionStamped__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__QuaternionStamped__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/QuaternionStamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__QuaternionStamped__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__QuaternionStamped__Sequence__destroy(
        array: *mut geometry_msgs__msg__QuaternionStamped__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/QuaternionStamped message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__QuaternionStamped__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__QuaternionStamped__Sequence,
        rhs: *const geometry_msgs__msg__QuaternionStamped__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/QuaternionStamped messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__QuaternionStamped__Sequence__copy(
        input: *const geometry_msgs__msg__QuaternionStamped__Sequence,
        output: *mut geometry_msgs__msg__QuaternionStamped__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__QuaternionStamped(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Transform {
    pub translation: geometry_msgs__msg__Vector3,
    pub rotation: geometry_msgs__msg__Quaternion,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Transform() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Transform>(),
        56usize,
        concat!("Size of: ", stringify!(geometry_msgs__msg__Transform))
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Transform>(),
        8usize,
        concat!("Alignment of ", stringify!(geometry_msgs__msg__Transform))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Transform>())).translation as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Transform),
            "::",
            stringify!(translation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Transform>())).rotation as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Transform),
            "::",
            stringify!(rotation)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Transform__Sequence {
    pub data: *mut geometry_msgs__msg__Transform,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Transform__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Transform__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__Transform__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Transform__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__Transform__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Transform__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Transform__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Transform__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Transform__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Transform__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Transform__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Transform message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__Transform"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__Transform__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Transform__init(msg: *mut geometry_msgs__msg__Transform) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Transform message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Transform__fini(msg: *mut geometry_msgs__msg__Transform);
}
extern "C" {
    #[doc = " Create msg/Transform message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__Transform__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Transform__create() -> *mut geometry_msgs__msg__Transform;
}
extern "C" {
    #[doc = " Destroy msg/Transform message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Transform__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Transform__destroy(msg: *mut geometry_msgs__msg__Transform);
}
extern "C" {
    #[doc = " Check for msg/Transform message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Transform__are_equal(
        lhs: *const geometry_msgs__msg__Transform,
        rhs: *const geometry_msgs__msg__Transform,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Transform message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Transform__copy(
        input: *const geometry_msgs__msg__Transform,
        output: *mut geometry_msgs__msg__Transform,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Transform messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__Transform__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Transform__Sequence__init(
        array: *mut geometry_msgs__msg__Transform__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Transform messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Transform__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Transform__Sequence__fini(
        array: *mut geometry_msgs__msg__Transform__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/Transform messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__Transform__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Transform__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__Transform__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Transform messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Transform__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Transform__Sequence__destroy(
        array: *mut geometry_msgs__msg__Transform__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Transform message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Transform__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__Transform__Sequence,
        rhs: *const geometry_msgs__msg__Transform__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Transform messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Transform__Sequence__copy(
        input: *const geometry_msgs__msg__Transform__Sequence,
        output: *mut geometry_msgs__msg__Transform__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__Transform(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__TransformStamped {
    pub header: std_msgs__msg__Header,
    pub child_frame_id: rosidl_runtime_c__String,
    pub transform: geometry_msgs__msg__Transform,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__TransformStamped() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__TransformStamped>(),
        112usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__TransformStamped)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__TransformStamped>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__TransformStamped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__TransformStamped>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__TransformStamped),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__TransformStamped>())).child_frame_id
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__TransformStamped),
            "::",
            stringify!(child_frame_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__TransformStamped>())).transform as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__TransformStamped),
            "::",
            stringify!(transform)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__TransformStamped__Sequence {
    pub data: *mut geometry_msgs__msg__TransformStamped,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__TransformStamped__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__TransformStamped__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__TransformStamped__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__TransformStamped__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__TransformStamped__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__TransformStamped__Sequence>())).data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__TransformStamped__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__TransformStamped__Sequence>())).size
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__TransformStamped__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__TransformStamped__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__TransformStamped__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/TransformStamped message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__TransformStamped"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__TransformStamped__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TransformStamped__init(
        msg: *mut geometry_msgs__msg__TransformStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/TransformStamped message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TransformStamped__fini(
        msg: *mut geometry_msgs__msg__TransformStamped,
    );
}
extern "C" {
    #[doc = " Create msg/TransformStamped message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__TransformStamped__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TransformStamped__create(
    ) -> *mut geometry_msgs__msg__TransformStamped;
}
extern "C" {
    #[doc = " Destroy msg/TransformStamped message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__TransformStamped__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TransformStamped__destroy(
        msg: *mut geometry_msgs__msg__TransformStamped,
    );
}
extern "C" {
    #[doc = " Check for msg/TransformStamped message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TransformStamped__are_equal(
        lhs: *const geometry_msgs__msg__TransformStamped,
        rhs: *const geometry_msgs__msg__TransformStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/TransformStamped message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TransformStamped__copy(
        input: *const geometry_msgs__msg__TransformStamped,
        output: *mut geometry_msgs__msg__TransformStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/TransformStamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__TransformStamped__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TransformStamped__Sequence__init(
        array: *mut geometry_msgs__msg__TransformStamped__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/TransformStamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__TransformStamped__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TransformStamped__Sequence__fini(
        array: *mut geometry_msgs__msg__TransformStamped__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/TransformStamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__TransformStamped__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TransformStamped__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__TransformStamped__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/TransformStamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__TransformStamped__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TransformStamped__Sequence__destroy(
        array: *mut geometry_msgs__msg__TransformStamped__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/TransformStamped message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TransformStamped__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__TransformStamped__Sequence,
        rhs: *const geometry_msgs__msg__TransformStamped__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/TransformStamped messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TransformStamped__Sequence__copy(
        input: *const geometry_msgs__msg__TransformStamped__Sequence,
        output: *mut geometry_msgs__msg__TransformStamped__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__TransformStamped(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Twist {
    pub linear: geometry_msgs__msg__Vector3,
    pub angular: geometry_msgs__msg__Vector3,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Twist() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Twist>(),
        48usize,
        concat!("Size of: ", stringify!(geometry_msgs__msg__Twist))
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Twist>(),
        8usize,
        concat!("Alignment of ", stringify!(geometry_msgs__msg__Twist))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Twist>())).linear as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Twist),
            "::",
            stringify!(linear)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Twist>())).angular as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Twist),
            "::",
            stringify!(angular)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Twist__Sequence {
    pub data: *mut geometry_msgs__msg__Twist,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Twist__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Twist__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(geometry_msgs__msg__Twist__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Twist__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__Twist__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Twist__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Twist__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Twist__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Twist__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Twist__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Twist__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Twist message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__Twist"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__Twist__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Twist__init(msg: *mut geometry_msgs__msg__Twist) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Twist message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Twist__fini(msg: *mut geometry_msgs__msg__Twist);
}
extern "C" {
    #[doc = " Create msg/Twist message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__Twist__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Twist__create() -> *mut geometry_msgs__msg__Twist;
}
extern "C" {
    #[doc = " Destroy msg/Twist message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Twist__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Twist__destroy(msg: *mut geometry_msgs__msg__Twist);
}
extern "C" {
    #[doc = " Check for msg/Twist message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Twist__are_equal(
        lhs: *const geometry_msgs__msg__Twist,
        rhs: *const geometry_msgs__msg__Twist,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Twist message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Twist__copy(
        input: *const geometry_msgs__msg__Twist,
        output: *mut geometry_msgs__msg__Twist,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Twist messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__Twist__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Twist__Sequence__init(
        array: *mut geometry_msgs__msg__Twist__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Twist messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Twist__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Twist__Sequence__fini(
        array: *mut geometry_msgs__msg__Twist__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/Twist messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__Twist__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Twist__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__Twist__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Twist messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Twist__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Twist__Sequence__destroy(
        array: *mut geometry_msgs__msg__Twist__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Twist message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Twist__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__Twist__Sequence,
        rhs: *const geometry_msgs__msg__Twist__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Twist messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Twist__Sequence__copy(
        input: *const geometry_msgs__msg__Twist__Sequence,
        output: *mut geometry_msgs__msg__Twist__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__Twist(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__TwistStamped {
    pub header: std_msgs__msg__Header,
    pub twist: geometry_msgs__msg__Twist,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__TwistStamped() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__TwistStamped>(),
        80usize,
        concat!("Size of: ", stringify!(geometry_msgs__msg__TwistStamped))
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__TwistStamped>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__TwistStamped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__TwistStamped>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__TwistStamped),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__TwistStamped>())).twist as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__TwistStamped),
            "::",
            stringify!(twist)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__TwistStamped__Sequence {
    pub data: *mut geometry_msgs__msg__TwistStamped,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__TwistStamped__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__TwistStamped__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__TwistStamped__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__TwistStamped__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__TwistStamped__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__TwistStamped__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__TwistStamped__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__TwistStamped__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__TwistStamped__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__TwistStamped__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__TwistStamped__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/TwistStamped message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__TwistStamped"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__TwistStamped__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistStamped__init(
        msg: *mut geometry_msgs__msg__TwistStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/TwistStamped message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistStamped__fini(msg: *mut geometry_msgs__msg__TwistStamped);
}
extern "C" {
    #[doc = " Create msg/TwistStamped message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__TwistStamped__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistStamped__create() -> *mut geometry_msgs__msg__TwistStamped;
}
extern "C" {
    #[doc = " Destroy msg/TwistStamped message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__TwistStamped__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistStamped__destroy(msg: *mut geometry_msgs__msg__TwistStamped);
}
extern "C" {
    #[doc = " Check for msg/TwistStamped message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistStamped__are_equal(
        lhs: *const geometry_msgs__msg__TwistStamped,
        rhs: *const geometry_msgs__msg__TwistStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/TwistStamped message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistStamped__copy(
        input: *const geometry_msgs__msg__TwistStamped,
        output: *mut geometry_msgs__msg__TwistStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/TwistStamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__TwistStamped__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistStamped__Sequence__init(
        array: *mut geometry_msgs__msg__TwistStamped__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/TwistStamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__TwistStamped__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistStamped__Sequence__fini(
        array: *mut geometry_msgs__msg__TwistStamped__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/TwistStamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__TwistStamped__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistStamped__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__TwistStamped__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/TwistStamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__TwistStamped__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistStamped__Sequence__destroy(
        array: *mut geometry_msgs__msg__TwistStamped__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/TwistStamped message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistStamped__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__TwistStamped__Sequence,
        rhs: *const geometry_msgs__msg__TwistStamped__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/TwistStamped messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistStamped__Sequence__copy(
        input: *const geometry_msgs__msg__TwistStamped__Sequence,
        output: *mut geometry_msgs__msg__TwistStamped__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__TwistStamped(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__TwistWithCovariance {
    pub twist: geometry_msgs__msg__Twist,
    pub covariance: [f64; 36usize],
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__TwistWithCovariance() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__TwistWithCovariance>(),
        336usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__TwistWithCovariance)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__TwistWithCovariance>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__TwistWithCovariance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__TwistWithCovariance>())).twist as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__TwistWithCovariance),
            "::",
            stringify!(twist)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__TwistWithCovariance>())).covariance
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__TwistWithCovariance),
            "::",
            stringify!(covariance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__TwistWithCovariance__Sequence {
    pub data: *mut geometry_msgs__msg__TwistWithCovariance,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__TwistWithCovariance__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__TwistWithCovariance__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__TwistWithCovariance__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__TwistWithCovariance__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__TwistWithCovariance__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__TwistWithCovariance__Sequence>())).data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__TwistWithCovariance__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__TwistWithCovariance__Sequence>())).size
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__TwistWithCovariance__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__TwistWithCovariance__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__TwistWithCovariance__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/TwistWithCovariance message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__TwistWithCovariance"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__TwistWithCovariance__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistWithCovariance__init(
        msg: *mut geometry_msgs__msg__TwistWithCovariance,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/TwistWithCovariance message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistWithCovariance__fini(
        msg: *mut geometry_msgs__msg__TwistWithCovariance,
    );
}
extern "C" {
    #[doc = " Create msg/TwistWithCovariance message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__TwistWithCovariance__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistWithCovariance__create(
    ) -> *mut geometry_msgs__msg__TwistWithCovariance;
}
extern "C" {
    #[doc = " Destroy msg/TwistWithCovariance message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__TwistWithCovariance__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistWithCovariance__destroy(
        msg: *mut geometry_msgs__msg__TwistWithCovariance,
    );
}
extern "C" {
    #[doc = " Check for msg/TwistWithCovariance message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistWithCovariance__are_equal(
        lhs: *const geometry_msgs__msg__TwistWithCovariance,
        rhs: *const geometry_msgs__msg__TwistWithCovariance,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/TwistWithCovariance message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistWithCovariance__copy(
        input: *const geometry_msgs__msg__TwistWithCovariance,
        output: *mut geometry_msgs__msg__TwistWithCovariance,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/TwistWithCovariance messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__TwistWithCovariance__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistWithCovariance__Sequence__init(
        array: *mut geometry_msgs__msg__TwistWithCovariance__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/TwistWithCovariance messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__TwistWithCovariance__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistWithCovariance__Sequence__fini(
        array: *mut geometry_msgs__msg__TwistWithCovariance__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/TwistWithCovariance messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__TwistWithCovariance__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistWithCovariance__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__TwistWithCovariance__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/TwistWithCovariance messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__TwistWithCovariance__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistWithCovariance__Sequence__destroy(
        array: *mut geometry_msgs__msg__TwistWithCovariance__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/TwistWithCovariance message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistWithCovariance__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__TwistWithCovariance__Sequence,
        rhs: *const geometry_msgs__msg__TwistWithCovariance__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/TwistWithCovariance messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistWithCovariance__Sequence__copy(
        input: *const geometry_msgs__msg__TwistWithCovariance__Sequence,
        output: *mut geometry_msgs__msg__TwistWithCovariance__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__TwistWithCovariance(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__TwistWithCovarianceStamped {
    pub header: std_msgs__msg__Header,
    pub twist: geometry_msgs__msg__TwistWithCovariance,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__TwistWithCovarianceStamped() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__TwistWithCovarianceStamped>(),
        368usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__TwistWithCovarianceStamped)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__TwistWithCovarianceStamped>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__TwistWithCovarianceStamped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__TwistWithCovarianceStamped>())).header
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__TwistWithCovarianceStamped),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__TwistWithCovarianceStamped>())).twist
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__TwistWithCovarianceStamped),
            "::",
            stringify!(twist)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__TwistWithCovarianceStamped__Sequence {
    pub data: *mut geometry_msgs__msg__TwistWithCovarianceStamped,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__TwistWithCovarianceStamped__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__TwistWithCovarianceStamped__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__TwistWithCovarianceStamped__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__TwistWithCovarianceStamped__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__TwistWithCovarianceStamped__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__TwistWithCovarianceStamped__Sequence>()))
                .data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__TwistWithCovarianceStamped__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__TwistWithCovarianceStamped__Sequence>()))
                .size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__TwistWithCovarianceStamped__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__TwistWithCovarianceStamped__Sequence>()))
                .capacity as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__TwistWithCovarianceStamped__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/TwistWithCovarianceStamped message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__TwistWithCovarianceStamped"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__TwistWithCovarianceStamped__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistWithCovarianceStamped__init(
        msg: *mut geometry_msgs__msg__TwistWithCovarianceStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/TwistWithCovarianceStamped message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistWithCovarianceStamped__fini(
        msg: *mut geometry_msgs__msg__TwistWithCovarianceStamped,
    );
}
extern "C" {
    #[doc = " Create msg/TwistWithCovarianceStamped message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__TwistWithCovarianceStamped__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistWithCovarianceStamped__create(
    ) -> *mut geometry_msgs__msg__TwistWithCovarianceStamped;
}
extern "C" {
    #[doc = " Destroy msg/TwistWithCovarianceStamped message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__TwistWithCovarianceStamped__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistWithCovarianceStamped__destroy(
        msg: *mut geometry_msgs__msg__TwistWithCovarianceStamped,
    );
}
extern "C" {
    #[doc = " Check for msg/TwistWithCovarianceStamped message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistWithCovarianceStamped__are_equal(
        lhs: *const geometry_msgs__msg__TwistWithCovarianceStamped,
        rhs: *const geometry_msgs__msg__TwistWithCovarianceStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/TwistWithCovarianceStamped message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistWithCovarianceStamped__copy(
        input: *const geometry_msgs__msg__TwistWithCovarianceStamped,
        output: *mut geometry_msgs__msg__TwistWithCovarianceStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/TwistWithCovarianceStamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__TwistWithCovarianceStamped__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistWithCovarianceStamped__Sequence__init(
        array: *mut geometry_msgs__msg__TwistWithCovarianceStamped__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/TwistWithCovarianceStamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__TwistWithCovarianceStamped__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistWithCovarianceStamped__Sequence__fini(
        array: *mut geometry_msgs__msg__TwistWithCovarianceStamped__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/TwistWithCovarianceStamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__TwistWithCovarianceStamped__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistWithCovarianceStamped__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__TwistWithCovarianceStamped__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/TwistWithCovarianceStamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__TwistWithCovarianceStamped__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistWithCovarianceStamped__Sequence__destroy(
        array: *mut geometry_msgs__msg__TwistWithCovarianceStamped__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/TwistWithCovarianceStamped message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistWithCovarianceStamped__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__TwistWithCovarianceStamped__Sequence,
        rhs: *const geometry_msgs__msg__TwistWithCovarianceStamped__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/TwistWithCovarianceStamped messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__TwistWithCovarianceStamped__Sequence__copy(
        input: *const geometry_msgs__msg__TwistWithCovarianceStamped__Sequence,
        output: *mut geometry_msgs__msg__TwistWithCovarianceStamped__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__TwistWithCovarianceStamped(
    ) -> *const rosidl_message_type_support_t;
}
extern "C" {
    #[doc = " Initialize msg/Vector3 message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__Vector3"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__Vector3__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Vector3__init(msg: *mut geometry_msgs__msg__Vector3) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Vector3 message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Vector3__fini(msg: *mut geometry_msgs__msg__Vector3);
}
extern "C" {
    #[doc = " Create msg/Vector3 message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__Vector3__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Vector3__create() -> *mut geometry_msgs__msg__Vector3;
}
extern "C" {
    #[doc = " Destroy msg/Vector3 message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Vector3__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Vector3__destroy(msg: *mut geometry_msgs__msg__Vector3);
}
extern "C" {
    #[doc = " Check for msg/Vector3 message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Vector3__are_equal(
        lhs: *const geometry_msgs__msg__Vector3,
        rhs: *const geometry_msgs__msg__Vector3,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Vector3 message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Vector3__copy(
        input: *const geometry_msgs__msg__Vector3,
        output: *mut geometry_msgs__msg__Vector3,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Vector3 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__Vector3__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Vector3__Sequence__init(
        array: *mut geometry_msgs__msg__Vector3__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Vector3 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Vector3__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Vector3__Sequence__fini(
        array: *mut geometry_msgs__msg__Vector3__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/Vector3 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__Vector3__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Vector3__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__Vector3__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Vector3 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Vector3__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Vector3__Sequence__destroy(
        array: *mut geometry_msgs__msg__Vector3__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Vector3 message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Vector3__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__Vector3__Sequence,
        rhs: *const geometry_msgs__msg__Vector3__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Vector3 messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Vector3__Sequence__copy(
        input: *const geometry_msgs__msg__Vector3__Sequence,
        output: *mut geometry_msgs__msg__Vector3__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__Vector3(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Vector3Stamped {
    pub header: std_msgs__msg__Header,
    pub vector: geometry_msgs__msg__Vector3,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Vector3Stamped() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Vector3Stamped>(),
        56usize,
        concat!("Size of: ", stringify!(geometry_msgs__msg__Vector3Stamped))
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Vector3Stamped>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__Vector3Stamped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Vector3Stamped>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Vector3Stamped),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Vector3Stamped>())).vector as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Vector3Stamped),
            "::",
            stringify!(vector)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Vector3Stamped__Sequence {
    pub data: *mut geometry_msgs__msg__Vector3Stamped,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Vector3Stamped__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Vector3Stamped__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__Vector3Stamped__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Vector3Stamped__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__Vector3Stamped__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Vector3Stamped__Sequence>())).data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Vector3Stamped__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Vector3Stamped__Sequence>())).size
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Vector3Stamped__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Vector3Stamped__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Vector3Stamped__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Vector3Stamped message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__Vector3Stamped"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__Vector3Stamped__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Vector3Stamped__init(
        msg: *mut geometry_msgs__msg__Vector3Stamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Vector3Stamped message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Vector3Stamped__fini(msg: *mut geometry_msgs__msg__Vector3Stamped);
}
extern "C" {
    #[doc = " Create msg/Vector3Stamped message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__Vector3Stamped__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Vector3Stamped__create() -> *mut geometry_msgs__msg__Vector3Stamped;
}
extern "C" {
    #[doc = " Destroy msg/Vector3Stamped message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Vector3Stamped__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Vector3Stamped__destroy(
        msg: *mut geometry_msgs__msg__Vector3Stamped,
    );
}
extern "C" {
    #[doc = " Check for msg/Vector3Stamped message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Vector3Stamped__are_equal(
        lhs: *const geometry_msgs__msg__Vector3Stamped,
        rhs: *const geometry_msgs__msg__Vector3Stamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Vector3Stamped message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Vector3Stamped__copy(
        input: *const geometry_msgs__msg__Vector3Stamped,
        output: *mut geometry_msgs__msg__Vector3Stamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Vector3Stamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__Vector3Stamped__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Vector3Stamped__Sequence__init(
        array: *mut geometry_msgs__msg__Vector3Stamped__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Vector3Stamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Vector3Stamped__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Vector3Stamped__Sequence__fini(
        array: *mut geometry_msgs__msg__Vector3Stamped__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/Vector3Stamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__Vector3Stamped__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Vector3Stamped__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__Vector3Stamped__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Vector3Stamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Vector3Stamped__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Vector3Stamped__Sequence__destroy(
        array: *mut geometry_msgs__msg__Vector3Stamped__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Vector3Stamped message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Vector3Stamped__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__Vector3Stamped__Sequence,
        rhs: *const geometry_msgs__msg__Vector3Stamped__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Vector3Stamped messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Vector3Stamped__Sequence__copy(
        input: *const geometry_msgs__msg__Vector3Stamped__Sequence,
        output: *mut geometry_msgs__msg__Vector3Stamped__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__Vector3Stamped(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Wrench {
    pub force: geometry_msgs__msg__Vector3,
    pub torque: geometry_msgs__msg__Vector3,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Wrench() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Wrench>(),
        48usize,
        concat!("Size of: ", stringify!(geometry_msgs__msg__Wrench))
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Wrench>(),
        8usize,
        concat!("Alignment of ", stringify!(geometry_msgs__msg__Wrench))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Wrench>())).force as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Wrench),
            "::",
            stringify!(force)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Wrench>())).torque as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Wrench),
            "::",
            stringify!(torque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__Wrench__Sequence {
    pub data: *mut geometry_msgs__msg__Wrench,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__Wrench__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__Wrench__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__Wrench__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__Wrench__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__Wrench__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Wrench__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Wrench__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Wrench__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Wrench__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__Wrench__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__Wrench__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Wrench message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__Wrench"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__Wrench__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Wrench__init(msg: *mut geometry_msgs__msg__Wrench) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Wrench message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Wrench__fini(msg: *mut geometry_msgs__msg__Wrench);
}
extern "C" {
    #[doc = " Create msg/Wrench message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__Wrench__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Wrench__create() -> *mut geometry_msgs__msg__Wrench;
}
extern "C" {
    #[doc = " Destroy msg/Wrench message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Wrench__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Wrench__destroy(msg: *mut geometry_msgs__msg__Wrench);
}
extern "C" {
    #[doc = " Check for msg/Wrench message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Wrench__are_equal(
        lhs: *const geometry_msgs__msg__Wrench,
        rhs: *const geometry_msgs__msg__Wrench,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Wrench message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Wrench__copy(
        input: *const geometry_msgs__msg__Wrench,
        output: *mut geometry_msgs__msg__Wrench,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Wrench messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__Wrench__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Wrench__Sequence__init(
        array: *mut geometry_msgs__msg__Wrench__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Wrench messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Wrench__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Wrench__Sequence__fini(
        array: *mut geometry_msgs__msg__Wrench__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/Wrench messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__Wrench__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Wrench__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__Wrench__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Wrench messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__Wrench__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Wrench__Sequence__destroy(
        array: *mut geometry_msgs__msg__Wrench__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Wrench message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Wrench__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__Wrench__Sequence,
        rhs: *const geometry_msgs__msg__Wrench__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Wrench messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__Wrench__Sequence__copy(
        input: *const geometry_msgs__msg__Wrench__Sequence,
        output: *mut geometry_msgs__msg__Wrench__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__Wrench(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__WrenchStamped {
    pub header: std_msgs__msg__Header,
    pub wrench: geometry_msgs__msg__Wrench,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__WrenchStamped() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__WrenchStamped>(),
        80usize,
        concat!("Size of: ", stringify!(geometry_msgs__msg__WrenchStamped))
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__WrenchStamped>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__WrenchStamped)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__WrenchStamped>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__WrenchStamped),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__WrenchStamped>())).wrench as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__WrenchStamped),
            "::",
            stringify!(wrench)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct geometry_msgs__msg__WrenchStamped__Sequence {
    pub data: *mut geometry_msgs__msg__WrenchStamped,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_geometry_msgs__msg__WrenchStamped__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<geometry_msgs__msg__WrenchStamped__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(geometry_msgs__msg__WrenchStamped__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<geometry_msgs__msg__WrenchStamped__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(geometry_msgs__msg__WrenchStamped__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__WrenchStamped__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__WrenchStamped__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__WrenchStamped__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__WrenchStamped__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<geometry_msgs__msg__WrenchStamped__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(geometry_msgs__msg__WrenchStamped__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/WrenchStamped message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* geometry_msgs__msg__WrenchStamped"]
    #[doc = "* )) before or use"]
    #[doc = "* geometry_msgs__msg__WrenchStamped__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__WrenchStamped__init(
        msg: *mut geometry_msgs__msg__WrenchStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/WrenchStamped message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__WrenchStamped__fini(msg: *mut geometry_msgs__msg__WrenchStamped);
}
extern "C" {
    #[doc = " Create msg/WrenchStamped message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* geometry_msgs__msg__WrenchStamped__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__WrenchStamped__create() -> *mut geometry_msgs__msg__WrenchStamped;
}
extern "C" {
    #[doc = " Destroy msg/WrenchStamped message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__WrenchStamped__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__WrenchStamped__destroy(msg: *mut geometry_msgs__msg__WrenchStamped);
}
extern "C" {
    #[doc = " Check for msg/WrenchStamped message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__WrenchStamped__are_equal(
        lhs: *const geometry_msgs__msg__WrenchStamped,
        rhs: *const geometry_msgs__msg__WrenchStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/WrenchStamped message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__WrenchStamped__copy(
        input: *const geometry_msgs__msg__WrenchStamped,
        output: *mut geometry_msgs__msg__WrenchStamped,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/WrenchStamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* geometry_msgs__msg__WrenchStamped__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__WrenchStamped__Sequence__init(
        array: *mut geometry_msgs__msg__WrenchStamped__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/WrenchStamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__WrenchStamped__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__WrenchStamped__Sequence__fini(
        array: *mut geometry_msgs__msg__WrenchStamped__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/WrenchStamped messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* geometry_msgs__msg__WrenchStamped__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__WrenchStamped__Sequence__create(
        size: size_t,
    ) -> *mut geometry_msgs__msg__WrenchStamped__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/WrenchStamped messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* geometry_msgs__msg__WrenchStamped__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__WrenchStamped__Sequence__destroy(
        array: *mut geometry_msgs__msg__WrenchStamped__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/WrenchStamped message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__WrenchStamped__Sequence__are_equal(
        lhs: *const geometry_msgs__msg__WrenchStamped__Sequence,
        rhs: *const geometry_msgs__msg__WrenchStamped__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/WrenchStamped messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn geometry_msgs__msg__WrenchStamped__Sequence__copy(
        input: *const geometry_msgs__msg__WrenchStamped__Sequence,
        output: *mut geometry_msgs__msg__WrenchStamped__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__geometry_msgs__msg__WrenchStamped(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unique_identifier_msgs__msg__UUID {
    pub uuid: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_unique_identifier_msgs__msg__UUID() {
    assert_eq!(
        ::std::mem::size_of::<unique_identifier_msgs__msg__UUID>(),
        16usize,
        concat!("Size of: ", stringify!(unique_identifier_msgs__msg__UUID))
    );
    assert_eq!(
        ::std::mem::align_of::<unique_identifier_msgs__msg__UUID>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(unique_identifier_msgs__msg__UUID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<unique_identifier_msgs__msg__UUID>())).uuid as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unique_identifier_msgs__msg__UUID),
            "::",
            stringify!(uuid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unique_identifier_msgs__msg__UUID__Sequence {
    pub data: *mut unique_identifier_msgs__msg__UUID,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_unique_identifier_msgs__msg__UUID__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<unique_identifier_msgs__msg__UUID__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(unique_identifier_msgs__msg__UUID__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<unique_identifier_msgs__msg__UUID__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(unique_identifier_msgs__msg__UUID__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<unique_identifier_msgs__msg__UUID__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unique_identifier_msgs__msg__UUID__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<unique_identifier_msgs__msg__UUID__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(unique_identifier_msgs__msg__UUID__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<unique_identifier_msgs__msg__UUID__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(unique_identifier_msgs__msg__UUID__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/UUID message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* unique_identifier_msgs__msg__UUID"]
    #[doc = "* )) before or use"]
    #[doc = "* unique_identifier_msgs__msg__UUID__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn unique_identifier_msgs__msg__UUID__init(
        msg: *mut unique_identifier_msgs__msg__UUID,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/UUID message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn unique_identifier_msgs__msg__UUID__fini(msg: *mut unique_identifier_msgs__msg__UUID);
}
extern "C" {
    #[doc = " Create msg/UUID message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* unique_identifier_msgs__msg__UUID__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn unique_identifier_msgs__msg__UUID__create() -> *mut unique_identifier_msgs__msg__UUID;
}
extern "C" {
    #[doc = " Destroy msg/UUID message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* unique_identifier_msgs__msg__UUID__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn unique_identifier_msgs__msg__UUID__destroy(msg: *mut unique_identifier_msgs__msg__UUID);
}
extern "C" {
    #[doc = " Check for msg/UUID message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn unique_identifier_msgs__msg__UUID__are_equal(
        lhs: *const unique_identifier_msgs__msg__UUID,
        rhs: *const unique_identifier_msgs__msg__UUID,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/UUID message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn unique_identifier_msgs__msg__UUID__copy(
        input: *const unique_identifier_msgs__msg__UUID,
        output: *mut unique_identifier_msgs__msg__UUID,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/UUID messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* unique_identifier_msgs__msg__UUID__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn unique_identifier_msgs__msg__UUID__Sequence__init(
        array: *mut unique_identifier_msgs__msg__UUID__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/UUID messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* unique_identifier_msgs__msg__UUID__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn unique_identifier_msgs__msg__UUID__Sequence__fini(
        array: *mut unique_identifier_msgs__msg__UUID__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/UUID messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* unique_identifier_msgs__msg__UUID__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn unique_identifier_msgs__msg__UUID__Sequence__create(
        size: size_t,
    ) -> *mut unique_identifier_msgs__msg__UUID__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/UUID messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* unique_identifier_msgs__msg__UUID__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn unique_identifier_msgs__msg__UUID__Sequence__destroy(
        array: *mut unique_identifier_msgs__msg__UUID__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/UUID message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn unique_identifier_msgs__msg__UUID__Sequence__are_equal(
        lhs: *const unique_identifier_msgs__msg__UUID__Sequence,
        rhs: *const unique_identifier_msgs__msg__UUID__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/UUID messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn unique_identifier_msgs__msg__UUID__Sequence__copy(
        input: *const unique_identifier_msgs__msg__UUID__Sequence,
        output: *mut unique_identifier_msgs__msg__UUID__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__unique_identifier_msgs__msg__UUID(
    ) -> *const rosidl_message_type_support_t;
}
pub const sensor_msgs__msg__BatteryState__POWER_SUPPLY_STATUS_UNKNOWN: ::std::os::raw::c_uint = 0;
#[doc = " Constant 'POWER_SUPPLY_STATUS_UNKNOWN'."]
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__BatteryState__POWER_SUPPLY_STATUS_CHARGING: ::std::os::raw::c_uint = 1;
#[doc = " Constant 'POWER_SUPPLY_STATUS_CHARGING'."]
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__BatteryState__POWER_SUPPLY_STATUS_DISCHARGING: ::std::os::raw::c_uint =
    2;
#[doc = " Constant 'POWER_SUPPLY_STATUS_DISCHARGING'."]
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__BatteryState__POWER_SUPPLY_STATUS_NOT_CHARGING: ::std::os::raw::c_uint =
    3;
#[doc = " Constant 'POWER_SUPPLY_STATUS_NOT_CHARGING'."]
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__BatteryState__POWER_SUPPLY_STATUS_FULL: ::std::os::raw::c_uint = 4;
#[doc = " Constant 'POWER_SUPPLY_STATUS_FULL'."]
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__BatteryState__POWER_SUPPLY_HEALTH_UNKNOWN: ::std::os::raw::c_uint = 0;
#[doc = " Constant 'POWER_SUPPLY_HEALTH_UNKNOWN'."]
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__BatteryState__POWER_SUPPLY_HEALTH_GOOD: ::std::os::raw::c_uint = 1;
#[doc = " Constant 'POWER_SUPPLY_HEALTH_GOOD'."]
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__BatteryState__POWER_SUPPLY_HEALTH_OVERHEAT: ::std::os::raw::c_uint = 2;
#[doc = " Constant 'POWER_SUPPLY_HEALTH_OVERHEAT'."]
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__BatteryState__POWER_SUPPLY_HEALTH_DEAD: ::std::os::raw::c_uint = 3;
#[doc = " Constant 'POWER_SUPPLY_HEALTH_DEAD'."]
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__BatteryState__POWER_SUPPLY_HEALTH_OVERVOLTAGE: ::std::os::raw::c_uint =
    4;
#[doc = " Constant 'POWER_SUPPLY_HEALTH_OVERVOLTAGE'."]
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__BatteryState__POWER_SUPPLY_HEALTH_UNSPEC_FAILURE:
    ::std::os::raw::c_uint = 5;
#[doc = " Constant 'POWER_SUPPLY_HEALTH_UNSPEC_FAILURE'."]
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__BatteryState__POWER_SUPPLY_HEALTH_COLD: ::std::os::raw::c_uint = 6;
#[doc = " Constant 'POWER_SUPPLY_HEALTH_COLD'."]
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__BatteryState__POWER_SUPPLY_HEALTH_WATCHDOG_TIMER_EXPIRE:
    ::std::os::raw::c_uint = 7;
#[doc = " Constant 'POWER_SUPPLY_HEALTH_WATCHDOG_TIMER_EXPIRE'."]
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__BatteryState__POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE:
    ::std::os::raw::c_uint = 8;
#[doc = " Constant 'POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE'."]
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__BatteryState__POWER_SUPPLY_TECHNOLOGY_UNKNOWN: ::std::os::raw::c_uint =
    0;
#[doc = " Constant 'POWER_SUPPLY_TECHNOLOGY_UNKNOWN'."]
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__BatteryState__POWER_SUPPLY_TECHNOLOGY_NIMH: ::std::os::raw::c_uint = 1;
#[doc = " Constant 'POWER_SUPPLY_TECHNOLOGY_NIMH'."]
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__BatteryState__POWER_SUPPLY_TECHNOLOGY_LION: ::std::os::raw::c_uint = 2;
#[doc = " Constant 'POWER_SUPPLY_TECHNOLOGY_LION'."]
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__BatteryState__POWER_SUPPLY_TECHNOLOGY_LIPO: ::std::os::raw::c_uint = 3;
#[doc = " Constant 'POWER_SUPPLY_TECHNOLOGY_LIPO'."]
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__BatteryState__POWER_SUPPLY_TECHNOLOGY_LIFE: ::std::os::raw::c_uint = 4;
#[doc = " Constant 'POWER_SUPPLY_TECHNOLOGY_LIFE'."]
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__BatteryState__POWER_SUPPLY_TECHNOLOGY_NICD: ::std::os::raw::c_uint = 5;
#[doc = " Constant 'POWER_SUPPLY_TECHNOLOGY_NICD'."]
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__BatteryState__POWER_SUPPLY_TECHNOLOGY_LIMN: ::std::os::raw::c_uint = 6;
#[doc = " Constant 'POWER_SUPPLY_TECHNOLOGY_LIMN'."]
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__BatteryState {
    pub header: std_msgs__msg__Header,
    pub voltage: f32,
    pub temperature: f32,
    pub current: f32,
    pub charge: f32,
    pub capacity: f32,
    pub design_capacity: f32,
    pub percentage: f32,
    pub power_supply_status: u8,
    pub power_supply_health: u8,
    pub power_supply_technology: u8,
    pub present: bool,
    pub cell_voltage: rosidl_runtime_c__float__Sequence,
    pub cell_temperature: rosidl_runtime_c__float__Sequence,
    pub location: rosidl_runtime_c__String,
    pub serial_number: rosidl_runtime_c__String,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__BatteryState() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__BatteryState>(),
        160usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__BatteryState))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__BatteryState>(),
        8usize,
        concat!("Alignment of ", stringify!(sensor_msgs__msg__BatteryState))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__BatteryState>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__BatteryState),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__BatteryState>())).voltage as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__BatteryState),
            "::",
            stringify!(voltage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__BatteryState>())).temperature as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__BatteryState),
            "::",
            stringify!(temperature)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__BatteryState>())).current as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__BatteryState),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__BatteryState>())).charge as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__BatteryState),
            "::",
            stringify!(charge)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__BatteryState>())).capacity as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__BatteryState),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__BatteryState>())).design_capacity as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__BatteryState),
            "::",
            stringify!(design_capacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__BatteryState>())).percentage as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__BatteryState),
            "::",
            stringify!(percentage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__BatteryState>())).power_supply_status
                as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__BatteryState),
            "::",
            stringify!(power_supply_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__BatteryState>())).power_supply_health
                as *const _ as usize
        },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__BatteryState),
            "::",
            stringify!(power_supply_health)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__BatteryState>())).power_supply_technology
                as *const _ as usize
        },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__BatteryState),
            "::",
            stringify!(power_supply_technology)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__BatteryState>())).present as *const _ as usize
        },
        63usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__BatteryState),
            "::",
            stringify!(present)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__BatteryState>())).cell_voltage as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__BatteryState),
            "::",
            stringify!(cell_voltage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__BatteryState>())).cell_temperature as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__BatteryState),
            "::",
            stringify!(cell_temperature)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__BatteryState>())).location as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__BatteryState),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__BatteryState>())).serial_number as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__BatteryState),
            "::",
            stringify!(serial_number)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__BatteryState__Sequence {
    pub data: *mut sensor_msgs__msg__BatteryState,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__BatteryState__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__BatteryState__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(sensor_msgs__msg__BatteryState__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__BatteryState__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__BatteryState__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__BatteryState__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__BatteryState__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__BatteryState__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__BatteryState__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__BatteryState__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__BatteryState__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/BatteryState message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__BatteryState"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__BatteryState__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__BatteryState__init(msg: *mut sensor_msgs__msg__BatteryState) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/BatteryState message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__BatteryState__fini(msg: *mut sensor_msgs__msg__BatteryState);
}
extern "C" {
    #[doc = " Create msg/BatteryState message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__BatteryState__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__BatteryState__create() -> *mut sensor_msgs__msg__BatteryState;
}
extern "C" {
    #[doc = " Destroy msg/BatteryState message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__BatteryState__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__BatteryState__destroy(msg: *mut sensor_msgs__msg__BatteryState);
}
extern "C" {
    #[doc = " Check for msg/BatteryState message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__BatteryState__are_equal(
        lhs: *const sensor_msgs__msg__BatteryState,
        rhs: *const sensor_msgs__msg__BatteryState,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/BatteryState message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__BatteryState__copy(
        input: *const sensor_msgs__msg__BatteryState,
        output: *mut sensor_msgs__msg__BatteryState,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/BatteryState messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__BatteryState__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__BatteryState__Sequence__init(
        array: *mut sensor_msgs__msg__BatteryState__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/BatteryState messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__BatteryState__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__BatteryState__Sequence__fini(
        array: *mut sensor_msgs__msg__BatteryState__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/BatteryState messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__BatteryState__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__BatteryState__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__BatteryState__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/BatteryState messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__BatteryState__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__BatteryState__Sequence__destroy(
        array: *mut sensor_msgs__msg__BatteryState__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/BatteryState message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__BatteryState__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__BatteryState__Sequence,
        rhs: *const sensor_msgs__msg__BatteryState__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/BatteryState messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__BatteryState__Sequence__copy(
        input: *const sensor_msgs__msg__BatteryState__Sequence,
        output: *mut sensor_msgs__msg__BatteryState__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__BatteryState(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__RegionOfInterest {
    pub x_offset: u32,
    pub y_offset: u32,
    pub height: u32,
    pub width: u32,
    pub do_rectify: bool,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__RegionOfInterest() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__RegionOfInterest>(),
        20usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__RegionOfInterest))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__RegionOfInterest>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__RegionOfInterest)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__RegionOfInterest>())).x_offset as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__RegionOfInterest),
            "::",
            stringify!(x_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__RegionOfInterest>())).y_offset as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__RegionOfInterest),
            "::",
            stringify!(y_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__RegionOfInterest>())).height as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__RegionOfInterest),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__RegionOfInterest>())).width as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__RegionOfInterest),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__RegionOfInterest>())).do_rectify as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__RegionOfInterest),
            "::",
            stringify!(do_rectify)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__RegionOfInterest__Sequence {
    pub data: *mut sensor_msgs__msg__RegionOfInterest,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__RegionOfInterest__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__RegionOfInterest__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(sensor_msgs__msg__RegionOfInterest__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__RegionOfInterest__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__RegionOfInterest__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__RegionOfInterest__Sequence>())).data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__RegionOfInterest__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__RegionOfInterest__Sequence>())).size
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__RegionOfInterest__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__RegionOfInterest__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__RegionOfInterest__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__CameraInfo {
    pub header: std_msgs__msg__Header,
    pub height: u32,
    pub width: u32,
    pub distortion_model: rosidl_runtime_c__String,
    pub d: rosidl_runtime_c__double__Sequence,
    pub k: [f64; 9usize],
    pub r: [f64; 9usize],
    pub p: [f64; 12usize],
    pub binning_x: u32,
    pub binning_y: u32,
    pub roi: sensor_msgs__msg__RegionOfInterest,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__CameraInfo() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__CameraInfo>(),
        360usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__CameraInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__CameraInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(sensor_msgs__msg__CameraInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__CameraInfo>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__CameraInfo),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__CameraInfo>())).height as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__CameraInfo),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__CameraInfo>())).width as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__CameraInfo),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__CameraInfo>())).distortion_model as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__CameraInfo),
            "::",
            stringify!(distortion_model)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sensor_msgs__msg__CameraInfo>())).d as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__CameraInfo),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sensor_msgs__msg__CameraInfo>())).k as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__CameraInfo),
            "::",
            stringify!(k)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sensor_msgs__msg__CameraInfo>())).r as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__CameraInfo),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sensor_msgs__msg__CameraInfo>())).p as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__CameraInfo),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__CameraInfo>())).binning_x as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__CameraInfo),
            "::",
            stringify!(binning_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__CameraInfo>())).binning_y as *const _ as usize
        },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__CameraInfo),
            "::",
            stringify!(binning_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__CameraInfo>())).roi as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__CameraInfo),
            "::",
            stringify!(roi)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__CameraInfo__Sequence {
    pub data: *mut sensor_msgs__msg__CameraInfo,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__CameraInfo__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__CameraInfo__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(sensor_msgs__msg__CameraInfo__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__CameraInfo__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__CameraInfo__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__CameraInfo__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__CameraInfo__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__CameraInfo__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__CameraInfo__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__CameraInfo__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__CameraInfo__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/CameraInfo message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__CameraInfo"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__CameraInfo__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__CameraInfo__init(msg: *mut sensor_msgs__msg__CameraInfo) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/CameraInfo message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__CameraInfo__fini(msg: *mut sensor_msgs__msg__CameraInfo);
}
extern "C" {
    #[doc = " Create msg/CameraInfo message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__CameraInfo__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__CameraInfo__create() -> *mut sensor_msgs__msg__CameraInfo;
}
extern "C" {
    #[doc = " Destroy msg/CameraInfo message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__CameraInfo__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__CameraInfo__destroy(msg: *mut sensor_msgs__msg__CameraInfo);
}
extern "C" {
    #[doc = " Check for msg/CameraInfo message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__CameraInfo__are_equal(
        lhs: *const sensor_msgs__msg__CameraInfo,
        rhs: *const sensor_msgs__msg__CameraInfo,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/CameraInfo message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__CameraInfo__copy(
        input: *const sensor_msgs__msg__CameraInfo,
        output: *mut sensor_msgs__msg__CameraInfo,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/CameraInfo messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__CameraInfo__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__CameraInfo__Sequence__init(
        array: *mut sensor_msgs__msg__CameraInfo__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/CameraInfo messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__CameraInfo__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__CameraInfo__Sequence__fini(
        array: *mut sensor_msgs__msg__CameraInfo__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/CameraInfo messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__CameraInfo__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__CameraInfo__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__CameraInfo__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/CameraInfo messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__CameraInfo__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__CameraInfo__Sequence__destroy(
        array: *mut sensor_msgs__msg__CameraInfo__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/CameraInfo message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__CameraInfo__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__CameraInfo__Sequence,
        rhs: *const sensor_msgs__msg__CameraInfo__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/CameraInfo messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__CameraInfo__Sequence__copy(
        input: *const sensor_msgs__msg__CameraInfo__Sequence,
        output: *mut sensor_msgs__msg__CameraInfo__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__CameraInfo(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__ChannelFloat32 {
    pub name: rosidl_runtime_c__String,
    pub values: rosidl_runtime_c__float__Sequence,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__ChannelFloat32() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__ChannelFloat32>(),
        48usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__ChannelFloat32))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__ChannelFloat32>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__ChannelFloat32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__ChannelFloat32>())).name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__ChannelFloat32),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__ChannelFloat32>())).values as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__ChannelFloat32),
            "::",
            stringify!(values)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__ChannelFloat32__Sequence {
    pub data: *mut sensor_msgs__msg__ChannelFloat32,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__ChannelFloat32__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__ChannelFloat32__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(sensor_msgs__msg__ChannelFloat32__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__ChannelFloat32__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__ChannelFloat32__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__ChannelFloat32__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__ChannelFloat32__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__ChannelFloat32__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__ChannelFloat32__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__ChannelFloat32__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__ChannelFloat32__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/ChannelFloat32 message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__ChannelFloat32"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__ChannelFloat32__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__ChannelFloat32__init(
        msg: *mut sensor_msgs__msg__ChannelFloat32,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/ChannelFloat32 message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__ChannelFloat32__fini(msg: *mut sensor_msgs__msg__ChannelFloat32);
}
extern "C" {
    #[doc = " Create msg/ChannelFloat32 message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__ChannelFloat32__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__ChannelFloat32__create() -> *mut sensor_msgs__msg__ChannelFloat32;
}
extern "C" {
    #[doc = " Destroy msg/ChannelFloat32 message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__ChannelFloat32__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__ChannelFloat32__destroy(msg: *mut sensor_msgs__msg__ChannelFloat32);
}
extern "C" {
    #[doc = " Check for msg/ChannelFloat32 message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__ChannelFloat32__are_equal(
        lhs: *const sensor_msgs__msg__ChannelFloat32,
        rhs: *const sensor_msgs__msg__ChannelFloat32,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/ChannelFloat32 message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__ChannelFloat32__copy(
        input: *const sensor_msgs__msg__ChannelFloat32,
        output: *mut sensor_msgs__msg__ChannelFloat32,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/ChannelFloat32 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__ChannelFloat32__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__ChannelFloat32__Sequence__init(
        array: *mut sensor_msgs__msg__ChannelFloat32__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/ChannelFloat32 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__ChannelFloat32__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__ChannelFloat32__Sequence__fini(
        array: *mut sensor_msgs__msg__ChannelFloat32__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/ChannelFloat32 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__ChannelFloat32__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__ChannelFloat32__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__ChannelFloat32__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/ChannelFloat32 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__ChannelFloat32__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__ChannelFloat32__Sequence__destroy(
        array: *mut sensor_msgs__msg__ChannelFloat32__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/ChannelFloat32 message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__ChannelFloat32__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__ChannelFloat32__Sequence,
        rhs: *const sensor_msgs__msg__ChannelFloat32__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/ChannelFloat32 messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__ChannelFloat32__Sequence__copy(
        input: *const sensor_msgs__msg__ChannelFloat32__Sequence,
        output: *mut sensor_msgs__msg__ChannelFloat32__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__ChannelFloat32(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__CompressedImage {
    pub header: std_msgs__msg__Header,
    pub format: rosidl_runtime_c__String,
    pub data: rosidl_runtime_c__uint8__Sequence,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__CompressedImage() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__CompressedImage>(),
        80usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__CompressedImage))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__CompressedImage>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__CompressedImage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__CompressedImage>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__CompressedImage),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__CompressedImage>())).format as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__CompressedImage),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__CompressedImage>())).data as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__CompressedImage),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__CompressedImage__Sequence {
    pub data: *mut sensor_msgs__msg__CompressedImage,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__CompressedImage__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__CompressedImage__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(sensor_msgs__msg__CompressedImage__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__CompressedImage__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__CompressedImage__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__CompressedImage__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__CompressedImage__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__CompressedImage__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__CompressedImage__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__CompressedImage__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__CompressedImage__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/CompressedImage message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__CompressedImage"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__CompressedImage__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__CompressedImage__init(
        msg: *mut sensor_msgs__msg__CompressedImage,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/CompressedImage message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__CompressedImage__fini(msg: *mut sensor_msgs__msg__CompressedImage);
}
extern "C" {
    #[doc = " Create msg/CompressedImage message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__CompressedImage__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__CompressedImage__create() -> *mut sensor_msgs__msg__CompressedImage;
}
extern "C" {
    #[doc = " Destroy msg/CompressedImage message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__CompressedImage__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__CompressedImage__destroy(msg: *mut sensor_msgs__msg__CompressedImage);
}
extern "C" {
    #[doc = " Check for msg/CompressedImage message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__CompressedImage__are_equal(
        lhs: *const sensor_msgs__msg__CompressedImage,
        rhs: *const sensor_msgs__msg__CompressedImage,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/CompressedImage message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__CompressedImage__copy(
        input: *const sensor_msgs__msg__CompressedImage,
        output: *mut sensor_msgs__msg__CompressedImage,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/CompressedImage messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__CompressedImage__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__CompressedImage__Sequence__init(
        array: *mut sensor_msgs__msg__CompressedImage__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/CompressedImage messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__CompressedImage__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__CompressedImage__Sequence__fini(
        array: *mut sensor_msgs__msg__CompressedImage__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/CompressedImage messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__CompressedImage__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__CompressedImage__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__CompressedImage__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/CompressedImage messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__CompressedImage__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__CompressedImage__Sequence__destroy(
        array: *mut sensor_msgs__msg__CompressedImage__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/CompressedImage message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__CompressedImage__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__CompressedImage__Sequence,
        rhs: *const sensor_msgs__msg__CompressedImage__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/CompressedImage messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__CompressedImage__Sequence__copy(
        input: *const sensor_msgs__msg__CompressedImage__Sequence,
        output: *mut sensor_msgs__msg__CompressedImage__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__CompressedImage(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__FluidPressure {
    pub header: std_msgs__msg__Header,
    pub fluid_pressure: f64,
    pub variance: f64,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__FluidPressure() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__FluidPressure>(),
        48usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__FluidPressure))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__FluidPressure>(),
        8usize,
        concat!("Alignment of ", stringify!(sensor_msgs__msg__FluidPressure))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__FluidPressure>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__FluidPressure),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__FluidPressure>())).fluid_pressure as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__FluidPressure),
            "::",
            stringify!(fluid_pressure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__FluidPressure>())).variance as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__FluidPressure),
            "::",
            stringify!(variance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__FluidPressure__Sequence {
    pub data: *mut sensor_msgs__msg__FluidPressure,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__FluidPressure__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__FluidPressure__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(sensor_msgs__msg__FluidPressure__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__FluidPressure__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__FluidPressure__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__FluidPressure__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__FluidPressure__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__FluidPressure__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__FluidPressure__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__FluidPressure__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__FluidPressure__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/FluidPressure message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__FluidPressure"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__FluidPressure__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__FluidPressure__init(msg: *mut sensor_msgs__msg__FluidPressure)
        -> bool;
}
extern "C" {
    #[doc = " Finalize msg/FluidPressure message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__FluidPressure__fini(msg: *mut sensor_msgs__msg__FluidPressure);
}
extern "C" {
    #[doc = " Create msg/FluidPressure message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__FluidPressure__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__FluidPressure__create() -> *mut sensor_msgs__msg__FluidPressure;
}
extern "C" {
    #[doc = " Destroy msg/FluidPressure message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__FluidPressure__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__FluidPressure__destroy(msg: *mut sensor_msgs__msg__FluidPressure);
}
extern "C" {
    #[doc = " Check for msg/FluidPressure message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__FluidPressure__are_equal(
        lhs: *const sensor_msgs__msg__FluidPressure,
        rhs: *const sensor_msgs__msg__FluidPressure,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/FluidPressure message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__FluidPressure__copy(
        input: *const sensor_msgs__msg__FluidPressure,
        output: *mut sensor_msgs__msg__FluidPressure,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/FluidPressure messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__FluidPressure__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__FluidPressure__Sequence__init(
        array: *mut sensor_msgs__msg__FluidPressure__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/FluidPressure messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__FluidPressure__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__FluidPressure__Sequence__fini(
        array: *mut sensor_msgs__msg__FluidPressure__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/FluidPressure messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__FluidPressure__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__FluidPressure__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__FluidPressure__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/FluidPressure messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__FluidPressure__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__FluidPressure__Sequence__destroy(
        array: *mut sensor_msgs__msg__FluidPressure__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/FluidPressure message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__FluidPressure__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__FluidPressure__Sequence,
        rhs: *const sensor_msgs__msg__FluidPressure__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/FluidPressure messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__FluidPressure__Sequence__copy(
        input: *const sensor_msgs__msg__FluidPressure__Sequence,
        output: *mut sensor_msgs__msg__FluidPressure__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__FluidPressure(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__Illuminance {
    pub header: std_msgs__msg__Header,
    pub illuminance: f64,
    pub variance: f64,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__Illuminance() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__Illuminance>(),
        48usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__Illuminance))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__Illuminance>(),
        8usize,
        concat!("Alignment of ", stringify!(sensor_msgs__msg__Illuminance))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Illuminance>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Illuminance),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Illuminance>())).illuminance as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Illuminance),
            "::",
            stringify!(illuminance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Illuminance>())).variance as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Illuminance),
            "::",
            stringify!(variance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__Illuminance__Sequence {
    pub data: *mut sensor_msgs__msg__Illuminance,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__Illuminance__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__Illuminance__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(sensor_msgs__msg__Illuminance__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__Illuminance__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__Illuminance__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Illuminance__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Illuminance__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Illuminance__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Illuminance__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Illuminance__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Illuminance__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Illuminance message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__Illuminance"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__Illuminance__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Illuminance__init(msg: *mut sensor_msgs__msg__Illuminance) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Illuminance message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Illuminance__fini(msg: *mut sensor_msgs__msg__Illuminance);
}
extern "C" {
    #[doc = " Create msg/Illuminance message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__Illuminance__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Illuminance__create() -> *mut sensor_msgs__msg__Illuminance;
}
extern "C" {
    #[doc = " Destroy msg/Illuminance message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__Illuminance__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Illuminance__destroy(msg: *mut sensor_msgs__msg__Illuminance);
}
extern "C" {
    #[doc = " Check for msg/Illuminance message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Illuminance__are_equal(
        lhs: *const sensor_msgs__msg__Illuminance,
        rhs: *const sensor_msgs__msg__Illuminance,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Illuminance message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Illuminance__copy(
        input: *const sensor_msgs__msg__Illuminance,
        output: *mut sensor_msgs__msg__Illuminance,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Illuminance messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__Illuminance__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Illuminance__Sequence__init(
        array: *mut sensor_msgs__msg__Illuminance__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Illuminance messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__Illuminance__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Illuminance__Sequence__fini(
        array: *mut sensor_msgs__msg__Illuminance__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/Illuminance messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__Illuminance__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Illuminance__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__Illuminance__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Illuminance messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__Illuminance__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Illuminance__Sequence__destroy(
        array: *mut sensor_msgs__msg__Illuminance__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Illuminance message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Illuminance__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__Illuminance__Sequence,
        rhs: *const sensor_msgs__msg__Illuminance__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Illuminance messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Illuminance__Sequence__copy(
        input: *const sensor_msgs__msg__Illuminance__Sequence,
        output: *mut sensor_msgs__msg__Illuminance__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__Illuminance(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__Image {
    pub header: std_msgs__msg__Header,
    pub height: u32,
    pub width: u32,
    pub encoding: rosidl_runtime_c__String,
    pub is_bigendian: u8,
    pub step: u32,
    pub data: rosidl_runtime_c__uint8__Sequence,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__Image() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__Image>(),
        96usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__Image))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__Image>(),
        8usize,
        concat!("Alignment of ", stringify!(sensor_msgs__msg__Image))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sensor_msgs__msg__Image>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Image),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sensor_msgs__msg__Image>())).height as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Image),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sensor_msgs__msg__Image>())).width as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Image),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Image>())).encoding as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Image),
            "::",
            stringify!(encoding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Image>())).is_bigendian as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Image),
            "::",
            stringify!(is_bigendian)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sensor_msgs__msg__Image>())).step as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Image),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sensor_msgs__msg__Image>())).data as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Image),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__Image__Sequence {
    pub data: *mut sensor_msgs__msg__Image,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__Image__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__Image__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__Image__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__Image__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__Image__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Image__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Image__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Image__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Image__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Image__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Image__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Image message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__Image"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__Image__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Image__init(msg: *mut sensor_msgs__msg__Image) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Image message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Image__fini(msg: *mut sensor_msgs__msg__Image);
}
extern "C" {
    #[doc = " Create msg/Image message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__Image__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Image__create() -> *mut sensor_msgs__msg__Image;
}
extern "C" {
    #[doc = " Destroy msg/Image message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__Image__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Image__destroy(msg: *mut sensor_msgs__msg__Image);
}
extern "C" {
    #[doc = " Check for msg/Image message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Image__are_equal(
        lhs: *const sensor_msgs__msg__Image,
        rhs: *const sensor_msgs__msg__Image,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Image message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Image__copy(
        input: *const sensor_msgs__msg__Image,
        output: *mut sensor_msgs__msg__Image,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Image messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__Image__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Image__Sequence__init(
        array: *mut sensor_msgs__msg__Image__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Image messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__Image__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Image__Sequence__fini(array: *mut sensor_msgs__msg__Image__Sequence);
}
extern "C" {
    #[doc = " Create array of msg/Image messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__Image__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Image__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__Image__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Image messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__Image__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Image__Sequence__destroy(
        array: *mut sensor_msgs__msg__Image__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Image message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Image__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__Image__Sequence,
        rhs: *const sensor_msgs__msg__Image__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Image messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Image__Sequence__copy(
        input: *const sensor_msgs__msg__Image__Sequence,
        output: *mut sensor_msgs__msg__Image__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__Image(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__Imu {
    pub header: std_msgs__msg__Header,
    pub orientation: geometry_msgs__msg__Quaternion,
    pub orientation_covariance: [f64; 9usize],
    pub angular_velocity: geometry_msgs__msg__Vector3,
    pub angular_velocity_covariance: [f64; 9usize],
    pub linear_acceleration: geometry_msgs__msg__Vector3,
    pub linear_acceleration_covariance: [f64; 9usize],
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__Imu() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__Imu>(),
        328usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__Imu))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__Imu>(),
        8usize,
        concat!("Alignment of ", stringify!(sensor_msgs__msg__Imu))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sensor_msgs__msg__Imu>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Imu),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Imu>())).orientation as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Imu),
            "::",
            stringify!(orientation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Imu>())).orientation_covariance as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Imu),
            "::",
            stringify!(orientation_covariance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Imu>())).angular_velocity as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Imu),
            "::",
            stringify!(angular_velocity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Imu>())).angular_velocity_covariance
                as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Imu),
            "::",
            stringify!(angular_velocity_covariance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Imu>())).linear_acceleration as *const _
                as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Imu),
            "::",
            stringify!(linear_acceleration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Imu>())).linear_acceleration_covariance
                as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Imu),
            "::",
            stringify!(linear_acceleration_covariance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__Imu__Sequence {
    pub data: *mut sensor_msgs__msg__Imu,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__Imu__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__Imu__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__Imu__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__Imu__Sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(sensor_msgs__msg__Imu__Sequence))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Imu__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Imu__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Imu__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Imu__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Imu__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Imu__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Imu message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__Imu"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__Imu__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Imu__init(msg: *mut sensor_msgs__msg__Imu) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Imu message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Imu__fini(msg: *mut sensor_msgs__msg__Imu);
}
extern "C" {
    #[doc = " Create msg/Imu message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__Imu__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Imu__create() -> *mut sensor_msgs__msg__Imu;
}
extern "C" {
    #[doc = " Destroy msg/Imu message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__Imu__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Imu__destroy(msg: *mut sensor_msgs__msg__Imu);
}
extern "C" {
    #[doc = " Check for msg/Imu message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Imu__are_equal(
        lhs: *const sensor_msgs__msg__Imu,
        rhs: *const sensor_msgs__msg__Imu,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Imu message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Imu__copy(
        input: *const sensor_msgs__msg__Imu,
        output: *mut sensor_msgs__msg__Imu,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Imu messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__Imu__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Imu__Sequence__init(
        array: *mut sensor_msgs__msg__Imu__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Imu messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__Imu__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Imu__Sequence__fini(array: *mut sensor_msgs__msg__Imu__Sequence);
}
extern "C" {
    #[doc = " Create array of msg/Imu messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__Imu__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Imu__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__Imu__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Imu messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__Imu__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Imu__Sequence__destroy(array: *mut sensor_msgs__msg__Imu__Sequence);
}
extern "C" {
    #[doc = " Check for msg/Imu message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Imu__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__Imu__Sequence,
        rhs: *const sensor_msgs__msg__Imu__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Imu messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Imu__Sequence__copy(
        input: *const sensor_msgs__msg__Imu__Sequence,
        output: *mut sensor_msgs__msg__Imu__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__Imu(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__JointState {
    pub header: std_msgs__msg__Header,
    pub name: rosidl_runtime_c__String__Sequence,
    pub position: rosidl_runtime_c__double__Sequence,
    pub velocity: rosidl_runtime_c__double__Sequence,
    pub effort: rosidl_runtime_c__double__Sequence,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__JointState() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__JointState>(),
        128usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__JointState))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__JointState>(),
        8usize,
        concat!("Alignment of ", stringify!(sensor_msgs__msg__JointState))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__JointState>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__JointState),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__JointState>())).name as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__JointState),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__JointState>())).position as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__JointState),
            "::",
            stringify!(position)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__JointState>())).velocity as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__JointState),
            "::",
            stringify!(velocity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__JointState>())).effort as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__JointState),
            "::",
            stringify!(effort)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__JointState__Sequence {
    pub data: *mut sensor_msgs__msg__JointState,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__JointState__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__JointState__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(sensor_msgs__msg__JointState__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__JointState__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__JointState__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__JointState__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__JointState__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__JointState__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__JointState__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__JointState__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__JointState__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/JointState message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__JointState"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__JointState__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JointState__init(msg: *mut sensor_msgs__msg__JointState) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/JointState message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JointState__fini(msg: *mut sensor_msgs__msg__JointState);
}
extern "C" {
    #[doc = " Create msg/JointState message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__JointState__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JointState__create() -> *mut sensor_msgs__msg__JointState;
}
extern "C" {
    #[doc = " Destroy msg/JointState message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__JointState__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JointState__destroy(msg: *mut sensor_msgs__msg__JointState);
}
extern "C" {
    #[doc = " Check for msg/JointState message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JointState__are_equal(
        lhs: *const sensor_msgs__msg__JointState,
        rhs: *const sensor_msgs__msg__JointState,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/JointState message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JointState__copy(
        input: *const sensor_msgs__msg__JointState,
        output: *mut sensor_msgs__msg__JointState,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/JointState messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__JointState__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JointState__Sequence__init(
        array: *mut sensor_msgs__msg__JointState__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/JointState messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__JointState__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JointState__Sequence__fini(
        array: *mut sensor_msgs__msg__JointState__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/JointState messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__JointState__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JointState__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__JointState__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/JointState messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__JointState__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JointState__Sequence__destroy(
        array: *mut sensor_msgs__msg__JointState__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/JointState message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JointState__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__JointState__Sequence,
        rhs: *const sensor_msgs__msg__JointState__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/JointState messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JointState__Sequence__copy(
        input: *const sensor_msgs__msg__JointState__Sequence,
        output: *mut sensor_msgs__msg__JointState__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__JointState(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__Joy {
    pub header: std_msgs__msg__Header,
    pub axes: rosidl_runtime_c__float__Sequence,
    pub buttons: rosidl_runtime_c__int32__Sequence,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__Joy() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__Joy>(),
        80usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__Joy))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__Joy>(),
        8usize,
        concat!("Alignment of ", stringify!(sensor_msgs__msg__Joy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sensor_msgs__msg__Joy>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Joy),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sensor_msgs__msg__Joy>())).axes as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Joy),
            "::",
            stringify!(axes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sensor_msgs__msg__Joy>())).buttons as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Joy),
            "::",
            stringify!(buttons)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__Joy__Sequence {
    pub data: *mut sensor_msgs__msg__Joy,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__Joy__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__Joy__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__Joy__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__Joy__Sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(sensor_msgs__msg__Joy__Sequence))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Joy__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Joy__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Joy__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Joy__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Joy__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Joy__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Joy message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__Joy"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__Joy__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Joy__init(msg: *mut sensor_msgs__msg__Joy) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Joy message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Joy__fini(msg: *mut sensor_msgs__msg__Joy);
}
extern "C" {
    #[doc = " Create msg/Joy message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__Joy__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Joy__create() -> *mut sensor_msgs__msg__Joy;
}
extern "C" {
    #[doc = " Destroy msg/Joy message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__Joy__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Joy__destroy(msg: *mut sensor_msgs__msg__Joy);
}
extern "C" {
    #[doc = " Check for msg/Joy message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Joy__are_equal(
        lhs: *const sensor_msgs__msg__Joy,
        rhs: *const sensor_msgs__msg__Joy,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Joy message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Joy__copy(
        input: *const sensor_msgs__msg__Joy,
        output: *mut sensor_msgs__msg__Joy,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Joy messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__Joy__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Joy__Sequence__init(
        array: *mut sensor_msgs__msg__Joy__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Joy messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__Joy__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Joy__Sequence__fini(array: *mut sensor_msgs__msg__Joy__Sequence);
}
extern "C" {
    #[doc = " Create array of msg/Joy messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__Joy__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Joy__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__Joy__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Joy messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__Joy__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Joy__Sequence__destroy(array: *mut sensor_msgs__msg__Joy__Sequence);
}
extern "C" {
    #[doc = " Check for msg/Joy message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Joy__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__Joy__Sequence,
        rhs: *const sensor_msgs__msg__Joy__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Joy messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Joy__Sequence__copy(
        input: *const sensor_msgs__msg__Joy__Sequence,
        output: *mut sensor_msgs__msg__Joy__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__Joy(
    ) -> *const rosidl_message_type_support_t;
}
pub const sensor_msgs__msg__JoyFeedback__TYPE_LED: ::std::os::raw::c_uint = 0;
#[doc = " Constant 'TYPE_LED'."]
pub type _bindgen_ty_22 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__JoyFeedback__TYPE_RUMBLE: ::std::os::raw::c_uint = 1;
#[doc = " Constant 'TYPE_RUMBLE'."]
pub type _bindgen_ty_23 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__JoyFeedback__TYPE_BUZZER: ::std::os::raw::c_uint = 2;
#[doc = " Constant 'TYPE_BUZZER'."]
pub type _bindgen_ty_24 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__JoyFeedback {
    pub type_: u8,
    pub id: u8,
    pub intensity: f32,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__JoyFeedback() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__JoyFeedback>(),
        8usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__JoyFeedback))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__JoyFeedback>(),
        4usize,
        concat!("Alignment of ", stringify!(sensor_msgs__msg__JoyFeedback))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__JoyFeedback>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__JoyFeedback),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__JoyFeedback>())).id as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__JoyFeedback),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__JoyFeedback>())).intensity as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__JoyFeedback),
            "::",
            stringify!(intensity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__JoyFeedback__Sequence {
    pub data: *mut sensor_msgs__msg__JoyFeedback,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__JoyFeedback__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__JoyFeedback__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(sensor_msgs__msg__JoyFeedback__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__JoyFeedback__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__JoyFeedback__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__JoyFeedback__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__JoyFeedback__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__JoyFeedback__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__JoyFeedback__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__JoyFeedback__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__JoyFeedback__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/JoyFeedback message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__JoyFeedback"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__JoyFeedback__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JoyFeedback__init(msg: *mut sensor_msgs__msg__JoyFeedback) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/JoyFeedback message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JoyFeedback__fini(msg: *mut sensor_msgs__msg__JoyFeedback);
}
extern "C" {
    #[doc = " Create msg/JoyFeedback message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__JoyFeedback__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JoyFeedback__create() -> *mut sensor_msgs__msg__JoyFeedback;
}
extern "C" {
    #[doc = " Destroy msg/JoyFeedback message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__JoyFeedback__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JoyFeedback__destroy(msg: *mut sensor_msgs__msg__JoyFeedback);
}
extern "C" {
    #[doc = " Check for msg/JoyFeedback message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JoyFeedback__are_equal(
        lhs: *const sensor_msgs__msg__JoyFeedback,
        rhs: *const sensor_msgs__msg__JoyFeedback,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/JoyFeedback message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JoyFeedback__copy(
        input: *const sensor_msgs__msg__JoyFeedback,
        output: *mut sensor_msgs__msg__JoyFeedback,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/JoyFeedback messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__JoyFeedback__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JoyFeedback__Sequence__init(
        array: *mut sensor_msgs__msg__JoyFeedback__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/JoyFeedback messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__JoyFeedback__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JoyFeedback__Sequence__fini(
        array: *mut sensor_msgs__msg__JoyFeedback__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/JoyFeedback messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__JoyFeedback__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JoyFeedback__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__JoyFeedback__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/JoyFeedback messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__JoyFeedback__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JoyFeedback__Sequence__destroy(
        array: *mut sensor_msgs__msg__JoyFeedback__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/JoyFeedback message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JoyFeedback__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__JoyFeedback__Sequence,
        rhs: *const sensor_msgs__msg__JoyFeedback__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/JoyFeedback messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JoyFeedback__Sequence__copy(
        input: *const sensor_msgs__msg__JoyFeedback__Sequence,
        output: *mut sensor_msgs__msg__JoyFeedback__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__JoyFeedback(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__JoyFeedbackArray {
    pub array: sensor_msgs__msg__JoyFeedback__Sequence,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__JoyFeedbackArray() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__JoyFeedbackArray>(),
        24usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__JoyFeedbackArray))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__JoyFeedbackArray>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__JoyFeedbackArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__JoyFeedbackArray>())).array as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__JoyFeedbackArray),
            "::",
            stringify!(array)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__JoyFeedbackArray__Sequence {
    pub data: *mut sensor_msgs__msg__JoyFeedbackArray,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__JoyFeedbackArray__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__JoyFeedbackArray__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(sensor_msgs__msg__JoyFeedbackArray__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__JoyFeedbackArray__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__JoyFeedbackArray__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__JoyFeedbackArray__Sequence>())).data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__JoyFeedbackArray__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__JoyFeedbackArray__Sequence>())).size
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__JoyFeedbackArray__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__JoyFeedbackArray__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__JoyFeedbackArray__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/JoyFeedbackArray message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__JoyFeedbackArray"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__JoyFeedbackArray__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JoyFeedbackArray__init(
        msg: *mut sensor_msgs__msg__JoyFeedbackArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/JoyFeedbackArray message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JoyFeedbackArray__fini(msg: *mut sensor_msgs__msg__JoyFeedbackArray);
}
extern "C" {
    #[doc = " Create msg/JoyFeedbackArray message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__JoyFeedbackArray__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JoyFeedbackArray__create() -> *mut sensor_msgs__msg__JoyFeedbackArray;
}
extern "C" {
    #[doc = " Destroy msg/JoyFeedbackArray message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__JoyFeedbackArray__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JoyFeedbackArray__destroy(
        msg: *mut sensor_msgs__msg__JoyFeedbackArray,
    );
}
extern "C" {
    #[doc = " Check for msg/JoyFeedbackArray message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JoyFeedbackArray__are_equal(
        lhs: *const sensor_msgs__msg__JoyFeedbackArray,
        rhs: *const sensor_msgs__msg__JoyFeedbackArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/JoyFeedbackArray message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JoyFeedbackArray__copy(
        input: *const sensor_msgs__msg__JoyFeedbackArray,
        output: *mut sensor_msgs__msg__JoyFeedbackArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/JoyFeedbackArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__JoyFeedbackArray__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JoyFeedbackArray__Sequence__init(
        array: *mut sensor_msgs__msg__JoyFeedbackArray__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/JoyFeedbackArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__JoyFeedbackArray__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JoyFeedbackArray__Sequence__fini(
        array: *mut sensor_msgs__msg__JoyFeedbackArray__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/JoyFeedbackArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__JoyFeedbackArray__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JoyFeedbackArray__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__JoyFeedbackArray__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/JoyFeedbackArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__JoyFeedbackArray__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JoyFeedbackArray__Sequence__destroy(
        array: *mut sensor_msgs__msg__JoyFeedbackArray__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/JoyFeedbackArray message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JoyFeedbackArray__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__JoyFeedbackArray__Sequence,
        rhs: *const sensor_msgs__msg__JoyFeedbackArray__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/JoyFeedbackArray messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__JoyFeedbackArray__Sequence__copy(
        input: *const sensor_msgs__msg__JoyFeedbackArray__Sequence,
        output: *mut sensor_msgs__msg__JoyFeedbackArray__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__JoyFeedbackArray(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__LaserEcho {
    pub echoes: rosidl_runtime_c__float__Sequence,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__LaserEcho() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__LaserEcho>(),
        24usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__LaserEcho))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__LaserEcho>(),
        8usize,
        concat!("Alignment of ", stringify!(sensor_msgs__msg__LaserEcho))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__LaserEcho>())).echoes as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__LaserEcho),
            "::",
            stringify!(echoes)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__LaserEcho__Sequence {
    pub data: *mut sensor_msgs__msg__LaserEcho,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__LaserEcho__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__LaserEcho__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(sensor_msgs__msg__LaserEcho__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__LaserEcho__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__LaserEcho__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__LaserEcho__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__LaserEcho__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__LaserEcho__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__LaserEcho__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__LaserEcho__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__LaserEcho__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/LaserEcho message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__LaserEcho"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__LaserEcho__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__LaserEcho__init(msg: *mut sensor_msgs__msg__LaserEcho) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/LaserEcho message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__LaserEcho__fini(msg: *mut sensor_msgs__msg__LaserEcho);
}
extern "C" {
    #[doc = " Create msg/LaserEcho message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__LaserEcho__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__LaserEcho__create() -> *mut sensor_msgs__msg__LaserEcho;
}
extern "C" {
    #[doc = " Destroy msg/LaserEcho message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__LaserEcho__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__LaserEcho__destroy(msg: *mut sensor_msgs__msg__LaserEcho);
}
extern "C" {
    #[doc = " Check for msg/LaserEcho message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__LaserEcho__are_equal(
        lhs: *const sensor_msgs__msg__LaserEcho,
        rhs: *const sensor_msgs__msg__LaserEcho,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/LaserEcho message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__LaserEcho__copy(
        input: *const sensor_msgs__msg__LaserEcho,
        output: *mut sensor_msgs__msg__LaserEcho,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/LaserEcho messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__LaserEcho__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__LaserEcho__Sequence__init(
        array: *mut sensor_msgs__msg__LaserEcho__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/LaserEcho messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__LaserEcho__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__LaserEcho__Sequence__fini(
        array: *mut sensor_msgs__msg__LaserEcho__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/LaserEcho messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__LaserEcho__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__LaserEcho__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__LaserEcho__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/LaserEcho messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__LaserEcho__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__LaserEcho__Sequence__destroy(
        array: *mut sensor_msgs__msg__LaserEcho__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/LaserEcho message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__LaserEcho__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__LaserEcho__Sequence,
        rhs: *const sensor_msgs__msg__LaserEcho__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/LaserEcho messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__LaserEcho__Sequence__copy(
        input: *const sensor_msgs__msg__LaserEcho__Sequence,
        output: *mut sensor_msgs__msg__LaserEcho__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__LaserEcho(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__LaserScan {
    pub header: std_msgs__msg__Header,
    pub angle_min: f32,
    pub angle_max: f32,
    pub angle_increment: f32,
    pub time_increment: f32,
    pub scan_time: f32,
    pub range_min: f32,
    pub range_max: f32,
    pub ranges: rosidl_runtime_c__float__Sequence,
    pub intensities: rosidl_runtime_c__float__Sequence,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__LaserScan() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__LaserScan>(),
        112usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__LaserScan))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__LaserScan>(),
        8usize,
        concat!("Alignment of ", stringify!(sensor_msgs__msg__LaserScan))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__LaserScan>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__LaserScan),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__LaserScan>())).angle_min as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__LaserScan),
            "::",
            stringify!(angle_min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__LaserScan>())).angle_max as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__LaserScan),
            "::",
            stringify!(angle_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__LaserScan>())).angle_increment as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__LaserScan),
            "::",
            stringify!(angle_increment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__LaserScan>())).time_increment as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__LaserScan),
            "::",
            stringify!(time_increment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__LaserScan>())).scan_time as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__LaserScan),
            "::",
            stringify!(scan_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__LaserScan>())).range_min as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__LaserScan),
            "::",
            stringify!(range_min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__LaserScan>())).range_max as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__LaserScan),
            "::",
            stringify!(range_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__LaserScan>())).ranges as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__LaserScan),
            "::",
            stringify!(ranges)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__LaserScan>())).intensities as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__LaserScan),
            "::",
            stringify!(intensities)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__LaserScan__Sequence {
    pub data: *mut sensor_msgs__msg__LaserScan,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__LaserScan__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__LaserScan__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(sensor_msgs__msg__LaserScan__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__LaserScan__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__LaserScan__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__LaserScan__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__LaserScan__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__LaserScan__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__LaserScan__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__LaserScan__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__LaserScan__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/LaserScan message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__LaserScan"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__LaserScan__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__LaserScan__init(msg: *mut sensor_msgs__msg__LaserScan) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/LaserScan message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__LaserScan__fini(msg: *mut sensor_msgs__msg__LaserScan);
}
extern "C" {
    #[doc = " Create msg/LaserScan message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__LaserScan__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__LaserScan__create() -> *mut sensor_msgs__msg__LaserScan;
}
extern "C" {
    #[doc = " Destroy msg/LaserScan message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__LaserScan__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__LaserScan__destroy(msg: *mut sensor_msgs__msg__LaserScan);
}
extern "C" {
    #[doc = " Check for msg/LaserScan message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__LaserScan__are_equal(
        lhs: *const sensor_msgs__msg__LaserScan,
        rhs: *const sensor_msgs__msg__LaserScan,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/LaserScan message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__LaserScan__copy(
        input: *const sensor_msgs__msg__LaserScan,
        output: *mut sensor_msgs__msg__LaserScan,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/LaserScan messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__LaserScan__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__LaserScan__Sequence__init(
        array: *mut sensor_msgs__msg__LaserScan__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/LaserScan messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__LaserScan__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__LaserScan__Sequence__fini(
        array: *mut sensor_msgs__msg__LaserScan__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/LaserScan messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__LaserScan__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__LaserScan__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__LaserScan__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/LaserScan messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__LaserScan__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__LaserScan__Sequence__destroy(
        array: *mut sensor_msgs__msg__LaserScan__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/LaserScan message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__LaserScan__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__LaserScan__Sequence,
        rhs: *const sensor_msgs__msg__LaserScan__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/LaserScan messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__LaserScan__Sequence__copy(
        input: *const sensor_msgs__msg__LaserScan__Sequence,
        output: *mut sensor_msgs__msg__LaserScan__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__LaserScan(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__MagneticField {
    pub header: std_msgs__msg__Header,
    pub magnetic_field: geometry_msgs__msg__Vector3,
    pub magnetic_field_covariance: [f64; 9usize],
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__MagneticField() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__MagneticField>(),
        128usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__MagneticField))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__MagneticField>(),
        8usize,
        concat!("Alignment of ", stringify!(sensor_msgs__msg__MagneticField))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MagneticField>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MagneticField),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MagneticField>())).magnetic_field as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MagneticField),
            "::",
            stringify!(magnetic_field)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MagneticField>())).magnetic_field_covariance
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MagneticField),
            "::",
            stringify!(magnetic_field_covariance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__MagneticField__Sequence {
    pub data: *mut sensor_msgs__msg__MagneticField,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__MagneticField__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__MagneticField__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(sensor_msgs__msg__MagneticField__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__MagneticField__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__MagneticField__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MagneticField__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MagneticField__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MagneticField__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MagneticField__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MagneticField__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MagneticField__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/MagneticField message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__MagneticField"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__MagneticField__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MagneticField__init(msg: *mut sensor_msgs__msg__MagneticField)
        -> bool;
}
extern "C" {
    #[doc = " Finalize msg/MagneticField message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MagneticField__fini(msg: *mut sensor_msgs__msg__MagneticField);
}
extern "C" {
    #[doc = " Create msg/MagneticField message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__MagneticField__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MagneticField__create() -> *mut sensor_msgs__msg__MagneticField;
}
extern "C" {
    #[doc = " Destroy msg/MagneticField message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__MagneticField__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MagneticField__destroy(msg: *mut sensor_msgs__msg__MagneticField);
}
extern "C" {
    #[doc = " Check for msg/MagneticField message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MagneticField__are_equal(
        lhs: *const sensor_msgs__msg__MagneticField,
        rhs: *const sensor_msgs__msg__MagneticField,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/MagneticField message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MagneticField__copy(
        input: *const sensor_msgs__msg__MagneticField,
        output: *mut sensor_msgs__msg__MagneticField,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/MagneticField messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__MagneticField__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MagneticField__Sequence__init(
        array: *mut sensor_msgs__msg__MagneticField__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/MagneticField messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__MagneticField__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MagneticField__Sequence__fini(
        array: *mut sensor_msgs__msg__MagneticField__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/MagneticField messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__MagneticField__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MagneticField__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__MagneticField__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/MagneticField messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__MagneticField__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MagneticField__Sequence__destroy(
        array: *mut sensor_msgs__msg__MagneticField__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/MagneticField message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MagneticField__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__MagneticField__Sequence,
        rhs: *const sensor_msgs__msg__MagneticField__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/MagneticField messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MagneticField__Sequence__copy(
        input: *const sensor_msgs__msg__MagneticField__Sequence,
        output: *mut sensor_msgs__msg__MagneticField__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__MagneticField(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__MultiDOFJointState {
    pub header: std_msgs__msg__Header,
    pub joint_names: rosidl_runtime_c__String__Sequence,
    pub transforms: geometry_msgs__msg__Transform__Sequence,
    pub twist: geometry_msgs__msg__Twist__Sequence,
    pub wrench: geometry_msgs__msg__Wrench__Sequence,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__MultiDOFJointState() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__MultiDOFJointState>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(sensor_msgs__msg__MultiDOFJointState)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__MultiDOFJointState>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__MultiDOFJointState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MultiDOFJointState>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MultiDOFJointState),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MultiDOFJointState>())).joint_names as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MultiDOFJointState),
            "::",
            stringify!(joint_names)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MultiDOFJointState>())).transforms as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MultiDOFJointState),
            "::",
            stringify!(transforms)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MultiDOFJointState>())).twist as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MultiDOFJointState),
            "::",
            stringify!(twist)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MultiDOFJointState>())).wrench as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MultiDOFJointState),
            "::",
            stringify!(wrench)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__MultiDOFJointState__Sequence {
    pub data: *mut sensor_msgs__msg__MultiDOFJointState,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__MultiDOFJointState__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__MultiDOFJointState__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(sensor_msgs__msg__MultiDOFJointState__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__MultiDOFJointState__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__MultiDOFJointState__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MultiDOFJointState__Sequence>())).data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MultiDOFJointState__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MultiDOFJointState__Sequence>())).size
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MultiDOFJointState__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MultiDOFJointState__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MultiDOFJointState__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/MultiDOFJointState message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__MultiDOFJointState"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__MultiDOFJointState__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MultiDOFJointState__init(
        msg: *mut sensor_msgs__msg__MultiDOFJointState,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/MultiDOFJointState message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MultiDOFJointState__fini(
        msg: *mut sensor_msgs__msg__MultiDOFJointState,
    );
}
extern "C" {
    #[doc = " Create msg/MultiDOFJointState message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__MultiDOFJointState__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MultiDOFJointState__create(
    ) -> *mut sensor_msgs__msg__MultiDOFJointState;
}
extern "C" {
    #[doc = " Destroy msg/MultiDOFJointState message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__MultiDOFJointState__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MultiDOFJointState__destroy(
        msg: *mut sensor_msgs__msg__MultiDOFJointState,
    );
}
extern "C" {
    #[doc = " Check for msg/MultiDOFJointState message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MultiDOFJointState__are_equal(
        lhs: *const sensor_msgs__msg__MultiDOFJointState,
        rhs: *const sensor_msgs__msg__MultiDOFJointState,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/MultiDOFJointState message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MultiDOFJointState__copy(
        input: *const sensor_msgs__msg__MultiDOFJointState,
        output: *mut sensor_msgs__msg__MultiDOFJointState,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/MultiDOFJointState messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__MultiDOFJointState__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MultiDOFJointState__Sequence__init(
        array: *mut sensor_msgs__msg__MultiDOFJointState__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/MultiDOFJointState messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__MultiDOFJointState__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MultiDOFJointState__Sequence__fini(
        array: *mut sensor_msgs__msg__MultiDOFJointState__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/MultiDOFJointState messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__MultiDOFJointState__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MultiDOFJointState__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__MultiDOFJointState__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/MultiDOFJointState messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__MultiDOFJointState__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MultiDOFJointState__Sequence__destroy(
        array: *mut sensor_msgs__msg__MultiDOFJointState__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/MultiDOFJointState message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MultiDOFJointState__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__MultiDOFJointState__Sequence,
        rhs: *const sensor_msgs__msg__MultiDOFJointState__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/MultiDOFJointState messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MultiDOFJointState__Sequence__copy(
        input: *const sensor_msgs__msg__MultiDOFJointState__Sequence,
        output: *mut sensor_msgs__msg__MultiDOFJointState__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__MultiDOFJointState(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__MultiEchoLaserScan {
    pub header: std_msgs__msg__Header,
    pub angle_min: f32,
    pub angle_max: f32,
    pub angle_increment: f32,
    pub time_increment: f32,
    pub scan_time: f32,
    pub range_min: f32,
    pub range_max: f32,
    pub ranges: sensor_msgs__msg__LaserEcho__Sequence,
    pub intensities: sensor_msgs__msg__LaserEcho__Sequence,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__MultiEchoLaserScan() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__MultiEchoLaserScan>(),
        112usize,
        concat!(
            "Size of: ",
            stringify!(sensor_msgs__msg__MultiEchoLaserScan)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__MultiEchoLaserScan>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__MultiEchoLaserScan)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MultiEchoLaserScan>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MultiEchoLaserScan),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MultiEchoLaserScan>())).angle_min as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MultiEchoLaserScan),
            "::",
            stringify!(angle_min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MultiEchoLaserScan>())).angle_max as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MultiEchoLaserScan),
            "::",
            stringify!(angle_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MultiEchoLaserScan>())).angle_increment
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MultiEchoLaserScan),
            "::",
            stringify!(angle_increment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MultiEchoLaserScan>())).time_increment
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MultiEchoLaserScan),
            "::",
            stringify!(time_increment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MultiEchoLaserScan>())).scan_time as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MultiEchoLaserScan),
            "::",
            stringify!(scan_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MultiEchoLaserScan>())).range_min as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MultiEchoLaserScan),
            "::",
            stringify!(range_min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MultiEchoLaserScan>())).range_max as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MultiEchoLaserScan),
            "::",
            stringify!(range_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MultiEchoLaserScan>())).ranges as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MultiEchoLaserScan),
            "::",
            stringify!(ranges)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MultiEchoLaserScan>())).intensities as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MultiEchoLaserScan),
            "::",
            stringify!(intensities)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__MultiEchoLaserScan__Sequence {
    pub data: *mut sensor_msgs__msg__MultiEchoLaserScan,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__MultiEchoLaserScan__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__MultiEchoLaserScan__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(sensor_msgs__msg__MultiEchoLaserScan__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__MultiEchoLaserScan__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__MultiEchoLaserScan__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MultiEchoLaserScan__Sequence>())).data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MultiEchoLaserScan__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MultiEchoLaserScan__Sequence>())).size
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MultiEchoLaserScan__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__MultiEchoLaserScan__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__MultiEchoLaserScan__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/MultiEchoLaserScan message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__MultiEchoLaserScan"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__MultiEchoLaserScan__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MultiEchoLaserScan__init(
        msg: *mut sensor_msgs__msg__MultiEchoLaserScan,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/MultiEchoLaserScan message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MultiEchoLaserScan__fini(
        msg: *mut sensor_msgs__msg__MultiEchoLaserScan,
    );
}
extern "C" {
    #[doc = " Create msg/MultiEchoLaserScan message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__MultiEchoLaserScan__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MultiEchoLaserScan__create(
    ) -> *mut sensor_msgs__msg__MultiEchoLaserScan;
}
extern "C" {
    #[doc = " Destroy msg/MultiEchoLaserScan message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__MultiEchoLaserScan__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MultiEchoLaserScan__destroy(
        msg: *mut sensor_msgs__msg__MultiEchoLaserScan,
    );
}
extern "C" {
    #[doc = " Check for msg/MultiEchoLaserScan message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MultiEchoLaserScan__are_equal(
        lhs: *const sensor_msgs__msg__MultiEchoLaserScan,
        rhs: *const sensor_msgs__msg__MultiEchoLaserScan,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/MultiEchoLaserScan message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MultiEchoLaserScan__copy(
        input: *const sensor_msgs__msg__MultiEchoLaserScan,
        output: *mut sensor_msgs__msg__MultiEchoLaserScan,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/MultiEchoLaserScan messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__MultiEchoLaserScan__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MultiEchoLaserScan__Sequence__init(
        array: *mut sensor_msgs__msg__MultiEchoLaserScan__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/MultiEchoLaserScan messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__MultiEchoLaserScan__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MultiEchoLaserScan__Sequence__fini(
        array: *mut sensor_msgs__msg__MultiEchoLaserScan__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/MultiEchoLaserScan messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__MultiEchoLaserScan__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MultiEchoLaserScan__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__MultiEchoLaserScan__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/MultiEchoLaserScan messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__MultiEchoLaserScan__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MultiEchoLaserScan__Sequence__destroy(
        array: *mut sensor_msgs__msg__MultiEchoLaserScan__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/MultiEchoLaserScan message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MultiEchoLaserScan__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__MultiEchoLaserScan__Sequence,
        rhs: *const sensor_msgs__msg__MultiEchoLaserScan__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/MultiEchoLaserScan messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__MultiEchoLaserScan__Sequence__copy(
        input: *const sensor_msgs__msg__MultiEchoLaserScan__Sequence,
        output: *mut sensor_msgs__msg__MultiEchoLaserScan__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__MultiEchoLaserScan(
    ) -> *const rosidl_message_type_support_t;
}
pub const sensor_msgs__msg__NavSatFix__COVARIANCE_TYPE_UNKNOWN: ::std::os::raw::c_uint = 0;
#[doc = " Constant 'COVARIANCE_TYPE_UNKNOWN'."]
pub type _bindgen_ty_25 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__NavSatFix__COVARIANCE_TYPE_APPROXIMATED: ::std::os::raw::c_uint = 1;
#[doc = " Constant 'COVARIANCE_TYPE_APPROXIMATED'."]
pub type _bindgen_ty_26 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__NavSatFix__COVARIANCE_TYPE_DIAGONAL_KNOWN: ::std::os::raw::c_uint = 2;
#[doc = " Constant 'COVARIANCE_TYPE_DIAGONAL_KNOWN'."]
pub type _bindgen_ty_27 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__NavSatFix__COVARIANCE_TYPE_KNOWN: ::std::os::raw::c_uint = 3;
#[doc = " Constant 'COVARIANCE_TYPE_KNOWN'."]
pub type _bindgen_ty_28 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__NavSatStatus__STATUS_NO_FIX: ::std::os::raw::c_int = -1;
#[doc = " Constant 'STATUS_NO_FIX'."]
pub type _bindgen_ty_29 = ::std::os::raw::c_int;
pub const sensor_msgs__msg__NavSatStatus__STATUS_FIX: ::std::os::raw::c_uint = 0;
#[doc = " Constant 'STATUS_FIX'."]
pub type _bindgen_ty_30 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__NavSatStatus__STATUS_SBAS_FIX: ::std::os::raw::c_uint = 1;
#[doc = " Constant 'STATUS_SBAS_FIX'."]
pub type _bindgen_ty_31 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__NavSatStatus__STATUS_GBAS_FIX: ::std::os::raw::c_uint = 2;
#[doc = " Constant 'STATUS_GBAS_FIX'."]
pub type _bindgen_ty_32 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__NavSatStatus__SERVICE_GPS: ::std::os::raw::c_uint = 1;
#[doc = " Constant 'SERVICE_GPS'."]
pub type _bindgen_ty_33 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__NavSatStatus__SERVICE_GLONASS: ::std::os::raw::c_uint = 2;
#[doc = " Constant 'SERVICE_GLONASS'."]
pub type _bindgen_ty_34 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__NavSatStatus__SERVICE_COMPASS: ::std::os::raw::c_uint = 4;
#[doc = " Constant 'SERVICE_COMPASS'."]
pub type _bindgen_ty_35 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__NavSatStatus__SERVICE_GALILEO: ::std::os::raw::c_uint = 8;
#[doc = " Constant 'SERVICE_GALILEO'."]
pub type _bindgen_ty_36 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__NavSatStatus {
    pub status: i8,
    pub service: u16,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__NavSatStatus() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__NavSatStatus>(),
        4usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__NavSatStatus))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__NavSatStatus>(),
        2usize,
        concat!("Alignment of ", stringify!(sensor_msgs__msg__NavSatStatus))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__NavSatStatus>())).status as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__NavSatStatus),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__NavSatStatus>())).service as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__NavSatStatus),
            "::",
            stringify!(service)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__NavSatStatus__Sequence {
    pub data: *mut sensor_msgs__msg__NavSatStatus,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__NavSatStatus__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__NavSatStatus__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(sensor_msgs__msg__NavSatStatus__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__NavSatStatus__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__NavSatStatus__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__NavSatStatus__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__NavSatStatus__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__NavSatStatus__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__NavSatStatus__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__NavSatStatus__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__NavSatStatus__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__NavSatFix {
    pub header: std_msgs__msg__Header,
    pub status: sensor_msgs__msg__NavSatStatus,
    pub latitude: f64,
    pub longitude: f64,
    pub altitude: f64,
    pub position_covariance: [f64; 9usize],
    pub position_covariance_type: u8,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__NavSatFix() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__NavSatFix>(),
        144usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__NavSatFix))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__NavSatFix>(),
        8usize,
        concat!("Alignment of ", stringify!(sensor_msgs__msg__NavSatFix))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__NavSatFix>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__NavSatFix),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__NavSatFix>())).status as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__NavSatFix),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__NavSatFix>())).latitude as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__NavSatFix),
            "::",
            stringify!(latitude)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__NavSatFix>())).longitude as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__NavSatFix),
            "::",
            stringify!(longitude)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__NavSatFix>())).altitude as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__NavSatFix),
            "::",
            stringify!(altitude)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__NavSatFix>())).position_covariance as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__NavSatFix),
            "::",
            stringify!(position_covariance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__NavSatFix>())).position_covariance_type
                as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__NavSatFix),
            "::",
            stringify!(position_covariance_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__NavSatFix__Sequence {
    pub data: *mut sensor_msgs__msg__NavSatFix,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__NavSatFix__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__NavSatFix__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(sensor_msgs__msg__NavSatFix__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__NavSatFix__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__NavSatFix__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__NavSatFix__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__NavSatFix__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__NavSatFix__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__NavSatFix__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__NavSatFix__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__NavSatFix__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/NavSatFix message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__NavSatFix"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__NavSatFix__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__NavSatFix__init(msg: *mut sensor_msgs__msg__NavSatFix) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/NavSatFix message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__NavSatFix__fini(msg: *mut sensor_msgs__msg__NavSatFix);
}
extern "C" {
    #[doc = " Create msg/NavSatFix message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__NavSatFix__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__NavSatFix__create() -> *mut sensor_msgs__msg__NavSatFix;
}
extern "C" {
    #[doc = " Destroy msg/NavSatFix message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__NavSatFix__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__NavSatFix__destroy(msg: *mut sensor_msgs__msg__NavSatFix);
}
extern "C" {
    #[doc = " Check for msg/NavSatFix message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__NavSatFix__are_equal(
        lhs: *const sensor_msgs__msg__NavSatFix,
        rhs: *const sensor_msgs__msg__NavSatFix,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/NavSatFix message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__NavSatFix__copy(
        input: *const sensor_msgs__msg__NavSatFix,
        output: *mut sensor_msgs__msg__NavSatFix,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/NavSatFix messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__NavSatFix__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__NavSatFix__Sequence__init(
        array: *mut sensor_msgs__msg__NavSatFix__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/NavSatFix messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__NavSatFix__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__NavSatFix__Sequence__fini(
        array: *mut sensor_msgs__msg__NavSatFix__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/NavSatFix messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__NavSatFix__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__NavSatFix__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__NavSatFix__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/NavSatFix messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__NavSatFix__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__NavSatFix__Sequence__destroy(
        array: *mut sensor_msgs__msg__NavSatFix__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/NavSatFix message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__NavSatFix__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__NavSatFix__Sequence,
        rhs: *const sensor_msgs__msg__NavSatFix__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/NavSatFix messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__NavSatFix__Sequence__copy(
        input: *const sensor_msgs__msg__NavSatFix__Sequence,
        output: *mut sensor_msgs__msg__NavSatFix__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__NavSatFix(
    ) -> *const rosidl_message_type_support_t;
}
extern "C" {
    #[doc = " Initialize msg/NavSatStatus message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__NavSatStatus"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__NavSatStatus__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__NavSatStatus__init(msg: *mut sensor_msgs__msg__NavSatStatus) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/NavSatStatus message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__NavSatStatus__fini(msg: *mut sensor_msgs__msg__NavSatStatus);
}
extern "C" {
    #[doc = " Create msg/NavSatStatus message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__NavSatStatus__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__NavSatStatus__create() -> *mut sensor_msgs__msg__NavSatStatus;
}
extern "C" {
    #[doc = " Destroy msg/NavSatStatus message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__NavSatStatus__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__NavSatStatus__destroy(msg: *mut sensor_msgs__msg__NavSatStatus);
}
extern "C" {
    #[doc = " Check for msg/NavSatStatus message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__NavSatStatus__are_equal(
        lhs: *const sensor_msgs__msg__NavSatStatus,
        rhs: *const sensor_msgs__msg__NavSatStatus,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/NavSatStatus message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__NavSatStatus__copy(
        input: *const sensor_msgs__msg__NavSatStatus,
        output: *mut sensor_msgs__msg__NavSatStatus,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/NavSatStatus messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__NavSatStatus__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__NavSatStatus__Sequence__init(
        array: *mut sensor_msgs__msg__NavSatStatus__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/NavSatStatus messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__NavSatStatus__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__NavSatStatus__Sequence__fini(
        array: *mut sensor_msgs__msg__NavSatStatus__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/NavSatStatus messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__NavSatStatus__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__NavSatStatus__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__NavSatStatus__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/NavSatStatus messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__NavSatStatus__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__NavSatStatus__Sequence__destroy(
        array: *mut sensor_msgs__msg__NavSatStatus__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/NavSatStatus message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__NavSatStatus__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__NavSatStatus__Sequence,
        rhs: *const sensor_msgs__msg__NavSatStatus__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/NavSatStatus messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__NavSatStatus__Sequence__copy(
        input: *const sensor_msgs__msg__NavSatStatus__Sequence,
        output: *mut sensor_msgs__msg__NavSatStatus__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__NavSatStatus(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__PointCloud {
    pub header: std_msgs__msg__Header,
    pub points: geometry_msgs__msg__Point32__Sequence,
    pub channels: sensor_msgs__msg__ChannelFloat32__Sequence,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__PointCloud() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__PointCloud>(),
        80usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__PointCloud))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__PointCloud>(),
        8usize,
        concat!("Alignment of ", stringify!(sensor_msgs__msg__PointCloud))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__PointCloud>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__PointCloud),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__PointCloud>())).points as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__PointCloud),
            "::",
            stringify!(points)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__PointCloud>())).channels as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__PointCloud),
            "::",
            stringify!(channels)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__PointCloud__Sequence {
    pub data: *mut sensor_msgs__msg__PointCloud,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__PointCloud__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__PointCloud__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(sensor_msgs__msg__PointCloud__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__PointCloud__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__PointCloud__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__PointCloud__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__PointCloud__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__PointCloud__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__PointCloud__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__PointCloud__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__PointCloud__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/PointCloud message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__PointCloud"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__PointCloud__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointCloud__init(msg: *mut sensor_msgs__msg__PointCloud) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/PointCloud message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointCloud__fini(msg: *mut sensor_msgs__msg__PointCloud);
}
extern "C" {
    #[doc = " Create msg/PointCloud message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__PointCloud__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointCloud__create() -> *mut sensor_msgs__msg__PointCloud;
}
extern "C" {
    #[doc = " Destroy msg/PointCloud message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__PointCloud__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointCloud__destroy(msg: *mut sensor_msgs__msg__PointCloud);
}
extern "C" {
    #[doc = " Check for msg/PointCloud message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointCloud__are_equal(
        lhs: *const sensor_msgs__msg__PointCloud,
        rhs: *const sensor_msgs__msg__PointCloud,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/PointCloud message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointCloud__copy(
        input: *const sensor_msgs__msg__PointCloud,
        output: *mut sensor_msgs__msg__PointCloud,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/PointCloud messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__PointCloud__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointCloud__Sequence__init(
        array: *mut sensor_msgs__msg__PointCloud__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/PointCloud messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__PointCloud__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointCloud__Sequence__fini(
        array: *mut sensor_msgs__msg__PointCloud__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/PointCloud messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__PointCloud__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointCloud__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__PointCloud__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/PointCloud messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__PointCloud__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointCloud__Sequence__destroy(
        array: *mut sensor_msgs__msg__PointCloud__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/PointCloud message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointCloud__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__PointCloud__Sequence,
        rhs: *const sensor_msgs__msg__PointCloud__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/PointCloud messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointCloud__Sequence__copy(
        input: *const sensor_msgs__msg__PointCloud__Sequence,
        output: *mut sensor_msgs__msg__PointCloud__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__PointCloud(
    ) -> *const rosidl_message_type_support_t;
}
pub const sensor_msgs__msg__PointField__INT8: ::std::os::raw::c_uint = 1;
#[doc = " Constant 'INT8'."]
pub type _bindgen_ty_37 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__PointField__UINT8: ::std::os::raw::c_uint = 2;
#[doc = " Constant 'UINT8'."]
pub type _bindgen_ty_38 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__PointField__INT16: ::std::os::raw::c_uint = 3;
#[doc = " Constant 'INT16'."]
pub type _bindgen_ty_39 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__PointField__UINT16: ::std::os::raw::c_uint = 4;
#[doc = " Constant 'UINT16'."]
pub type _bindgen_ty_40 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__PointField__INT32: ::std::os::raw::c_uint = 5;
#[doc = " Constant 'INT32'."]
pub type _bindgen_ty_41 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__PointField__UINT32: ::std::os::raw::c_uint = 6;
#[doc = " Constant 'UINT32'."]
pub type _bindgen_ty_42 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__PointField__FLOAT32: ::std::os::raw::c_uint = 7;
#[doc = " Constant 'FLOAT32'."]
pub type _bindgen_ty_43 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__PointField__FLOAT64: ::std::os::raw::c_uint = 8;
#[doc = " Constant 'FLOAT64'."]
pub type _bindgen_ty_44 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__PointField {
    pub name: rosidl_runtime_c__String,
    pub offset: u32,
    pub datatype: u8,
    pub count: u32,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__PointField() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__PointField>(),
        40usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__PointField))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__PointField>(),
        8usize,
        concat!("Alignment of ", stringify!(sensor_msgs__msg__PointField))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__PointField>())).name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__PointField),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__PointField>())).offset as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__PointField),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__PointField>())).datatype as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__PointField),
            "::",
            stringify!(datatype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__PointField>())).count as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__PointField),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__PointField__Sequence {
    pub data: *mut sensor_msgs__msg__PointField,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__PointField__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__PointField__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(sensor_msgs__msg__PointField__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__PointField__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__PointField__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__PointField__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__PointField__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__PointField__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__PointField__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__PointField__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__PointField__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__PointCloud2 {
    pub header: std_msgs__msg__Header,
    pub height: u32,
    pub width: u32,
    pub fields: sensor_msgs__msg__PointField__Sequence,
    pub is_bigendian: bool,
    pub point_step: u32,
    pub row_step: u32,
    pub data: rosidl_runtime_c__uint8__Sequence,
    pub is_dense: bool,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__PointCloud2() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__PointCloud2>(),
        112usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__PointCloud2))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__PointCloud2>(),
        8usize,
        concat!("Alignment of ", stringify!(sensor_msgs__msg__PointCloud2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__PointCloud2>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__PointCloud2),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__PointCloud2>())).height as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__PointCloud2),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__PointCloud2>())).width as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__PointCloud2),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__PointCloud2>())).fields as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__PointCloud2),
            "::",
            stringify!(fields)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__PointCloud2>())).is_bigendian as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__PointCloud2),
            "::",
            stringify!(is_bigendian)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__PointCloud2>())).point_step as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__PointCloud2),
            "::",
            stringify!(point_step)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__PointCloud2>())).row_step as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__PointCloud2),
            "::",
            stringify!(row_step)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__PointCloud2>())).data as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__PointCloud2),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__PointCloud2>())).is_dense as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__PointCloud2),
            "::",
            stringify!(is_dense)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__PointCloud2__Sequence {
    pub data: *mut sensor_msgs__msg__PointCloud2,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__PointCloud2__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__PointCloud2__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(sensor_msgs__msg__PointCloud2__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__PointCloud2__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__PointCloud2__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__PointCloud2__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__PointCloud2__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__PointCloud2__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__PointCloud2__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__PointCloud2__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__PointCloud2__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/PointCloud2 message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__PointCloud2"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__PointCloud2__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointCloud2__init(msg: *mut sensor_msgs__msg__PointCloud2) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/PointCloud2 message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointCloud2__fini(msg: *mut sensor_msgs__msg__PointCloud2);
}
extern "C" {
    #[doc = " Create msg/PointCloud2 message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__PointCloud2__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointCloud2__create() -> *mut sensor_msgs__msg__PointCloud2;
}
extern "C" {
    #[doc = " Destroy msg/PointCloud2 message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__PointCloud2__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointCloud2__destroy(msg: *mut sensor_msgs__msg__PointCloud2);
}
extern "C" {
    #[doc = " Check for msg/PointCloud2 message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointCloud2__are_equal(
        lhs: *const sensor_msgs__msg__PointCloud2,
        rhs: *const sensor_msgs__msg__PointCloud2,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/PointCloud2 message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointCloud2__copy(
        input: *const sensor_msgs__msg__PointCloud2,
        output: *mut sensor_msgs__msg__PointCloud2,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/PointCloud2 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__PointCloud2__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointCloud2__Sequence__init(
        array: *mut sensor_msgs__msg__PointCloud2__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/PointCloud2 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__PointCloud2__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointCloud2__Sequence__fini(
        array: *mut sensor_msgs__msg__PointCloud2__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/PointCloud2 messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__PointCloud2__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointCloud2__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__PointCloud2__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/PointCloud2 messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__PointCloud2__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointCloud2__Sequence__destroy(
        array: *mut sensor_msgs__msg__PointCloud2__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/PointCloud2 message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointCloud2__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__PointCloud2__Sequence,
        rhs: *const sensor_msgs__msg__PointCloud2__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/PointCloud2 messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointCloud2__Sequence__copy(
        input: *const sensor_msgs__msg__PointCloud2__Sequence,
        output: *mut sensor_msgs__msg__PointCloud2__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__PointCloud2(
    ) -> *const rosidl_message_type_support_t;
}
extern "C" {
    #[doc = " Initialize msg/PointField message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__PointField"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__PointField__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointField__init(msg: *mut sensor_msgs__msg__PointField) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/PointField message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointField__fini(msg: *mut sensor_msgs__msg__PointField);
}
extern "C" {
    #[doc = " Create msg/PointField message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__PointField__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointField__create() -> *mut sensor_msgs__msg__PointField;
}
extern "C" {
    #[doc = " Destroy msg/PointField message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__PointField__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointField__destroy(msg: *mut sensor_msgs__msg__PointField);
}
extern "C" {
    #[doc = " Check for msg/PointField message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointField__are_equal(
        lhs: *const sensor_msgs__msg__PointField,
        rhs: *const sensor_msgs__msg__PointField,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/PointField message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointField__copy(
        input: *const sensor_msgs__msg__PointField,
        output: *mut sensor_msgs__msg__PointField,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/PointField messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__PointField__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointField__Sequence__init(
        array: *mut sensor_msgs__msg__PointField__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/PointField messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__PointField__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointField__Sequence__fini(
        array: *mut sensor_msgs__msg__PointField__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/PointField messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__PointField__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointField__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__PointField__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/PointField messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__PointField__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointField__Sequence__destroy(
        array: *mut sensor_msgs__msg__PointField__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/PointField message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointField__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__PointField__Sequence,
        rhs: *const sensor_msgs__msg__PointField__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/PointField messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__PointField__Sequence__copy(
        input: *const sensor_msgs__msg__PointField__Sequence,
        output: *mut sensor_msgs__msg__PointField__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__PointField(
    ) -> *const rosidl_message_type_support_t;
}
pub const sensor_msgs__msg__Range__ULTRASOUND: ::std::os::raw::c_uint = 0;
#[doc = " Constant 'ULTRASOUND'."]
pub type _bindgen_ty_45 = ::std::os::raw::c_uint;
pub const sensor_msgs__msg__Range__INFRARED: ::std::os::raw::c_uint = 1;
#[doc = " Constant 'INFRARED'."]
pub type _bindgen_ty_46 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__Range {
    pub header: std_msgs__msg__Header,
    pub radiation_type: u8,
    pub field_of_view: f32,
    pub min_range: f32,
    pub max_range: f32,
    pub range: f32,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__Range() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__Range>(),
        56usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__Range))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__Range>(),
        8usize,
        concat!("Alignment of ", stringify!(sensor_msgs__msg__Range))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sensor_msgs__msg__Range>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Range),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Range>())).radiation_type as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Range),
            "::",
            stringify!(radiation_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Range>())).field_of_view as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Range),
            "::",
            stringify!(field_of_view)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Range>())).min_range as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Range),
            "::",
            stringify!(min_range)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Range>())).max_range as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Range),
            "::",
            stringify!(max_range)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sensor_msgs__msg__Range>())).range as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Range),
            "::",
            stringify!(range)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__Range__Sequence {
    pub data: *mut sensor_msgs__msg__Range,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__Range__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__Range__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__Range__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__Range__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__Range__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Range__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Range__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Range__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Range__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Range__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Range__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Range message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__Range"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__Range__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Range__init(msg: *mut sensor_msgs__msg__Range) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Range message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Range__fini(msg: *mut sensor_msgs__msg__Range);
}
extern "C" {
    #[doc = " Create msg/Range message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__Range__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Range__create() -> *mut sensor_msgs__msg__Range;
}
extern "C" {
    #[doc = " Destroy msg/Range message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__Range__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Range__destroy(msg: *mut sensor_msgs__msg__Range);
}
extern "C" {
    #[doc = " Check for msg/Range message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Range__are_equal(
        lhs: *const sensor_msgs__msg__Range,
        rhs: *const sensor_msgs__msg__Range,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Range message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Range__copy(
        input: *const sensor_msgs__msg__Range,
        output: *mut sensor_msgs__msg__Range,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Range messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__Range__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Range__Sequence__init(
        array: *mut sensor_msgs__msg__Range__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Range messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__Range__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Range__Sequence__fini(array: *mut sensor_msgs__msg__Range__Sequence);
}
extern "C" {
    #[doc = " Create array of msg/Range messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__Range__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Range__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__Range__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Range messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__Range__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Range__Sequence__destroy(
        array: *mut sensor_msgs__msg__Range__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Range message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Range__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__Range__Sequence,
        rhs: *const sensor_msgs__msg__Range__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Range messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Range__Sequence__copy(
        input: *const sensor_msgs__msg__Range__Sequence,
        output: *mut sensor_msgs__msg__Range__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__Range(
    ) -> *const rosidl_message_type_support_t;
}
extern "C" {
    #[doc = " Initialize msg/RegionOfInterest message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__RegionOfInterest"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__RegionOfInterest__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__RegionOfInterest__init(
        msg: *mut sensor_msgs__msg__RegionOfInterest,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/RegionOfInterest message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__RegionOfInterest__fini(msg: *mut sensor_msgs__msg__RegionOfInterest);
}
extern "C" {
    #[doc = " Create msg/RegionOfInterest message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__RegionOfInterest__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__RegionOfInterest__create() -> *mut sensor_msgs__msg__RegionOfInterest;
}
extern "C" {
    #[doc = " Destroy msg/RegionOfInterest message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__RegionOfInterest__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__RegionOfInterest__destroy(
        msg: *mut sensor_msgs__msg__RegionOfInterest,
    );
}
extern "C" {
    #[doc = " Check for msg/RegionOfInterest message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__RegionOfInterest__are_equal(
        lhs: *const sensor_msgs__msg__RegionOfInterest,
        rhs: *const sensor_msgs__msg__RegionOfInterest,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/RegionOfInterest message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__RegionOfInterest__copy(
        input: *const sensor_msgs__msg__RegionOfInterest,
        output: *mut sensor_msgs__msg__RegionOfInterest,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/RegionOfInterest messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__RegionOfInterest__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__RegionOfInterest__Sequence__init(
        array: *mut sensor_msgs__msg__RegionOfInterest__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/RegionOfInterest messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__RegionOfInterest__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__RegionOfInterest__Sequence__fini(
        array: *mut sensor_msgs__msg__RegionOfInterest__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/RegionOfInterest messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__RegionOfInterest__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__RegionOfInterest__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__RegionOfInterest__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/RegionOfInterest messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__RegionOfInterest__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__RegionOfInterest__Sequence__destroy(
        array: *mut sensor_msgs__msg__RegionOfInterest__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/RegionOfInterest message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__RegionOfInterest__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__RegionOfInterest__Sequence,
        rhs: *const sensor_msgs__msg__RegionOfInterest__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/RegionOfInterest messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__RegionOfInterest__Sequence__copy(
        input: *const sensor_msgs__msg__RegionOfInterest__Sequence,
        output: *mut sensor_msgs__msg__RegionOfInterest__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__RegionOfInterest(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__RelativeHumidity {
    pub header: std_msgs__msg__Header,
    pub relative_humidity: f64,
    pub variance: f64,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__RelativeHumidity() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__RelativeHumidity>(),
        48usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__RelativeHumidity))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__RelativeHumidity>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__RelativeHumidity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__RelativeHumidity>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__RelativeHumidity),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__RelativeHumidity>())).relative_humidity
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__RelativeHumidity),
            "::",
            stringify!(relative_humidity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__RelativeHumidity>())).variance as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__RelativeHumidity),
            "::",
            stringify!(variance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__RelativeHumidity__Sequence {
    pub data: *mut sensor_msgs__msg__RelativeHumidity,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__RelativeHumidity__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__RelativeHumidity__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(sensor_msgs__msg__RelativeHumidity__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__RelativeHumidity__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__RelativeHumidity__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__RelativeHumidity__Sequence>())).data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__RelativeHumidity__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__RelativeHumidity__Sequence>())).size
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__RelativeHumidity__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__RelativeHumidity__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__RelativeHumidity__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/RelativeHumidity message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__RelativeHumidity"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__RelativeHumidity__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__RelativeHumidity__init(
        msg: *mut sensor_msgs__msg__RelativeHumidity,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/RelativeHumidity message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__RelativeHumidity__fini(msg: *mut sensor_msgs__msg__RelativeHumidity);
}
extern "C" {
    #[doc = " Create msg/RelativeHumidity message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__RelativeHumidity__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__RelativeHumidity__create() -> *mut sensor_msgs__msg__RelativeHumidity;
}
extern "C" {
    #[doc = " Destroy msg/RelativeHumidity message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__RelativeHumidity__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__RelativeHumidity__destroy(
        msg: *mut sensor_msgs__msg__RelativeHumidity,
    );
}
extern "C" {
    #[doc = " Check for msg/RelativeHumidity message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__RelativeHumidity__are_equal(
        lhs: *const sensor_msgs__msg__RelativeHumidity,
        rhs: *const sensor_msgs__msg__RelativeHumidity,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/RelativeHumidity message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__RelativeHumidity__copy(
        input: *const sensor_msgs__msg__RelativeHumidity,
        output: *mut sensor_msgs__msg__RelativeHumidity,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/RelativeHumidity messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__RelativeHumidity__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__RelativeHumidity__Sequence__init(
        array: *mut sensor_msgs__msg__RelativeHumidity__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/RelativeHumidity messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__RelativeHumidity__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__RelativeHumidity__Sequence__fini(
        array: *mut sensor_msgs__msg__RelativeHumidity__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/RelativeHumidity messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__RelativeHumidity__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__RelativeHumidity__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__RelativeHumidity__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/RelativeHumidity messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__RelativeHumidity__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__RelativeHumidity__Sequence__destroy(
        array: *mut sensor_msgs__msg__RelativeHumidity__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/RelativeHumidity message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__RelativeHumidity__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__RelativeHumidity__Sequence,
        rhs: *const sensor_msgs__msg__RelativeHumidity__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/RelativeHumidity messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__RelativeHumidity__Sequence__copy(
        input: *const sensor_msgs__msg__RelativeHumidity__Sequence,
        output: *mut sensor_msgs__msg__RelativeHumidity__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__RelativeHumidity(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__Temperature {
    pub header: std_msgs__msg__Header,
    pub temperature: f64,
    pub variance: f64,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__Temperature() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__Temperature>(),
        48usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__Temperature))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__Temperature>(),
        8usize,
        concat!("Alignment of ", stringify!(sensor_msgs__msg__Temperature))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Temperature>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Temperature),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Temperature>())).temperature as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Temperature),
            "::",
            stringify!(temperature)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Temperature>())).variance as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Temperature),
            "::",
            stringify!(variance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__Temperature__Sequence {
    pub data: *mut sensor_msgs__msg__Temperature,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__Temperature__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__Temperature__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(sensor_msgs__msg__Temperature__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__Temperature__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__Temperature__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Temperature__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Temperature__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Temperature__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Temperature__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__Temperature__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__Temperature__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Temperature message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__Temperature"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__Temperature__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Temperature__init(msg: *mut sensor_msgs__msg__Temperature) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Temperature message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Temperature__fini(msg: *mut sensor_msgs__msg__Temperature);
}
extern "C" {
    #[doc = " Create msg/Temperature message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__Temperature__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Temperature__create() -> *mut sensor_msgs__msg__Temperature;
}
extern "C" {
    #[doc = " Destroy msg/Temperature message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__Temperature__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Temperature__destroy(msg: *mut sensor_msgs__msg__Temperature);
}
extern "C" {
    #[doc = " Check for msg/Temperature message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Temperature__are_equal(
        lhs: *const sensor_msgs__msg__Temperature,
        rhs: *const sensor_msgs__msg__Temperature,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Temperature message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Temperature__copy(
        input: *const sensor_msgs__msg__Temperature,
        output: *mut sensor_msgs__msg__Temperature,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Temperature messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__Temperature__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Temperature__Sequence__init(
        array: *mut sensor_msgs__msg__Temperature__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Temperature messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__Temperature__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Temperature__Sequence__fini(
        array: *mut sensor_msgs__msg__Temperature__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/Temperature messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__Temperature__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Temperature__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__Temperature__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Temperature messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__Temperature__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Temperature__Sequence__destroy(
        array: *mut sensor_msgs__msg__Temperature__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Temperature message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Temperature__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__Temperature__Sequence,
        rhs: *const sensor_msgs__msg__Temperature__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Temperature messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__Temperature__Sequence__copy(
        input: *const sensor_msgs__msg__Temperature__Sequence,
        output: *mut sensor_msgs__msg__Temperature__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__Temperature(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__TimeReference {
    pub header: std_msgs__msg__Header,
    pub time_ref: builtin_interfaces__msg__Time,
    pub source: rosidl_runtime_c__String,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__TimeReference() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__TimeReference>(),
        64usize,
        concat!("Size of: ", stringify!(sensor_msgs__msg__TimeReference))
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__TimeReference>(),
        8usize,
        concat!("Alignment of ", stringify!(sensor_msgs__msg__TimeReference))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__TimeReference>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__TimeReference),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__TimeReference>())).time_ref as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__TimeReference),
            "::",
            stringify!(time_ref)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__TimeReference>())).source as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__TimeReference),
            "::",
            stringify!(source)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sensor_msgs__msg__TimeReference__Sequence {
    pub data: *mut sensor_msgs__msg__TimeReference,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_sensor_msgs__msg__TimeReference__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<sensor_msgs__msg__TimeReference__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(sensor_msgs__msg__TimeReference__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<sensor_msgs__msg__TimeReference__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(sensor_msgs__msg__TimeReference__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__TimeReference__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__TimeReference__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__TimeReference__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__TimeReference__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sensor_msgs__msg__TimeReference__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sensor_msgs__msg__TimeReference__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/TimeReference message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* sensor_msgs__msg__TimeReference"]
    #[doc = "* )) before or use"]
    #[doc = "* sensor_msgs__msg__TimeReference__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__TimeReference__init(msg: *mut sensor_msgs__msg__TimeReference)
        -> bool;
}
extern "C" {
    #[doc = " Finalize msg/TimeReference message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__TimeReference__fini(msg: *mut sensor_msgs__msg__TimeReference);
}
extern "C" {
    #[doc = " Create msg/TimeReference message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* sensor_msgs__msg__TimeReference__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__TimeReference__create() -> *mut sensor_msgs__msg__TimeReference;
}
extern "C" {
    #[doc = " Destroy msg/TimeReference message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__TimeReference__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__TimeReference__destroy(msg: *mut sensor_msgs__msg__TimeReference);
}
extern "C" {
    #[doc = " Check for msg/TimeReference message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__TimeReference__are_equal(
        lhs: *const sensor_msgs__msg__TimeReference,
        rhs: *const sensor_msgs__msg__TimeReference,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/TimeReference message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__TimeReference__copy(
        input: *const sensor_msgs__msg__TimeReference,
        output: *mut sensor_msgs__msg__TimeReference,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/TimeReference messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* sensor_msgs__msg__TimeReference__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__TimeReference__Sequence__init(
        array: *mut sensor_msgs__msg__TimeReference__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/TimeReference messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__TimeReference__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__TimeReference__Sequence__fini(
        array: *mut sensor_msgs__msg__TimeReference__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/TimeReference messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* sensor_msgs__msg__TimeReference__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__TimeReference__Sequence__create(
        size: size_t,
    ) -> *mut sensor_msgs__msg__TimeReference__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/TimeReference messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* sensor_msgs__msg__TimeReference__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__TimeReference__Sequence__destroy(
        array: *mut sensor_msgs__msg__TimeReference__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/TimeReference message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__TimeReference__Sequence__are_equal(
        lhs: *const sensor_msgs__msg__TimeReference__Sequence,
        rhs: *const sensor_msgs__msg__TimeReference__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/TimeReference messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn sensor_msgs__msg__TimeReference__Sequence__copy(
        input: *const sensor_msgs__msg__TimeReference__Sequence,
        output: *mut sensor_msgs__msg__TimeReference__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__sensor_msgs__msg__TimeReference(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nav_msgs__msg__GridCells {
    pub header: std_msgs__msg__Header,
    pub cell_width: f32,
    pub cell_height: f32,
    pub cells: geometry_msgs__msg__Point__Sequence,
}
#[test]
fn bindgen_test_layout_nav_msgs__msg__GridCells() {
    assert_eq!(
        ::std::mem::size_of::<nav_msgs__msg__GridCells>(),
        64usize,
        concat!("Size of: ", stringify!(nav_msgs__msg__GridCells))
    );
    assert_eq!(
        ::std::mem::align_of::<nav_msgs__msg__GridCells>(),
        8usize,
        concat!("Alignment of ", stringify!(nav_msgs__msg__GridCells))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nav_msgs__msg__GridCells>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__GridCells),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__GridCells>())).cell_width as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__GridCells),
            "::",
            stringify!(cell_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__GridCells>())).cell_height as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__GridCells),
            "::",
            stringify!(cell_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nav_msgs__msg__GridCells>())).cells as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__GridCells),
            "::",
            stringify!(cells)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nav_msgs__msg__GridCells__Sequence {
    pub data: *mut nav_msgs__msg__GridCells,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_nav_msgs__msg__GridCells__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<nav_msgs__msg__GridCells__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(nav_msgs__msg__GridCells__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<nav_msgs__msg__GridCells__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(nav_msgs__msg__GridCells__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__GridCells__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__GridCells__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__GridCells__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__GridCells__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__GridCells__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__GridCells__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/GridCells message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* nav_msgs__msg__GridCells"]
    #[doc = "* )) before or use"]
    #[doc = "* nav_msgs__msg__GridCells__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn nav_msgs__msg__GridCells__init(msg: *mut nav_msgs__msg__GridCells) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/GridCells message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__GridCells__fini(msg: *mut nav_msgs__msg__GridCells);
}
extern "C" {
    #[doc = " Create msg/GridCells message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* nav_msgs__msg__GridCells__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn nav_msgs__msg__GridCells__create() -> *mut nav_msgs__msg__GridCells;
}
extern "C" {
    #[doc = " Destroy msg/GridCells message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* nav_msgs__msg__GridCells__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__GridCells__destroy(msg: *mut nav_msgs__msg__GridCells);
}
extern "C" {
    #[doc = " Check for msg/GridCells message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__GridCells__are_equal(
        lhs: *const nav_msgs__msg__GridCells,
        rhs: *const nav_msgs__msg__GridCells,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/GridCells message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__GridCells__copy(
        input: *const nav_msgs__msg__GridCells,
        output: *mut nav_msgs__msg__GridCells,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/GridCells messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* nav_msgs__msg__GridCells__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__GridCells__Sequence__init(
        array: *mut nav_msgs__msg__GridCells__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/GridCells messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* nav_msgs__msg__GridCells__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__GridCells__Sequence__fini(array: *mut nav_msgs__msg__GridCells__Sequence);
}
extern "C" {
    #[doc = " Create array of msg/GridCells messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* nav_msgs__msg__GridCells__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn nav_msgs__msg__GridCells__Sequence__create(
        size: size_t,
    ) -> *mut nav_msgs__msg__GridCells__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/GridCells messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* nav_msgs__msg__GridCells__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__GridCells__Sequence__destroy(
        array: *mut nav_msgs__msg__GridCells__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/GridCells message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__GridCells__Sequence__are_equal(
        lhs: *const nav_msgs__msg__GridCells__Sequence,
        rhs: *const nav_msgs__msg__GridCells__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/GridCells messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__GridCells__Sequence__copy(
        input: *const nav_msgs__msg__GridCells__Sequence,
        output: *mut nav_msgs__msg__GridCells__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__nav_msgs__msg__GridCells(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nav_msgs__msg__MapMetaData {
    pub map_load_time: builtin_interfaces__msg__Time,
    pub resolution: f32,
    pub width: u32,
    pub height: u32,
    pub origin: geometry_msgs__msg__Pose,
}
#[test]
fn bindgen_test_layout_nav_msgs__msg__MapMetaData() {
    assert_eq!(
        ::std::mem::size_of::<nav_msgs__msg__MapMetaData>(),
        80usize,
        concat!("Size of: ", stringify!(nav_msgs__msg__MapMetaData))
    );
    assert_eq!(
        ::std::mem::align_of::<nav_msgs__msg__MapMetaData>(),
        8usize,
        concat!("Alignment of ", stringify!(nav_msgs__msg__MapMetaData))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__MapMetaData>())).map_load_time as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__MapMetaData),
            "::",
            stringify!(map_load_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__MapMetaData>())).resolution as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__MapMetaData),
            "::",
            stringify!(resolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__MapMetaData>())).width as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__MapMetaData),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__MapMetaData>())).height as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__MapMetaData),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__MapMetaData>())).origin as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__MapMetaData),
            "::",
            stringify!(origin)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nav_msgs__msg__MapMetaData__Sequence {
    pub data: *mut nav_msgs__msg__MapMetaData,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_nav_msgs__msg__MapMetaData__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<nav_msgs__msg__MapMetaData__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(nav_msgs__msg__MapMetaData__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<nav_msgs__msg__MapMetaData__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(nav_msgs__msg__MapMetaData__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__MapMetaData__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__MapMetaData__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__MapMetaData__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__MapMetaData__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__MapMetaData__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__MapMetaData__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/MapMetaData message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* nav_msgs__msg__MapMetaData"]
    #[doc = "* )) before or use"]
    #[doc = "* nav_msgs__msg__MapMetaData__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn nav_msgs__msg__MapMetaData__init(msg: *mut nav_msgs__msg__MapMetaData) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/MapMetaData message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__MapMetaData__fini(msg: *mut nav_msgs__msg__MapMetaData);
}
extern "C" {
    #[doc = " Create msg/MapMetaData message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* nav_msgs__msg__MapMetaData__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn nav_msgs__msg__MapMetaData__create() -> *mut nav_msgs__msg__MapMetaData;
}
extern "C" {
    #[doc = " Destroy msg/MapMetaData message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* nav_msgs__msg__MapMetaData__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__MapMetaData__destroy(msg: *mut nav_msgs__msg__MapMetaData);
}
extern "C" {
    #[doc = " Check for msg/MapMetaData message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__MapMetaData__are_equal(
        lhs: *const nav_msgs__msg__MapMetaData,
        rhs: *const nav_msgs__msg__MapMetaData,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/MapMetaData message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__MapMetaData__copy(
        input: *const nav_msgs__msg__MapMetaData,
        output: *mut nav_msgs__msg__MapMetaData,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/MapMetaData messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* nav_msgs__msg__MapMetaData__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__MapMetaData__Sequence__init(
        array: *mut nav_msgs__msg__MapMetaData__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/MapMetaData messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* nav_msgs__msg__MapMetaData__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__MapMetaData__Sequence__fini(
        array: *mut nav_msgs__msg__MapMetaData__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/MapMetaData messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* nav_msgs__msg__MapMetaData__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn nav_msgs__msg__MapMetaData__Sequence__create(
        size: size_t,
    ) -> *mut nav_msgs__msg__MapMetaData__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/MapMetaData messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* nav_msgs__msg__MapMetaData__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__MapMetaData__Sequence__destroy(
        array: *mut nav_msgs__msg__MapMetaData__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/MapMetaData message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__MapMetaData__Sequence__are_equal(
        lhs: *const nav_msgs__msg__MapMetaData__Sequence,
        rhs: *const nav_msgs__msg__MapMetaData__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/MapMetaData messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__MapMetaData__Sequence__copy(
        input: *const nav_msgs__msg__MapMetaData__Sequence,
        output: *mut nav_msgs__msg__MapMetaData__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__nav_msgs__msg__MapMetaData(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nav_msgs__msg__OccupancyGrid {
    pub header: std_msgs__msg__Header,
    pub info: nav_msgs__msg__MapMetaData,
    pub data: rosidl_runtime_c__int8__Sequence,
}
#[test]
fn bindgen_test_layout_nav_msgs__msg__OccupancyGrid() {
    assert_eq!(
        ::std::mem::size_of::<nav_msgs__msg__OccupancyGrid>(),
        136usize,
        concat!("Size of: ", stringify!(nav_msgs__msg__OccupancyGrid))
    );
    assert_eq!(
        ::std::mem::align_of::<nav_msgs__msg__OccupancyGrid>(),
        8usize,
        concat!("Alignment of ", stringify!(nav_msgs__msg__OccupancyGrid))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__OccupancyGrid>())).header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__OccupancyGrid),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__OccupancyGrid>())).info as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__OccupancyGrid),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__OccupancyGrid>())).data as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__OccupancyGrid),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nav_msgs__msg__OccupancyGrid__Sequence {
    pub data: *mut nav_msgs__msg__OccupancyGrid,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_nav_msgs__msg__OccupancyGrid__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<nav_msgs__msg__OccupancyGrid__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(nav_msgs__msg__OccupancyGrid__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<nav_msgs__msg__OccupancyGrid__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(nav_msgs__msg__OccupancyGrid__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__OccupancyGrid__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__OccupancyGrid__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__OccupancyGrid__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__OccupancyGrid__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__OccupancyGrid__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__OccupancyGrid__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/OccupancyGrid message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* nav_msgs__msg__OccupancyGrid"]
    #[doc = "* )) before or use"]
    #[doc = "* nav_msgs__msg__OccupancyGrid__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn nav_msgs__msg__OccupancyGrid__init(msg: *mut nav_msgs__msg__OccupancyGrid) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/OccupancyGrid message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__OccupancyGrid__fini(msg: *mut nav_msgs__msg__OccupancyGrid);
}
extern "C" {
    #[doc = " Create msg/OccupancyGrid message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* nav_msgs__msg__OccupancyGrid__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn nav_msgs__msg__OccupancyGrid__create() -> *mut nav_msgs__msg__OccupancyGrid;
}
extern "C" {
    #[doc = " Destroy msg/OccupancyGrid message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* nav_msgs__msg__OccupancyGrid__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__OccupancyGrid__destroy(msg: *mut nav_msgs__msg__OccupancyGrid);
}
extern "C" {
    #[doc = " Check for msg/OccupancyGrid message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__OccupancyGrid__are_equal(
        lhs: *const nav_msgs__msg__OccupancyGrid,
        rhs: *const nav_msgs__msg__OccupancyGrid,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/OccupancyGrid message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__OccupancyGrid__copy(
        input: *const nav_msgs__msg__OccupancyGrid,
        output: *mut nav_msgs__msg__OccupancyGrid,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/OccupancyGrid messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* nav_msgs__msg__OccupancyGrid__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__OccupancyGrid__Sequence__init(
        array: *mut nav_msgs__msg__OccupancyGrid__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/OccupancyGrid messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* nav_msgs__msg__OccupancyGrid__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__OccupancyGrid__Sequence__fini(
        array: *mut nav_msgs__msg__OccupancyGrid__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/OccupancyGrid messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* nav_msgs__msg__OccupancyGrid__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn nav_msgs__msg__OccupancyGrid__Sequence__create(
        size: size_t,
    ) -> *mut nav_msgs__msg__OccupancyGrid__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/OccupancyGrid messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* nav_msgs__msg__OccupancyGrid__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__OccupancyGrid__Sequence__destroy(
        array: *mut nav_msgs__msg__OccupancyGrid__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/OccupancyGrid message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__OccupancyGrid__Sequence__are_equal(
        lhs: *const nav_msgs__msg__OccupancyGrid__Sequence,
        rhs: *const nav_msgs__msg__OccupancyGrid__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/OccupancyGrid messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__OccupancyGrid__Sequence__copy(
        input: *const nav_msgs__msg__OccupancyGrid__Sequence,
        output: *mut nav_msgs__msg__OccupancyGrid__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__nav_msgs__msg__OccupancyGrid(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nav_msgs__msg__Odometry {
    pub header: std_msgs__msg__Header,
    pub child_frame_id: rosidl_runtime_c__String,
    pub pose: geometry_msgs__msg__PoseWithCovariance,
    pub twist: geometry_msgs__msg__TwistWithCovariance,
}
#[test]
fn bindgen_test_layout_nav_msgs__msg__Odometry() {
    assert_eq!(
        ::std::mem::size_of::<nav_msgs__msg__Odometry>(),
        736usize,
        concat!("Size of: ", stringify!(nav_msgs__msg__Odometry))
    );
    assert_eq!(
        ::std::mem::align_of::<nav_msgs__msg__Odometry>(),
        8usize,
        concat!("Alignment of ", stringify!(nav_msgs__msg__Odometry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nav_msgs__msg__Odometry>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__Odometry),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__Odometry>())).child_frame_id as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__Odometry),
            "::",
            stringify!(child_frame_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nav_msgs__msg__Odometry>())).pose as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__Odometry),
            "::",
            stringify!(pose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nav_msgs__msg__Odometry>())).twist as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__Odometry),
            "::",
            stringify!(twist)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nav_msgs__msg__Odometry__Sequence {
    pub data: *mut nav_msgs__msg__Odometry,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_nav_msgs__msg__Odometry__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<nav_msgs__msg__Odometry__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(nav_msgs__msg__Odometry__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<nav_msgs__msg__Odometry__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(nav_msgs__msg__Odometry__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__Odometry__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__Odometry__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__Odometry__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__Odometry__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__Odometry__Sequence>())).capacity as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__Odometry__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Odometry message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* nav_msgs__msg__Odometry"]
    #[doc = "* )) before or use"]
    #[doc = "* nav_msgs__msg__Odometry__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn nav_msgs__msg__Odometry__init(msg: *mut nav_msgs__msg__Odometry) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Odometry message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__Odometry__fini(msg: *mut nav_msgs__msg__Odometry);
}
extern "C" {
    #[doc = " Create msg/Odometry message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* nav_msgs__msg__Odometry__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn nav_msgs__msg__Odometry__create() -> *mut nav_msgs__msg__Odometry;
}
extern "C" {
    #[doc = " Destroy msg/Odometry message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* nav_msgs__msg__Odometry__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__Odometry__destroy(msg: *mut nav_msgs__msg__Odometry);
}
extern "C" {
    #[doc = " Check for msg/Odometry message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__Odometry__are_equal(
        lhs: *const nav_msgs__msg__Odometry,
        rhs: *const nav_msgs__msg__Odometry,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Odometry message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__Odometry__copy(
        input: *const nav_msgs__msg__Odometry,
        output: *mut nav_msgs__msg__Odometry,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Odometry messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* nav_msgs__msg__Odometry__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__Odometry__Sequence__init(
        array: *mut nav_msgs__msg__Odometry__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Odometry messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* nav_msgs__msg__Odometry__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__Odometry__Sequence__fini(array: *mut nav_msgs__msg__Odometry__Sequence);
}
extern "C" {
    #[doc = " Create array of msg/Odometry messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* nav_msgs__msg__Odometry__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn nav_msgs__msg__Odometry__Sequence__create(
        size: size_t,
    ) -> *mut nav_msgs__msg__Odometry__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Odometry messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* nav_msgs__msg__Odometry__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__Odometry__Sequence__destroy(
        array: *mut nav_msgs__msg__Odometry__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/Odometry message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__Odometry__Sequence__are_equal(
        lhs: *const nav_msgs__msg__Odometry__Sequence,
        rhs: *const nav_msgs__msg__Odometry__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Odometry messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__Odometry__Sequence__copy(
        input: *const nav_msgs__msg__Odometry__Sequence,
        output: *mut nav_msgs__msg__Odometry__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__nav_msgs__msg__Odometry(
    ) -> *const rosidl_message_type_support_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nav_msgs__msg__Path {
    pub header: std_msgs__msg__Header,
    pub poses: geometry_msgs__msg__PoseStamped__Sequence,
}
#[test]
fn bindgen_test_layout_nav_msgs__msg__Path() {
    assert_eq!(
        ::std::mem::size_of::<nav_msgs__msg__Path>(),
        56usize,
        concat!("Size of: ", stringify!(nav_msgs__msg__Path))
    );
    assert_eq!(
        ::std::mem::align_of::<nav_msgs__msg__Path>(),
        8usize,
        concat!("Alignment of ", stringify!(nav_msgs__msg__Path))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nav_msgs__msg__Path>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__Path),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nav_msgs__msg__Path>())).poses as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__Path),
            "::",
            stringify!(poses)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nav_msgs__msg__Path__Sequence {
    pub data: *mut nav_msgs__msg__Path,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_nav_msgs__msg__Path__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<nav_msgs__msg__Path__Sequence>(),
        24usize,
        concat!("Size of: ", stringify!(nav_msgs__msg__Path__Sequence))
    );
    assert_eq!(
        ::std::mem::align_of::<nav_msgs__msg__Path__Sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(nav_msgs__msg__Path__Sequence))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__Path__Sequence>())).data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__Path__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__Path__Sequence>())).size as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__Path__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nav_msgs__msg__Path__Sequence>())).capacity as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nav_msgs__msg__Path__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/Path message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* nav_msgs__msg__Path"]
    #[doc = "* )) before or use"]
    #[doc = "* nav_msgs__msg__Path__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn nav_msgs__msg__Path__init(msg: *mut nav_msgs__msg__Path) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/Path message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__Path__fini(msg: *mut nav_msgs__msg__Path);
}
extern "C" {
    #[doc = " Create msg/Path message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* nav_msgs__msg__Path__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn nav_msgs__msg__Path__create() -> *mut nav_msgs__msg__Path;
}
extern "C" {
    #[doc = " Destroy msg/Path message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* nav_msgs__msg__Path__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__Path__destroy(msg: *mut nav_msgs__msg__Path);
}
extern "C" {
    #[doc = " Check for msg/Path message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__Path__are_equal(
        lhs: *const nav_msgs__msg__Path,
        rhs: *const nav_msgs__msg__Path,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/Path message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__Path__copy(
        input: *const nav_msgs__msg__Path,
        output: *mut nav_msgs__msg__Path,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/Path messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* nav_msgs__msg__Path__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__Path__Sequence__init(
        array: *mut nav_msgs__msg__Path__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/Path messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* nav_msgs__msg__Path__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__Path__Sequence__fini(array: *mut nav_msgs__msg__Path__Sequence);
}
extern "C" {
    #[doc = " Create array of msg/Path messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* nav_msgs__msg__Path__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn nav_msgs__msg__Path__Sequence__create(
        size: size_t,
    ) -> *mut nav_msgs__msg__Path__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/Path messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* nav_msgs__msg__Path__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__Path__Sequence__destroy(array: *mut nav_msgs__msg__Path__Sequence);
}
extern "C" {
    #[doc = " Check for msg/Path message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__Path__Sequence__are_equal(
        lhs: *const nav_msgs__msg__Path__Sequence,
        rhs: *const nav_msgs__msg__Path__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/Path messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn nav_msgs__msg__Path__Sequence__copy(
        input: *const nav_msgs__msg__Path__Sequence,
        output: *mut nav_msgs__msg__Path__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__nav_msgs__msg__Path(
    ) -> *const rosidl_message_type_support_t;
}
pub const diagnostic_msgs__msg__DiagnosticStatus__OK: ::std::os::raw::c_uint = 0;
#[doc = " Constant 'OK'."]
pub type _bindgen_ty_47 = ::std::os::raw::c_uint;
pub const diagnostic_msgs__msg__DiagnosticStatus__WARN: ::std::os::raw::c_uint = 1;
#[doc = " Constant 'WARN'."]
pub type _bindgen_ty_48 = ::std::os::raw::c_uint;
pub const diagnostic_msgs__msg__DiagnosticStatus__ERROR: ::std::os::raw::c_uint = 2;
#[doc = " Constant 'ERROR'."]
pub type _bindgen_ty_49 = ::std::os::raw::c_uint;
pub const diagnostic_msgs__msg__DiagnosticStatus__STALE: ::std::os::raw::c_uint = 3;
#[doc = " Constant 'STALE'."]
pub type _bindgen_ty_50 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct diagnostic_msgs__msg__KeyValue {
    pub key: rosidl_runtime_c__String,
    pub value: rosidl_runtime_c__String,
}
#[test]
fn bindgen_test_layout_diagnostic_msgs__msg__KeyValue() {
    assert_eq!(
        ::std::mem::size_of::<diagnostic_msgs__msg__KeyValue>(),
        48usize,
        concat!("Size of: ", stringify!(diagnostic_msgs__msg__KeyValue))
    );
    assert_eq!(
        ::std::mem::align_of::<diagnostic_msgs__msg__KeyValue>(),
        8usize,
        concat!("Alignment of ", stringify!(diagnostic_msgs__msg__KeyValue))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<diagnostic_msgs__msg__KeyValue>())).key as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(diagnostic_msgs__msg__KeyValue),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<diagnostic_msgs__msg__KeyValue>())).value as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(diagnostic_msgs__msg__KeyValue),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct diagnostic_msgs__msg__KeyValue__Sequence {
    pub data: *mut diagnostic_msgs__msg__KeyValue,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_diagnostic_msgs__msg__KeyValue__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<diagnostic_msgs__msg__KeyValue__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(diagnostic_msgs__msg__KeyValue__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<diagnostic_msgs__msg__KeyValue__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(diagnostic_msgs__msg__KeyValue__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<diagnostic_msgs__msg__KeyValue__Sequence>())).data as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(diagnostic_msgs__msg__KeyValue__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<diagnostic_msgs__msg__KeyValue__Sequence>())).size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(diagnostic_msgs__msg__KeyValue__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<diagnostic_msgs__msg__KeyValue__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(diagnostic_msgs__msg__KeyValue__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct diagnostic_msgs__msg__DiagnosticStatus {
    pub level: u8,
    pub name: rosidl_runtime_c__String,
    pub message: rosidl_runtime_c__String,
    pub hardware_id: rosidl_runtime_c__String,
    pub values: diagnostic_msgs__msg__KeyValue__Sequence,
}
#[test]
fn bindgen_test_layout_diagnostic_msgs__msg__DiagnosticStatus() {
    assert_eq!(
        ::std::mem::size_of::<diagnostic_msgs__msg__DiagnosticStatus>(),
        104usize,
        concat!(
            "Size of: ",
            stringify!(diagnostic_msgs__msg__DiagnosticStatus)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<diagnostic_msgs__msg__DiagnosticStatus>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(diagnostic_msgs__msg__DiagnosticStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<diagnostic_msgs__msg__DiagnosticStatus>())).level as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(diagnostic_msgs__msg__DiagnosticStatus),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<diagnostic_msgs__msg__DiagnosticStatus>())).name as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(diagnostic_msgs__msg__DiagnosticStatus),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<diagnostic_msgs__msg__DiagnosticStatus>())).message as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(diagnostic_msgs__msg__DiagnosticStatus),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<diagnostic_msgs__msg__DiagnosticStatus>())).hardware_id
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(diagnostic_msgs__msg__DiagnosticStatus),
            "::",
            stringify!(hardware_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<diagnostic_msgs__msg__DiagnosticStatus>())).values as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(diagnostic_msgs__msg__DiagnosticStatus),
            "::",
            stringify!(values)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct diagnostic_msgs__msg__DiagnosticStatus__Sequence {
    pub data: *mut diagnostic_msgs__msg__DiagnosticStatus,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_diagnostic_msgs__msg__DiagnosticStatus__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<diagnostic_msgs__msg__DiagnosticStatus__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(diagnostic_msgs__msg__DiagnosticStatus__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<diagnostic_msgs__msg__DiagnosticStatus__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(diagnostic_msgs__msg__DiagnosticStatus__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<diagnostic_msgs__msg__DiagnosticStatus__Sequence>())).data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(diagnostic_msgs__msg__DiagnosticStatus__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<diagnostic_msgs__msg__DiagnosticStatus__Sequence>())).size
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(diagnostic_msgs__msg__DiagnosticStatus__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<diagnostic_msgs__msg__DiagnosticStatus__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(diagnostic_msgs__msg__DiagnosticStatus__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct diagnostic_msgs__msg__DiagnosticArray {
    pub header: std_msgs__msg__Header,
    pub status: diagnostic_msgs__msg__DiagnosticStatus__Sequence,
}
#[test]
fn bindgen_test_layout_diagnostic_msgs__msg__DiagnosticArray() {
    assert_eq!(
        ::std::mem::size_of::<diagnostic_msgs__msg__DiagnosticArray>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(diagnostic_msgs__msg__DiagnosticArray)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<diagnostic_msgs__msg__DiagnosticArray>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(diagnostic_msgs__msg__DiagnosticArray)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<diagnostic_msgs__msg__DiagnosticArray>())).header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(diagnostic_msgs__msg__DiagnosticArray),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<diagnostic_msgs__msg__DiagnosticArray>())).status as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(diagnostic_msgs__msg__DiagnosticArray),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct diagnostic_msgs__msg__DiagnosticArray__Sequence {
    pub data: *mut diagnostic_msgs__msg__DiagnosticArray,
    #[doc = " The number of valid items in data"]
    pub size: size_t,
    #[doc = " The number of allocated items in data"]
    pub capacity: size_t,
}
#[test]
fn bindgen_test_layout_diagnostic_msgs__msg__DiagnosticArray__Sequence() {
    assert_eq!(
        ::std::mem::size_of::<diagnostic_msgs__msg__DiagnosticArray__Sequence>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(diagnostic_msgs__msg__DiagnosticArray__Sequence)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<diagnostic_msgs__msg__DiagnosticArray__Sequence>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(diagnostic_msgs__msg__DiagnosticArray__Sequence)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<diagnostic_msgs__msg__DiagnosticArray__Sequence>())).data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(diagnostic_msgs__msg__DiagnosticArray__Sequence),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<diagnostic_msgs__msg__DiagnosticArray__Sequence>())).size
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(diagnostic_msgs__msg__DiagnosticArray__Sequence),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<diagnostic_msgs__msg__DiagnosticArray__Sequence>())).capacity
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(diagnostic_msgs__msg__DiagnosticArray__Sequence),
            "::",
            stringify!(capacity)
        )
    );
}
extern "C" {
    #[doc = " Initialize msg/DiagnosticArray message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* diagnostic_msgs__msg__DiagnosticArray"]
    #[doc = "* )) before or use"]
    #[doc = "* diagnostic_msgs__msg__DiagnosticArray__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__DiagnosticArray__init(
        msg: *mut diagnostic_msgs__msg__DiagnosticArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/DiagnosticArray message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__DiagnosticArray__fini(
        msg: *mut diagnostic_msgs__msg__DiagnosticArray,
    );
}
extern "C" {
    #[doc = " Create msg/DiagnosticArray message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* diagnostic_msgs__msg__DiagnosticArray__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__DiagnosticArray__create(
    ) -> *mut diagnostic_msgs__msg__DiagnosticArray;
}
extern "C" {
    #[doc = " Destroy msg/DiagnosticArray message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* diagnostic_msgs__msg__DiagnosticArray__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__DiagnosticArray__destroy(
        msg: *mut diagnostic_msgs__msg__DiagnosticArray,
    );
}
extern "C" {
    #[doc = " Check for msg/DiagnosticArray message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__DiagnosticArray__are_equal(
        lhs: *const diagnostic_msgs__msg__DiagnosticArray,
        rhs: *const diagnostic_msgs__msg__DiagnosticArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/DiagnosticArray message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__DiagnosticArray__copy(
        input: *const diagnostic_msgs__msg__DiagnosticArray,
        output: *mut diagnostic_msgs__msg__DiagnosticArray,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/DiagnosticArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* diagnostic_msgs__msg__DiagnosticArray__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__DiagnosticArray__Sequence__init(
        array: *mut diagnostic_msgs__msg__DiagnosticArray__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/DiagnosticArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* diagnostic_msgs__msg__DiagnosticArray__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__DiagnosticArray__Sequence__fini(
        array: *mut diagnostic_msgs__msg__DiagnosticArray__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/DiagnosticArray messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* diagnostic_msgs__msg__DiagnosticArray__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__DiagnosticArray__Sequence__create(
        size: size_t,
    ) -> *mut diagnostic_msgs__msg__DiagnosticArray__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/DiagnosticArray messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* diagnostic_msgs__msg__DiagnosticArray__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__DiagnosticArray__Sequence__destroy(
        array: *mut diagnostic_msgs__msg__DiagnosticArray__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/DiagnosticArray message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__DiagnosticArray__Sequence__are_equal(
        lhs: *const diagnostic_msgs__msg__DiagnosticArray__Sequence,
        rhs: *const diagnostic_msgs__msg__DiagnosticArray__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/DiagnosticArray messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__DiagnosticArray__Sequence__copy(
        input: *const diagnostic_msgs__msg__DiagnosticArray__Sequence,
        output: *mut diagnostic_msgs__msg__DiagnosticArray__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__diagnostic_msgs__msg__DiagnosticArray(
    ) -> *const rosidl_message_type_support_t;
}
extern "C" {
    #[doc = " Initialize msg/DiagnosticStatus message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* diagnostic_msgs__msg__DiagnosticStatus"]
    #[doc = "* )) before or use"]
    #[doc = "* diagnostic_msgs__msg__DiagnosticStatus__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__DiagnosticStatus__init(
        msg: *mut diagnostic_msgs__msg__DiagnosticStatus,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/DiagnosticStatus message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__DiagnosticStatus__fini(
        msg: *mut diagnostic_msgs__msg__DiagnosticStatus,
    );
}
extern "C" {
    #[doc = " Create msg/DiagnosticStatus message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* diagnostic_msgs__msg__DiagnosticStatus__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__DiagnosticStatus__create(
    ) -> *mut diagnostic_msgs__msg__DiagnosticStatus;
}
extern "C" {
    #[doc = " Destroy msg/DiagnosticStatus message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* diagnostic_msgs__msg__DiagnosticStatus__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__DiagnosticStatus__destroy(
        msg: *mut diagnostic_msgs__msg__DiagnosticStatus,
    );
}
extern "C" {
    #[doc = " Check for msg/DiagnosticStatus message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__DiagnosticStatus__are_equal(
        lhs: *const diagnostic_msgs__msg__DiagnosticStatus,
        rhs: *const diagnostic_msgs__msg__DiagnosticStatus,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/DiagnosticStatus message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__DiagnosticStatus__copy(
        input: *const diagnostic_msgs__msg__DiagnosticStatus,
        output: *mut diagnostic_msgs__msg__DiagnosticStatus,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/DiagnosticStatus messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* diagnostic_msgs__msg__DiagnosticStatus__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__DiagnosticStatus__Sequence__init(
        array: *mut diagnostic_msgs__msg__DiagnosticStatus__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/DiagnosticStatus messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* diagnostic_msgs__msg__DiagnosticStatus__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__DiagnosticStatus__Sequence__fini(
        array: *mut diagnostic_msgs__msg__DiagnosticStatus__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/DiagnosticStatus messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* diagnostic_msgs__msg__DiagnosticStatus__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__DiagnosticStatus__Sequence__create(
        size: size_t,
    ) -> *mut diagnostic_msgs__msg__DiagnosticStatus__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/DiagnosticStatus messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* diagnostic_msgs__msg__DiagnosticStatus__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__DiagnosticStatus__Sequence__destroy(
        array: *mut diagnostic_msgs__msg__DiagnosticStatus__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/DiagnosticStatus message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__DiagnosticStatus__Sequence__are_equal(
        lhs: *const diagnostic_msgs__msg__DiagnosticStatus__Sequence,
        rhs: *const diagnostic_msgs__msg__DiagnosticStatus__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/DiagnosticStatus messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__DiagnosticStatus__Sequence__copy(
        input: *const diagnostic_msgs__msg__DiagnosticStatus__Sequence,
        output: *mut diagnostic_msgs__msg__DiagnosticStatus__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__diagnostic_msgs__msg__DiagnosticStatus(
    ) -> *const rosidl_message_type_support_t;
}
extern "C" {
    #[doc = " Initialize msg/KeyValue message."]
    #[doc = "**"]
    #[doc = "* If the init function is called twice for the same message without"]
    #[doc = "* calling fini inbetween previously allocated memory will be leaked."]
    #[doc = "* \\param[in,out] msg The previously allocated message pointer."]
    #[doc = "* Fields without a default value will not be initialized by this function."]
    #[doc = "* You might want to call memset(msg, 0, sizeof("]
    #[doc = "* diagnostic_msgs__msg__KeyValue"]
    #[doc = "* )) before or use"]
    #[doc = "* diagnostic_msgs__msg__KeyValue__create()"]
    #[doc = "* to allocate and initialize the message."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__KeyValue__init(msg: *mut diagnostic_msgs__msg__KeyValue) -> bool;
}
extern "C" {
    #[doc = " Finalize msg/KeyValue message."]
    #[doc = "**"]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__KeyValue__fini(msg: *mut diagnostic_msgs__msg__KeyValue);
}
extern "C" {
    #[doc = " Create msg/KeyValue message."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the message, sets the memory to zero, and"]
    #[doc = "* calls"]
    #[doc = "* diagnostic_msgs__msg__KeyValue__init()."]
    #[doc = "* \\return The pointer to the initialized message if successful,"]
    #[doc = "* otherwise NULL"]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__KeyValue__create() -> *mut diagnostic_msgs__msg__KeyValue;
}
extern "C" {
    #[doc = " Destroy msg/KeyValue message."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* diagnostic_msgs__msg__KeyValue__fini()"]
    #[doc = "* and frees the memory of the message."]
    #[doc = "* \\param[in,out] msg The allocated message pointer."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__KeyValue__destroy(msg: *mut diagnostic_msgs__msg__KeyValue);
}
extern "C" {
    #[doc = " Check for msg/KeyValue message equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message on the right hand size of the equality operator."]
    #[doc = "* \\return true if messages are equal, otherwise false."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__KeyValue__are_equal(
        lhs: *const diagnostic_msgs__msg__KeyValue,
        rhs: *const diagnostic_msgs__msg__KeyValue,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy a msg/KeyValue message."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source message pointer."]
    #[doc = "* \\param[out] output The target message pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer is null"]
    #[doc = "*   or memory allocation fails."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__KeyValue__copy(
        input: *const diagnostic_msgs__msg__KeyValue,
        output: *mut diagnostic_msgs__msg__KeyValue,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize array of msg/KeyValue messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the number of elements and calls"]
    #[doc = "* diagnostic_msgs__msg__KeyValue__init()"]
    #[doc = "* for each element of the array."]
    #[doc = "* \\param[in,out] array The allocated array pointer."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return true if initialization was successful, otherwise false"]
    #[doc = "* If the array pointer is valid and the size is zero it is guaranteed"]
    #[doc = "# to return true."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__KeyValue__Sequence__init(
        array: *mut diagnostic_msgs__msg__KeyValue__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Finalize array of msg/KeyValue messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* diagnostic_msgs__msg__KeyValue__fini()"]
    #[doc = "* for each element of the array and frees the memory for the number of"]
    #[doc = "* elements."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__KeyValue__Sequence__fini(
        array: *mut diagnostic_msgs__msg__KeyValue__Sequence,
    );
}
extern "C" {
    #[doc = " Create array of msg/KeyValue messages."]
    #[doc = "**"]
    #[doc = "* It allocates the memory for the array and calls"]
    #[doc = "* diagnostic_msgs__msg__KeyValue__Sequence__init()."]
    #[doc = "* \\param[in] size The size / capacity of the array."]
    #[doc = "* \\return The pointer to the initialized array if successful, otherwise NULL"]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__KeyValue__Sequence__create(
        size: size_t,
    ) -> *mut diagnostic_msgs__msg__KeyValue__Sequence;
}
extern "C" {
    #[doc = " Destroy array of msg/KeyValue messages."]
    #[doc = "**"]
    #[doc = "* It calls"]
    #[doc = "* diagnostic_msgs__msg__KeyValue__Sequence__fini()"]
    #[doc = "* on the array,"]
    #[doc = "* and frees the memory of the array."]
    #[doc = "* \\param[in,out] array The initialized array pointer."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__KeyValue__Sequence__destroy(
        array: *mut diagnostic_msgs__msg__KeyValue__Sequence,
    );
}
extern "C" {
    #[doc = " Check for msg/KeyValue message array equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs The message array on the left hand size of the equality operator."]
    #[doc = "* \\param[in] rhs The message array on the right hand size of the equality operator."]
    #[doc = "* \\return true if message arrays are equal in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__KeyValue__Sequence__are_equal(
        lhs: *const diagnostic_msgs__msg__KeyValue__Sequence,
        rhs: *const diagnostic_msgs__msg__KeyValue__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy an array of msg/KeyValue messages."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input The source array pointer."]
    #[doc = "* \\param[out] output The target array pointer, which must"]
    #[doc = "*   have been initialized before calling this function."]
    #[doc = "* \\return true if successful, or false if either pointer"]
    #[doc = "*   is null or memory allocation fails."]
    #[doc = "*/"]
    pub fn diagnostic_msgs__msg__KeyValue__Sequence__copy(
        input: *const diagnostic_msgs__msg__KeyValue__Sequence,
        output: *mut diagnostic_msgs__msg__KeyValue__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_typesupport_c__get_message_type_support_handle__diagnostic_msgs__msg__KeyValue(
    ) -> *const rosidl_message_type_support_t;
}
extern "C" {
    pub fn rosidl_runtime_c__float__Sequence__init(
        sequence: *mut rosidl_runtime_c__float__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__float__Sequence__fini(
        sequence: *mut rosidl_runtime_c__float__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__float__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__float__Sequence,
        rhs: *const rosidl_runtime_c__float__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__float__Sequence__copy(
        input: *const rosidl_runtime_c__float__Sequence,
        output: *mut rosidl_runtime_c__float__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__double__Sequence__init(
        sequence: *mut rosidl_runtime_c__double__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__double__Sequence__fini(
        sequence: *mut rosidl_runtime_c__double__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__double__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__double__Sequence,
        rhs: *const rosidl_runtime_c__double__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__double__Sequence__copy(
        input: *const rosidl_runtime_c__double__Sequence,
        output: *mut rosidl_runtime_c__double__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__long_double__Sequence__init(
        sequence: *mut rosidl_runtime_c__long_double__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__long_double__Sequence__fini(
        sequence: *mut rosidl_runtime_c__long_double__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__long_double__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__long_double__Sequence,
        rhs: *const rosidl_runtime_c__long_double__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__long_double__Sequence__copy(
        input: *const rosidl_runtime_c__long_double__Sequence,
        output: *mut rosidl_runtime_c__long_double__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__char__Sequence__init(
        sequence: *mut rosidl_runtime_c__char__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__char__Sequence__fini(sequence: *mut rosidl_runtime_c__char__Sequence);
}
extern "C" {
    pub fn rosidl_runtime_c__char__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__char__Sequence,
        rhs: *const rosidl_runtime_c__char__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__char__Sequence__copy(
        input: *const rosidl_runtime_c__char__Sequence,
        output: *mut rosidl_runtime_c__char__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__wchar__Sequence__init(
        sequence: *mut rosidl_runtime_c__wchar__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__wchar__Sequence__fini(
        sequence: *mut rosidl_runtime_c__wchar__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__wchar__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__wchar__Sequence,
        rhs: *const rosidl_runtime_c__wchar__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__wchar__Sequence__copy(
        input: *const rosidl_runtime_c__wchar__Sequence,
        output: *mut rosidl_runtime_c__wchar__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__boolean__Sequence__init(
        sequence: *mut rosidl_runtime_c__boolean__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__boolean__Sequence__fini(
        sequence: *mut rosidl_runtime_c__boolean__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__boolean__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__boolean__Sequence,
        rhs: *const rosidl_runtime_c__boolean__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__boolean__Sequence__copy(
        input: *const rosidl_runtime_c__boolean__Sequence,
        output: *mut rosidl_runtime_c__boolean__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__octet__Sequence__init(
        sequence: *mut rosidl_runtime_c__octet__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__octet__Sequence__fini(
        sequence: *mut rosidl_runtime_c__octet__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__octet__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__octet__Sequence,
        rhs: *const rosidl_runtime_c__octet__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__octet__Sequence__copy(
        input: *const rosidl_runtime_c__octet__Sequence,
        output: *mut rosidl_runtime_c__octet__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__uint8__Sequence__init(
        sequence: *mut rosidl_runtime_c__uint8__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__uint8__Sequence__fini(
        sequence: *mut rosidl_runtime_c__uint8__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__uint8__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__uint8__Sequence,
        rhs: *const rosidl_runtime_c__uint8__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__uint8__Sequence__copy(
        input: *const rosidl_runtime_c__uint8__Sequence,
        output: *mut rosidl_runtime_c__uint8__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__int8__Sequence__init(
        sequence: *mut rosidl_runtime_c__int8__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__int8__Sequence__fini(sequence: *mut rosidl_runtime_c__int8__Sequence);
}
extern "C" {
    pub fn rosidl_runtime_c__int8__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__int8__Sequence,
        rhs: *const rosidl_runtime_c__int8__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__int8__Sequence__copy(
        input: *const rosidl_runtime_c__int8__Sequence,
        output: *mut rosidl_runtime_c__int8__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__uint16__Sequence__init(
        sequence: *mut rosidl_runtime_c__uint16__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__uint16__Sequence__fini(
        sequence: *mut rosidl_runtime_c__uint16__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__uint16__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__uint16__Sequence,
        rhs: *const rosidl_runtime_c__uint16__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__uint16__Sequence__copy(
        input: *const rosidl_runtime_c__uint16__Sequence,
        output: *mut rosidl_runtime_c__uint16__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__int16__Sequence__init(
        sequence: *mut rosidl_runtime_c__int16__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__int16__Sequence__fini(
        sequence: *mut rosidl_runtime_c__int16__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__int16__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__int16__Sequence,
        rhs: *const rosidl_runtime_c__int16__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__int16__Sequence__copy(
        input: *const rosidl_runtime_c__int16__Sequence,
        output: *mut rosidl_runtime_c__int16__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__uint32__Sequence__init(
        sequence: *mut rosidl_runtime_c__uint32__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__uint32__Sequence__fini(
        sequence: *mut rosidl_runtime_c__uint32__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__uint32__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__uint32__Sequence,
        rhs: *const rosidl_runtime_c__uint32__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__uint32__Sequence__copy(
        input: *const rosidl_runtime_c__uint32__Sequence,
        output: *mut rosidl_runtime_c__uint32__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__int32__Sequence__init(
        sequence: *mut rosidl_runtime_c__int32__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__int32__Sequence__fini(
        sequence: *mut rosidl_runtime_c__int32__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__int32__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__int32__Sequence,
        rhs: *const rosidl_runtime_c__int32__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__int32__Sequence__copy(
        input: *const rosidl_runtime_c__int32__Sequence,
        output: *mut rosidl_runtime_c__int32__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__uint64__Sequence__init(
        sequence: *mut rosidl_runtime_c__uint64__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__uint64__Sequence__fini(
        sequence: *mut rosidl_runtime_c__uint64__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__uint64__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__uint64__Sequence,
        rhs: *const rosidl_runtime_c__uint64__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__uint64__Sequence__copy(
        input: *const rosidl_runtime_c__uint64__Sequence,
        output: *mut rosidl_runtime_c__uint64__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__int64__Sequence__init(
        sequence: *mut rosidl_runtime_c__int64__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__int64__Sequence__fini(
        sequence: *mut rosidl_runtime_c__int64__Sequence,
    );
}
extern "C" {
    pub fn rosidl_runtime_c__int64__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__int64__Sequence,
        rhs: *const rosidl_runtime_c__int64__Sequence,
    ) -> bool;
}
extern "C" {
    pub fn rosidl_runtime_c__int64__Sequence__copy(
        input: *const rosidl_runtime_c__int64__Sequence,
        output: *mut rosidl_runtime_c__int64__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " \\defgroup primitives_sequence_functions__legacy Sequence functions for legacy types for backward compatibility."]
    pub fn rosidl_runtime_c__bool__Sequence__init(
        sequence: *mut rosidl_runtime_c__boolean__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_FINI(bool)"]
    pub fn rosidl_runtime_c__bool__Sequence__fini(
        sequence: *mut rosidl_runtime_c__boolean__Sequence,
    );
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_EQ(bool)"]
    pub fn rosidl_runtime_c__bool__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__boolean__Sequence,
        rhs: *const rosidl_runtime_c__boolean__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_COPY(bool)"]
    pub fn rosidl_runtime_c__bool__Sequence__copy(
        input: *const rosidl_runtime_c__boolean__Sequence,
        output: *mut rosidl_runtime_c__boolean__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_INIT(byte)"]
    pub fn rosidl_runtime_c__byte__Sequence__init(
        sequence: *mut rosidl_runtime_c__octet__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_FINI(byte)"]
    pub fn rosidl_runtime_c__byte__Sequence__fini(sequence: *mut rosidl_runtime_c__octet__Sequence);
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_EQ(byte)"]
    pub fn rosidl_runtime_c__byte__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__octet__Sequence,
        rhs: *const rosidl_runtime_c__octet__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_COPY(byte)"]
    pub fn rosidl_runtime_c__byte__Sequence__copy(
        input: *const rosidl_runtime_c__octet__Sequence,
        output: *mut rosidl_runtime_c__octet__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_INIT(float32)"]
    pub fn rosidl_runtime_c__float32__Sequence__init(
        sequence: *mut rosidl_runtime_c__float__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_FINI(float32)"]
    pub fn rosidl_runtime_c__float32__Sequence__fini(
        sequence: *mut rosidl_runtime_c__float__Sequence,
    );
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_EQ(float32)"]
    pub fn rosidl_runtime_c__float32__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__float__Sequence,
        rhs: *const rosidl_runtime_c__float__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_COPY(float32)"]
    pub fn rosidl_runtime_c__float32__Sequence__copy(
        input: *const rosidl_runtime_c__float__Sequence,
        output: *mut rosidl_runtime_c__float__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_INIT(float64)"]
    pub fn rosidl_runtime_c__float64__Sequence__init(
        sequence: *mut rosidl_runtime_c__double__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_FINI(float64)"]
    pub fn rosidl_runtime_c__float64__Sequence__fini(
        sequence: *mut rosidl_runtime_c__double__Sequence,
    );
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_EQ(float64)"]
    pub fn rosidl_runtime_c__float64__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__double__Sequence,
        rhs: *const rosidl_runtime_c__double__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " See #ROSIDL_RUNTIME_C__DECLARE_PRIMITIVE_SEQUENCE_COPY(float64)"]
    pub fn rosidl_runtime_c__float64__Sequence__copy(
        input: *const rosidl_runtime_c__double__Sequence,
        output: *mut rosidl_runtime_c__double__Sequence,
    ) -> bool;
}
#[doc = " Upper boundary for #rosidl_runtime_c__String or #rosidl_runtime_c__U16String."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rosidl_runtime_c__String__bound {
    #[doc = " The number of characters in the string (excluding the null character)."]
    pub bound: size_t,
}
#[test]
fn bindgen_test_layout_rosidl_runtime_c__String__bound() {
    assert_eq!(
        ::std::mem::size_of::<rosidl_runtime_c__String__bound>(),
        8usize,
        concat!("Size of: ", stringify!(rosidl_runtime_c__String__bound))
    );
    assert_eq!(
        ::std::mem::align_of::<rosidl_runtime_c__String__bound>(),
        8usize,
        concat!("Alignment of ", stringify!(rosidl_runtime_c__String__bound))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rosidl_runtime_c__String__bound>())).bound as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rosidl_runtime_c__String__bound),
            "::",
            stringify!(bound)
        )
    );
}
extern "C" {
    #[doc = " Initialize a rosidl_runtime_c__String structure."]
    pub fn rosidl_runtime_c__String__init(str_: *mut rosidl_runtime_c__String) -> bool;
}
extern "C" {
    #[doc = " Deallocate the memory of the rosidl_runtime_c__String structure."]
    pub fn rosidl_runtime_c__String__fini(str_: *mut rosidl_runtime_c__String);
}
extern "C" {
    #[doc = " Copy rosidl_runtime_c__String structure content."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy that"]
    #[doc = "* plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input a pointer to a rosidl_runtime_c__String structure"]
    #[doc = "*   to copy from."]
    #[doc = "* \\param[out] output a pointer to an initialized rosidl_runtime_c__String"]
    #[doc = "*   structure to copy into."]
    #[doc = "* \\return true if successful, false if either pointer is null or memory"]
    #[doc = "*   allocation fails."]
    #[doc = "*/"]
    pub fn rosidl_runtime_c__String__copy(
        input: *const rosidl_runtime_c__String,
        output: *mut rosidl_runtime_c__String,
    ) -> bool;
}
extern "C" {
    #[doc = " Check for rosidl_runtime_c__String structure equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs a pointer to the left hand side of the equality operator."]
    #[doc = "* \\param[in] lhs a pointer to the right hand side of the equality operator."]
    #[doc = "* \\return true if rosidl_runtime_c__String structures are equal in size and content,"]
    #[doc = "*   otherwise false."]
    #[doc = "*/"]
    pub fn rosidl_runtime_c__String__are_equal(
        lhs: *const rosidl_runtime_c__String,
        rhs: *const rosidl_runtime_c__String,
    ) -> bool;
}
extern "C" {
    #[doc = " Assign the c string pointer of n characters to the rosidl_runtime_c__String structure."]
    pub fn rosidl_runtime_c__String__assignn(
        str_: *mut rosidl_runtime_c__String,
        value: *const ::std::os::raw::c_char,
        n: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Assign the c string pointer to the rosidl_runtime_c__String structure."]
    pub fn rosidl_runtime_c__String__assign(
        str_: *mut rosidl_runtime_c__String,
        value: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Initialize a rosidl_runtime_c__String__Sequence__init structure."]
    pub fn rosidl_runtime_c__String__Sequence__init(
        sequence: *mut rosidl_runtime_c__String__Sequence,
        size: size_t,
    ) -> bool;
}
extern "C" {
    #[doc = " Deallocate the memory of the string sequence structure."]
    pub fn rosidl_runtime_c__String__Sequence__fini(
        sequence: *mut rosidl_runtime_c__String__Sequence,
    );
}
extern "C" {
    #[doc = " Check for rosidl_runtime_c__String__Sequence structure equality."]
    #[doc = "**"]
    #[doc = "* \\param[in] lhs a pointer to the left hand side of the equality operator."]
    #[doc = "* \\param[in] lhs a pointer to the right hand side of the equality operator."]
    #[doc = "* \\return true if rosidl_runtime_c__String__Sequence structures are equal"]
    #[doc = "*   in size and content, otherwise false."]
    #[doc = "*/"]
    pub fn rosidl_runtime_c__String__Sequence__are_equal(
        lhs: *const rosidl_runtime_c__String__Sequence,
        rhs: *const rosidl_runtime_c__String__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Copy rosidl_runtime_c__String__Sequence structure content."]
    #[doc = "**"]
    #[doc = "* This functions performs a deep copy, as opposed to the shallow copy"]
    #[doc = "* that plain assignment yields."]
    #[doc = "*"]
    #[doc = "* \\param[in] input a pointer to a rosidl_runtime_c__String__Sequence"]
    #[doc = "*   structure to copy from."]
    #[doc = "* \\param[out] output a pointer to an initialized rosidl_runtime_c__String__Sequence"]
    #[doc = "*   structure to copy into."]
    #[doc = "* \\return true if successful, false if either pointer is null or memory"]
    #[doc = "*   allocation fails."]
    #[doc = "*/"]
    pub fn rosidl_runtime_c__String__Sequence__copy(
        input: *const rosidl_runtime_c__String__Sequence,
        output: *mut rosidl_runtime_c__String__Sequence,
    ) -> bool;
}
extern "C" {
    #[doc = " Create a rosidl_runtime_c__String__Sequence structure with a specific size."]
    pub fn rosidl_runtime_c__String__Sequence__create(
        size: size_t,
    ) -> *mut rosidl_runtime_c__String__Sequence;
}
extern "C" {
    #[doc = " Destroy a rosidl_runtime_c__String__Sequence structure."]
    pub fn rosidl_runtime_c__String__Sequence__destroy(
        sequence: *mut rosidl_runtime_c__String__Sequence,
    );
}
